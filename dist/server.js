#!/usr/bin/env node
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path2 = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports3.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports3.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports3.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports3.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        (function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        })()
      );
      var ChangeAnnotations = (
        /** @class */
        (function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        })()
      );
      var WorkspaceChange = (
        /** @class */
        (function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        })()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports3.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports3.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument2(uri, languageId, version, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        (function() {
          function FullTextDocument3(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        })()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports2.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_12 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_12.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection;
  }
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path2 = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path2.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path2.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path2.join(prefix, "node_modules");
          } else {
            return path2.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path2.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path2.normalize(child).indexOf(path2.normalize(parent)) === 0;
        } else {
          return path2.normalize(child).toLowerCase().indexOf(path2.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path2.isAbsolute(nodePath)) {
          nodePath = path2.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("node:util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_12 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports2.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_12.ConnectionStrategy.is(arg1) || node_12.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_12.IPCMessageReader(process);
            output = new node_12.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_12.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_12.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_12.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message = String(label);
        let counter = counters.get(message) ?? 0;
        counter += 1;
        counters.set(message, counter);
        logger.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log(...args) {
        logger.log(serialize(args));
      };
      console.error = function error(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  TextDocument: () => TextDocument
});
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument, TextDocument;
var init_main = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument = class _FullTextDocument {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version) {
        for (const change of changes) {
          if (_FullTextDocument.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (_FullTextDocument.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          const mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
          return lineOffset;
        }
        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
      }
      ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
          offset--;
        }
        return offset;
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument2) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument2.create = create;
      function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
          document.update(changes, version);
          return document;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument2.update = update;
      function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          const diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          const startOffset = document.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument2.applyEdits = applyEdits;
    })(TextDocument || (TextDocument = {}));
  }
});

// node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
    !(function(t, e) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = e();
      else if ("function" == typeof define && define.amd) define([], e);
      else {
        var r = e();
        for (var n in r) ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
      }
    })(exports2, (() => (() => {
      "use strict";
      var t = { 975: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", i = 0, o = -1, s = 0, a = 0; a <= t3.length; ++a) {
            if (a < t3.length) r3 = t3.charCodeAt(a);
            else {
              if (47 === r3) break;
              r3 = 47;
            }
            if (47 === r3) {
              if (o === a - 1 || 1 === s) ;
              else if (o !== a - 1 && 2 === s) {
                if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), o = a, s = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", i = 0, o = a, s = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
              } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, a) : n3 = t3.slice(o + 1, a), i = a - o - 1;
              o = a, s = 0;
            } else 46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
            var s;
            o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
          }
          return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length) return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var i = arguments[r3];
            e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3) return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
          for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
          for (var o = t3.length, s = o - i, a = 1; a < r3.length && 47 === r3.charCodeAt(a); ++a) ;
          for (var h = r3.length - a, c = s < h ? s : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(a + u)) return r3.slice(a + u + 1);
                if (0 === u) return r3.slice(a + u);
              } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(i + u);
            if (l !== r3.charCodeAt(a + u)) break;
            47 === l && (f = u);
          }
          var d = "";
          for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
          return d.length > 0 ? d + r3.slice(a + f) : (a += f, 47 === r3.charCodeAt(a) && ++a, r3.slice(a));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else o = false;
          return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, i = 0, o = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3) return "";
            var a = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else -1 === h && (s = false, h = n3 + 1), a >= 0 && (c === r3.charCodeAt(a) ? -1 == --a && (o = n3) : (a = -1, o = h));
            }
            return i === o ? o = h : -1 === o && (o = t3.length), t3.slice(i, o);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === o && (s = false, o = n3 + 1);
          return -1 === o ? "" : t3.slice(i, o);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, a = t3.length - 1; a >= 0; --a) {
            var h = t3.charCodeAt(a);
            if (47 !== h) -1 === i && (o = false, i = a + 1), 46 === h ? -1 === r3 ? r3 = a : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
            else if (!o) {
              n3 = a + 1;
              break;
            }
          }
          return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return (function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          })(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length) return r3;
          var n3, i = t3.charCodeAt(0), o = 47 === i;
          o ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var s = -1, a = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === h && (c = false, h = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            a = f + 1;
            break;
          }
          return -1 === s || -1 === h || 0 === u || 1 === u && s === h - 1 && s === a + 1 ? -1 !== h && (r3.base = r3.name = 0 === a && o ? t3.slice(1, h) : t3.slice(a, h)) : (0 === a && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(a, s), r3.base = t3.slice(a, h)), r3.ext = t3.slice(s, h)), a > 0 ? r3.dir = t3.slice(0, a - 1) : o && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 70: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process) e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          let t3 = navigator.userAgent;
          e2.isWindows = t3.indexOf("Windows") >= 0;
        }
      }, 231: (t2, e2, r2) => {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        const n2 = r2(70), i = /^\w[\w\d+.-]*$/, o = /^\//, s = /^\/\//;
        function a(t3, e3) {
          if (!t3.scheme && e3) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
          if (t3.scheme && !i.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!o.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (s.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        const h = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class u {
          static isUri(t3) {
            return t3 instanceof u || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }
          scheme;
          authority;
          path;
          query;
          fragment;
          constructor(t3, e3, r3, n3, i2, o2 = false) {
            "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ (function(t4, e4) {
              return t4 || e4 ? t4 : "file";
            })(t3, o2), this.authority = e3 || h, this.path = (function(t4, e4) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== c && (e4 = c + e4) : e4 = c;
              }
              return e4;
            })(this.scheme, r3 || h), this.query = n3 || h, this.fragment = i2 || h, a(this, o2));
          }
          get fsPath() {
            return v(this, false);
          }
          with(t3) {
            if (!t3) return this;
            let { scheme: e3, authority: r3, path: n3, query: i2, fragment: o2 } = t3;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = h), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r3 === this.authority && n3 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e3, r3, n3, i2, o2);
          }
          static parse(t3, e3 = false) {
            const r3 = f.exec(t3);
            return r3 ? new d(r3[2] || h, w(r3[4] || h), w(r3[5] || h), w(r3[7] || h), w(r3[9] || h), e3) : new d(h, h, h, h, h);
          }
          static file(t3) {
            let e3 = h;
            if (n2.isWindows && (t3 = t3.replace(/\\/g, c)), t3[0] === c && t3[1] === c) {
              const r3 = t3.indexOf(c, 2);
              -1 === r3 ? (e3 = t3.substring(2), t3 = c) : (e3 = t3.substring(2, r3), t3 = t3.substring(r3) || c);
            }
            return new d("file", e3, t3, h, h);
          }
          static from(t3) {
            const e3 = new d(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return a(e3, true), e3;
          }
          toString(t3 = false) {
            return y(this, t3);
          }
          toJSON() {
            return this;
          }
          static revive(t3) {
            if (t3) {
              if (t3 instanceof u) return t3;
              {
                const e3 = new d(t3);
                return e3._formatted = t3.external, e3._fsPath = t3._sep === l ? t3.fsPath : null, e3;
              }
            }
            return t3;
          }
        }
        e2.URI = u;
        const l = n2.isWindows ? 1 : void 0;
        class d extends u {
          _formatted = null;
          _fsPath = null;
          get fsPath() {
            return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
          }
          toString(t3 = false) {
            return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
          }
          toJSON() {
            const t3 = { $mid: 1 };
            return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = l), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
          }
        }
        const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
        function g(t3, e3, r3) {
          let n3, i2 = -1;
          for (let o2 = 0; o2 < t3.length; o2++) {
            const s2 = t3.charCodeAt(o2);
            if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r3 && 91 === s2 || r3 && 93 === s2 || r3 && 58 === s2) -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n3 && (n3 += t3.charAt(o2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, o2));
              const e4 = p[s2];
              void 0 !== e4 ? (-1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n3 += e4) : -1 === i2 && (i2 = o2);
            }
          }
          return -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2))), void 0 !== n3 ? n3 : t3;
        }
        function m(t3) {
          let e3;
          for (let r3 = 0; r3 < t3.length; r3++) {
            const n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += p[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function v(t3, e3) {
          let r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? `//${t3.authority}${t3.path}` : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function y(t3, e3) {
          const r3 = e3 ? m : g;
          let n3 = "", { scheme: i2, authority: o2, path: s2, query: a2, fragment: h2 } = t3;
          if (i2 && (n3 += i2, n3 += ":"), (o2 || "file" === i2) && (n3 += c, n3 += c), o2) {
            let t4 = o2.indexOf("@");
            if (-1 !== t4) {
              const e4 = o2.substr(0, t4);
              o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n3 += r3(e4, false, false) : (n3 += r3(e4.substr(0, t4), false, false), n3 += ":", n3 += r3(e4.substr(t4 + 1), false, true)), n3 += "@";
            }
            o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n3 += r3(o2, false, true) : (n3 += r3(o2.substr(0, t4), false, true), n3 += o2.substr(t4));
          }
          if (s2) {
            if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
              const t4 = s2.charCodeAt(1);
              t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
            } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
              const t4 = s2.charCodeAt(0);
              t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
            }
            n3 += r3(s2, true, false);
          }
          return a2 && (n3 += "?", n3 += r3(a2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : g(h2, false, false)), n3;
        }
        function b(t3) {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3.length > 3 ? t3.substr(0, 3) + b(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = v;
        const C = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function w(t3) {
          return t3.match(C) ? t3.replace(C, ((t4) => b(t4))) : t3;
        }
      }, 552: function(t2, e2, r2) {
        var n2 = this && this.__createBinding || (Object.create ? function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3);
          var i2 = Object.getOwnPropertyDescriptor(e3, r3);
          i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return e3[r3];
          } }), Object.defineProperty(t3, n3, i2);
        } : function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3), t3[n3] = e3[r3];
        }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
          Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
        } : function(t3, e3) {
          t3.default = e3;
        }), o = this && this.__importStar || function(t3) {
          if (t3 && t3.__esModule) return t3;
          var e3 = {};
          if (null != t3) for (var r3 in t3) "default" !== r3 && Object.prototype.hasOwnProperty.call(t3, r3) && n2(e3, t3, r3);
          return i(e3, t3), e3;
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        const s = o(r2(975)), a = s.posix || s, h = "/";
        var c;
        !(function(t3) {
          t3.joinPath = function(t4, ...e3) {
            return t4.with({ path: a.join(t4.path, ...e3) });
          }, t3.resolvePath = function(t4, ...e3) {
            let r3 = t4.path, n3 = false;
            r3[0] !== h && (r3 = h + r3, n3 = true);
            let i2 = a.resolve(r3, ...e3);
            return n3 && i2[0] === h && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === h) return t4;
            let e3 = a.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return a.basename(t4.path);
          }, t3.extname = function(t4) {
            return a.extname(t4.path);
          };
        })(c || (e2.Utils = c = {}));
      } }, e = {};
      function r(n2) {
        var i = e[n2];
        if (void 0 !== i) return i.exports;
        var o = e[n2] = { exports: {} };
        return t[n2].call(o.exports, o, o.exports, r), o.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        const e2 = r(231);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        const i = r(552);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return i.Utils;
        } });
      })(), n;
    })()));
  }
});

// node_modules/@isaacs/balanced-match/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/@isaacs/balanced-match/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.range = exports2.balanced = void 0;
    var balanced = (a, b, str) => {
      const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
      const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
      const r = ma !== null && mb != null && (0, exports2.range)(ma, mb, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length)
      };
    };
    exports2.balanced = balanced;
    var maybeMatch = (reg, str) => {
      const m = str.match(reg);
      return m ? m[0] : null;
    };
    var range = (a, b, str) => {
      let begs, beg, left, right = void 0, result;
      let ai = str.indexOf(a);
      let bi = str.indexOf(b, ai + 1);
      let i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i === ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length === 1) {
            const r = begs.pop();
            if (r !== void 0)
              result = [r, bi];
          } else {
            beg = begs.pop();
            if (beg !== void 0 && beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== void 0) {
          result = [left, right];
        }
      }
      return result;
    };
    exports2.range = range;
  }
});

// node_modules/@isaacs/brace-expansion/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/@isaacs/brace-expansion/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand = expand;
    var balanced_match_1 = require_commonjs();
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    var escSlashPattern = new RegExp(escSlash, "g");
    var escOpenPattern = new RegExp(escOpen, "g");
    var escClosePattern = new RegExp(escClose, "g");
    var escCommaPattern = new RegExp(escComma, "g");
    var escPeriodPattern = new RegExp(escPeriod, "g");
    var slashPattern = /\\\\/g;
    var openPattern = /\\{/g;
    var closePattern = /\\}/g;
    var commaPattern = /\\,/g;
    var periodPattern = /\\./g;
    function numeric(str) {
      return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
    }
    function unescapeBraces(str) {
      return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
    }
    function parseCommaParts(str) {
      if (!str) {
        return [""];
      }
      const parts = [];
      const m = (0, balanced_match_1.balanced)("{", "}", str);
      if (!m) {
        return str.split(",");
      }
      const { pre, body, post } = m;
      const p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      const postParts = parseCommaParts(post);
      if (post.length) {
        ;
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expand(str) {
      if (!str) {
        return [];
      }
      if (str.slice(0, 2) === "{}") {
        str = "\\{\\}" + str.slice(2);
      }
      return expand_(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand_(str, isTop) {
      const expansions = [];
      const m = (0, balanced_match_1.balanced)("{", "}", str);
      if (!m)
        return [str];
      const pre = m.pre;
      const post = m.post.length ? expand_(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
          const expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand_(str);
          }
          return [str];
        }
        let n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1 && n[0] !== void 0) {
            n = expand_(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map((p) => m.pre + n[0] + p);
            }
          }
        }
        let N;
        if (isSequence && n[0] !== void 0 && n[1] !== void 0) {
          const x = numeric(n[0]);
          const y = numeric(n[1]);
          const width = Math.max(n[0].length, n[1].length);
          let incr = n.length === 3 && n[2] !== void 0 ? Math.abs(numeric(n[2])) : 1;
          let test = lte;
          const reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          const pad = n.some(isPadded);
          N = [];
          for (let i = x; test(i, y); i += incr) {
            let c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\") {
                c = "";
              }
            } else {
              c = String(i);
              if (pad) {
                const need = width - c.length;
                if (need > 0) {
                  const z = new Array(need + 1).join("0");
                  if (i < 0) {
                    c = "-" + z + c.slice(1);
                  } else {
                    c = z + c;
                  }
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (let j = 0; j < n.length; j++) {
            N.push.apply(N, expand_(n[j], false));
          }
        }
        for (let j = 0; j < N.length; j++) {
          for (let k = 0; k < post.length; k++) {
            const expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion) {
              expansions.push(expansion);
            }
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
      if (magicalBraces) {
        return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
      }
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\{}])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
    };
    exports2.unescape = unescape;
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp = p.#parent;
          while (pp) {
            for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i]);
              }
            }
            p = pp;
            pp = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
          const pp = p.#parts[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c.copyIn(p);
        }
        return c;
      }
      static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i2 = pos;
          let acc2 = "";
          while (i2 < str.length) {
            const c = str.charAt(i2++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc2 += c;
              continue;
            }
            if (inBrace) {
              if (i2 === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i2;
              braceNeg = false;
              acc2 += c;
              continue;
            }
            if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext = new _AST(c, ast);
              i2 = _AST.#parseAST(str, ext, i2, opt);
              ast.push(ext);
              continue;
            }
            acc2 += c;
          }
          ast.push(acc2);
          return i2;
        }
        let i = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i < str.length) {
          const c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc += c;
            continue;
          }
          if (inBrace) {
            if (i === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i;
            braceNeg = false;
            acc += c;
            continue;
          }
          if (isExtglobType(c) && str.charAt(i) === "(") {
            part.push(acc);
            acc = "";
            const ext = new _AST(c, part);
            part.push(ext);
            i = _AST.#parseAST(str, ext, i, opt);
            continue;
          }
          if (c === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i;
          }
          acc += c;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str.substring(pos - 1)];
        return i;
      }
      static fromGlob(pattern, options = {}) {
        const ast = new _AST(null, void 0, options);
        _AST.#parseAST(pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s) => typeof s !== "string");
          const src = this.#parts.map((p) => {
            const [re, _, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
          const c = glob.charAt(i);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c) ? "\\" : "") + c;
            continue;
          }
          if (c === "\\") {
            if (i === glob.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c === "[") {
            const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
            if (consumed) {
              re += src;
              uflag = uflag || needUflag;
              i += consumed - 1;
              hasMagic = hasMagic || magic;
              continue;
            }
          }
          if (c === "*") {
            re += noEmpty && glob === "*" ? starNoEmpty : star;
            hasMagic = true;
            continue;
          }
          if (c === "?") {
            re += qmark;
            hasMagic = true;
            continue;
          }
          re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
      }
    };
    exports2.AST = AST;
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape = (s, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
      if (magicalBraces) {
        return windowsPathsNoEscape ? s.replace(/[?*()[\]{}]/g, "[$&]") : s.replace(/[?*()[\]\\{}]/g, "\\$&");
      }
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape;
  }
});

// node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/css-variable-lsp/node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = require_commonjs2();
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    exports2.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path2 = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p) => (0, exports2.minimatch)(p, pattern, options);
    exports2.filter = filter;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.expand)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp.forEach((p, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = exports2.GLOBSTAR;
            }
          });
          const filtered = pp.filter((p) => p !== exports2.GLOBSTAR);
          if (this.partial && filtered.length >= 1) {
            const prefixes = [];
            for (let i = 1; i <= filtered.length; i++) {
              prefixes.push(filtered.slice(0, i).join("/"));
            }
            return "(?:" + prefixes.join("|") + ")";
          }
          return filtered.join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.partial) {
          re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
        }
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/path-scurry/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/path-scurry/node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #onInsert;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      #perf;
      /**
       * {@link LRUCache.OptionsBase.perf}
       */
      get perf() {
        return this.#perf;
      }
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      #hasOnInsert;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.onInsert} (read-only)
       */
      get onInsert() {
        return this.#onInsert;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
        if (perf !== void 0) {
          if (typeof perf?.now !== "function") {
            throw new TypeError("perf option must have a now() method if specified");
          }
        }
        this.#perf = perf ?? defaultPerf;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof onInsert === "function") {
          this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = this.#perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (this.#perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = this.#perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = this.#perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
          if (this.#hasOnInsert) {
            this.#onInsert?.(v, k, "add");
          }
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
          if (this.#hasOnInsert) {
            this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          const vl = this.#valList[index];
          if (vl === p || ignoreAbort && updateCache && vl === void 0) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching !== void 0) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("node:events");
    var node_stream_1 = __importDefault(require("node:stream"));
    var node_string_decoder_1 = require("node:string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var Minipass = class extends node_events_1.EventEmitter {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options = args[0] || {};
        super();
        if (options.objectMode && typeof options.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options)) {
          this[ENCODING] = options.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs6 = __commonJS({
  "node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs4();
    var node_path_1 = require("node:path");
    var node_url_1 = require("node:url");
    var fs_1 = require("fs");
    var actualFS = __importStar(require("node:fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("node:fs/promises");
    var minipass_1 = require_commonjs5();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = new lru_cache_1.LRUCache({ max: 2 ** 12 });
    var normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = new lru_cache_1.LRUCache({ max: 2 ** 12 });
    var normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /* c8 ignore start */
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       *
       * @deprecated
       */
      get path() {
        return this.parentPath;
      }
      /* c8 ignore stop */
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path2) {
        if (!path2) {
          return this;
        }
        const rootPath = this.getRootString(path2);
        const dir = path2.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (p.#matchName === name) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p = children.provisional; p < children.length; p++) {
          const c = children[p];
          if (c)
            c.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
      }
      #readdirAddNewChild(e, c) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
          const pchild = c[p];
          const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c);
        }
      }
      #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index !== c.provisional) {
          if (index === c.length - 1)
            c.pop();
          else
            c.splice(index, 1);
          c.unshift(p);
        }
        c.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path2) {
        return node_path_1.win32.parse(path2).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare, root] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare)) {
            return this.roots[rootPath] = root;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path2) {
        return path2.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = (0, node_url_1.fileURLToPath)(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path2 = this.cwd) {
        if (typeof path2 === "string") {
          path2 = this.cwd.resolve(path2);
        }
        return path2.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter || filter(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        if (!filter || filter(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter || filter(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter || filter(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path2 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path2 === "string" ? this.cwd.resolve(path2) : path2;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path_1.posix, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs3();
    var isPatternList = (pl) => pl.length >= 1;
    var isGlobList = (gl) => gl.length >= 1;
    var Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs3();
    var pattern_js_1 = require_pattern();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
          const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs3();
    var HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path2, n]) => [
          path2,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root) {
            t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs5();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path2, opts) {
        this.patterns = patterns;
        this.path = path2;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path2) {
        return this.seen.has(path2) || !!this.#ignore?.ignored?.(path2);
      }
      #childrenIgnored(path2) {
        return !!this.#ignore?.childrenIgnored?.(path2);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path2, opts) {
        super(patterns, path2, opts);
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path2, opts) {
        super(patterns, path2, opts);
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs3();
    var node_url_1 = require("node:url");
    var path_scurry_1 = require_commonjs6();
    var pattern_js_1 = require_pattern();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs3();
    var hasMagic = (pattern, options = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/index.js
var require_commonjs7 = __commonJS({
  "node_modules/css-variable-lsp/node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.Ignore = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = void 0;
    exports2.globStreamSync = globStreamSync;
    exports2.globStream = globStream;
    exports2.globSync = globSync;
    exports2.globIterateSync = globIterateSync;
    exports2.globIterate = globIterate;
    var minimatch_1 = require_commonjs3();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    var minimatch_2 = require_commonjs3();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    var ignore_js_1 = require_ignore();
    Object.defineProperty(exports2, "Ignore", { enumerable: true, get: function() {
      return ignore_js_1.Ignore;
    } });
    function globStreamSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).streamSync();
    }
    function globStream(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).stream();
    }
    function globSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walkSync();
    }
    async function glob_(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walk();
    }
    function globIterateSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterateSync();
    }
    function globIterate(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterate();
    }
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/css-tree/cjs/tokenizer/types.cjs
var require_types = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/types.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    var Ident = 1;
    var Function = 2;
    var AtKeyword = 3;
    var Hash = 4;
    var String2 = 5;
    var BadString = 6;
    var Url = 7;
    var BadUrl = 8;
    var Delim = 9;
    var Number2 = 10;
    var Percentage = 11;
    var Dimension = 12;
    var WhiteSpace = 13;
    var CDO = 14;
    var CDC = 15;
    var Colon = 16;
    var Semicolon = 17;
    var Comma = 18;
    var LeftSquareBracket = 19;
    var RightSquareBracket = 20;
    var LeftParenthesis = 21;
    var RightParenthesis = 22;
    var LeftCurlyBracket = 23;
    var RightCurlyBracket = 24;
    var Comment = 25;
    exports2.AtKeyword = AtKeyword;
    exports2.BadString = BadString;
    exports2.BadUrl = BadUrl;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.Colon = Colon;
    exports2.Comma = Comma;
    exports2.Comment = Comment;
    exports2.Delim = Delim;
    exports2.Dimension = Dimension;
    exports2.EOF = EOF;
    exports2.Function = Function;
    exports2.Hash = Hash;
    exports2.Ident = Ident;
    exports2.LeftCurlyBracket = LeftCurlyBracket;
    exports2.LeftParenthesis = LeftParenthesis;
    exports2.LeftSquareBracket = LeftSquareBracket;
    exports2.Number = Number2;
    exports2.Percentage = Percentage;
    exports2.RightCurlyBracket = RightCurlyBracket;
    exports2.RightParenthesis = RightParenthesis;
    exports2.RightSquareBracket = RightSquareBracket;
    exports2.Semicolon = Semicolon;
    exports2.String = String2;
    exports2.Url = Url;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs
var require_char_code_definitions = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isHexDigit(code) {
      return isDigit(code) || // 0 .. 9
      code >= 65 && code <= 70 || // A .. F
      code >= 97 && code <= 102;
    }
    function isUppercaseLetter(code) {
      return code >= 65 && code <= 90;
    }
    function isLowercaseLetter(code) {
      return code >= 97 && code <= 122;
    }
    function isLetter(code) {
      return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    function isNonAscii(code) {
      return code >= 128;
    }
    function isNameStart(code) {
      return isLetter(code) || isNonAscii(code) || code === 95;
    }
    function isName(code) {
      return isNameStart(code) || isDigit(code) || code === 45;
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function isNewline(code) {
      return code === 10 || code === 13 || code === 12;
    }
    function isWhiteSpace(code) {
      return isNewline(code) || code === 32 || code === 9;
    }
    function isValidEscape(first, second) {
      if (first !== 92) {
        return false;
      }
      if (isNewline(second) || second === EOF) {
        return false;
      }
      return true;
    }
    function isIdentifierStart(first, second, third) {
      if (first === 45) {
        return isNameStart(second) || second === 45 || isValidEscape(second, third);
      }
      if (isNameStart(first)) {
        return true;
      }
      if (first === 92) {
        return isValidEscape(first, second);
      }
      return false;
    }
    function isNumberStart(first, second, third) {
      if (first === 43 || first === 45) {
        if (isDigit(second)) {
          return 2;
        }
        return second === 46 && isDigit(third) ? 3 : 0;
      }
      if (first === 46) {
        return isDigit(second) ? 2 : 0;
      }
      if (isDigit(first)) {
        return 1;
      }
      return 0;
    }
    function isBOM(code) {
      if (code === 65279) {
        return 1;
      }
      if (code === 65534) {
        return 1;
      }
      return 0;
    }
    var CATEGORY = new Array(128);
    var EofCategory = 128;
    var WhiteSpaceCategory = 130;
    var DigitCategory = 131;
    var NameStartCategory = 132;
    var NonPrintableCategory = 133;
    for (let i = 0; i < CATEGORY.length; i++) {
      CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
    }
    function charCodeCategory(code) {
      return code < 128 ? CATEGORY[code] : NameStartCategory;
    }
    exports2.DigitCategory = DigitCategory;
    exports2.EofCategory = EofCategory;
    exports2.NameStartCategory = NameStartCategory;
    exports2.NonPrintableCategory = NonPrintableCategory;
    exports2.WhiteSpaceCategory = WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeCategory;
    exports2.isBOM = isBOM;
    exports2.isDigit = isDigit;
    exports2.isHexDigit = isHexDigit;
    exports2.isIdentifierStart = isIdentifierStart;
    exports2.isLetter = isLetter;
    exports2.isLowercaseLetter = isLowercaseLetter;
    exports2.isName = isName;
    exports2.isNameStart = isNameStart;
    exports2.isNewline = isNewline;
    exports2.isNonAscii = isNonAscii;
    exports2.isNonPrintable = isNonPrintable;
    exports2.isNumberStart = isNumberStart;
    exports2.isUppercaseLetter = isUppercaseLetter;
    exports2.isValidEscape = isValidEscape;
    exports2.isWhiteSpace = isWhiteSpace;
  }
});

// node_modules/css-tree/cjs/tokenizer/utils.cjs
var require_utils = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/utils.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    function getCharCode(source, offset) {
      return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
      if (code === 13 && getCharCode(source, offset + 1) === 10) {
        return 2;
      }
      return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
      let code = testStr.charCodeAt(offset);
      if (charCodeDefinitions.isUppercaseLetter(code)) {
        code = code | 32;
      }
      return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
      if (end - start !== referenceStr.length) {
        return false;
      }
      if (start < 0 || end > testStr.length) {
        return false;
      }
      for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);
        if (charCodeDefinitions.isUppercaseLetter(testCode)) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function findWhiteSpaceStart(source, offset) {
      for (; offset >= 0; offset--) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function findDecimalNumberEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function consumeEscaped(source, offset) {
      offset += 2;
      if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
          if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
            break;
          }
        }
        const code = getCharCode(source, offset);
        if (charCodeDefinitions.isWhiteSpace(code)) {
          offset += getNewlineLength(source, offset, code);
        }
      }
      return offset;
    }
    function consumeName(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (charCodeDefinitions.isName(code)) {
          continue;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset) - 1;
          continue;
        }
        break;
      }
      return offset;
    }
    function consumeNumber(source, offset) {
      let code = source.charCodeAt(offset);
      if (code === 43 || code === 45) {
        code = source.charCodeAt(offset += 1);
      }
      if (charCodeDefinitions.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
      }
      if (code === 46 && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
        offset += 2;
        offset = findDecimalNumberEnd(source, offset);
      }
      if (cmpChar(
        source,
        offset,
        101
        /* e */
      )) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);
        if (code === 45 || code === 43) {
          sign = 1;
          code = source.charCodeAt(offset + 2);
        }
        if (charCodeDefinitions.isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
      }
      return offset;
    }
    function consumeBadUrlRemnants(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (code === 41) {
          offset++;
          break;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset);
        }
      }
      return offset;
    }
    function decodeEscaped(escaped) {
      if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
      }
      let code = parseInt(escaped, 16);
      if (code === 0 || // If this number is zero,
      code >= 55296 && code <= 57343 || // or is for a surrogate,
      code > 1114111) {
        code = 65533;
      }
      return String.fromCodePoint(code);
    }
    exports2.cmpChar = cmpChar;
    exports2.cmpStr = cmpStr;
    exports2.consumeBadUrlRemnants = consumeBadUrlRemnants;
    exports2.consumeEscaped = consumeEscaped;
    exports2.consumeName = consumeName;
    exports2.consumeNumber = consumeNumber;
    exports2.decodeEscaped = decodeEscaped;
    exports2.findDecimalNumberEnd = findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = findWhiteSpaceStart;
    exports2.getNewlineLength = getNewlineLength;
  }
});

// node_modules/css-tree/cjs/tokenizer/names.cjs
var require_names = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/names.cjs"(exports2, module2) {
    "use strict";
    var tokenNames = [
      "EOF-token",
      "ident-token",
      "function-token",
      "at-keyword-token",
      "hash-token",
      "string-token",
      "bad-string-token",
      "url-token",
      "bad-url-token",
      "delim-token",
      "number-token",
      "percentage-token",
      "dimension-token",
      "whitespace-token",
      "CDO-token",
      "CDC-token",
      "colon-token",
      "semicolon-token",
      "comma-token",
      "[-token",
      "]-token",
      "(-token",
      ")-token",
      "{-token",
      "}-token",
      "comment-token"
    ];
    module2.exports = tokenNames;
  }
});

// node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs
var require_adopt_buffer = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs"(exports2) {
    "use strict";
    var MIN_SIZE = 16 * 1024;
    function adoptBuffer(buffer = null, size) {
      if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
      }
      return buffer;
    }
    exports2.adoptBuffer = adoptBuffer;
  }
});

// node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs
var require_OffsetToLocation = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer();
    var charCodeDefinitions = require_char_code_definitions();
    var N = 10;
    var F = 12;
    var R = 13;
    function computeLinesAndColumns(host) {
      const source = host.source;
      const sourceLength = source.length;
      const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
      const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
      const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
      let line = host.startLine;
      let column = host.startColumn;
      for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);
        lines[i] = line;
        columns[i] = column++;
        if (code === N || code === R || code === F) {
          if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
            i++;
            lines[i] = line;
            columns[i] = column;
          }
          line++;
          column = 1;
        }
      }
      lines[sourceLength] = line;
      columns[sourceLength] = column;
      host.lines = lines;
      host.columns = columns;
      host.computed = true;
    }
    var OffsetToLocation = class {
      constructor(source, startOffset, startLine, startColumn) {
        this.setSource(source, startOffset, startLine, startColumn);
        this.lines = null;
        this.columns = null;
      }
      setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
      }
      getLocation(offset, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          offset: this.startOffset + offset,
          line: this.lines[offset],
          column: this.columns[offset]
        };
      }
      getLocationRange(start, end, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
          },
          end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
          }
        };
      }
    };
    exports2.OffsetToLocation = OffsetToLocation;
  }
});

// node_modules/css-tree/cjs/tokenizer/TokenStream.cjs
var require_TokenStream = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/TokenStream.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer();
    var utils = require_utils();
    var names = require_names();
    var types = require_types();
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    var balancePair = new Uint8Array(32);
    balancePair[types.Function] = types.RightParenthesis;
    balancePair[types.LeftParenthesis] = types.RightParenthesis;
    balancePair[types.LeftSquareBracket] = types.RightSquareBracket;
    balancePair[types.LeftCurlyBracket] = types.RightCurlyBracket;
    function isBlockOpenerToken(tokenType) {
      return balancePair[tokenType] !== 0;
    }
    var TokenStream = class {
      constructor(source, tokenize) {
        this.setSource(source, tokenize);
      }
      reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
      }
      setSource(source = "", tokenize = () => {
      }) {
        source = String(source || "");
        const sourceLength = source.length;
        const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1);
        const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let firstCharOffset = -1;
        let balanceCloseType = 0;
        let balanceStart = source.length;
        this.offsetAndType = null;
        this.balance = null;
        balance.fill(0);
        tokenize(source, (type, start, end) => {
          const index = tokenCount++;
          offsetAndType[index] = type << TYPE_SHIFT | end;
          if (firstCharOffset === -1) {
            firstCharOffset = start;
          }
          balance[index] = balanceStart;
          if (type === balanceCloseType) {
            const prevBalanceStart = balance[balanceStart];
            balance[balanceStart] = index;
            balanceStart = prevBalanceStart;
            balanceCloseType = balancePair[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
          } else if (isBlockOpenerToken(type)) {
            balanceStart = index;
            balanceCloseType = balancePair[type];
          }
        });
        offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength;
        balance[tokenCount] = tokenCount;
        for (let i = 0; i < tokenCount; i++) {
          const balanceStart2 = balance[i];
          if (balanceStart2 <= i) {
            const balanceEnd = balance[balanceStart2];
            if (balanceEnd !== i) {
              balance[i] = balanceEnd;
            }
          } else if (balanceStart2 > tokenCount) {
            balance[i] = tokenCount;
          }
        }
        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;
        this.reset();
        this.next();
      }
      lookupType(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset] >> TYPE_SHIFT;
        }
        return types.EOF;
      }
      lookupTypeNonSC(idx) {
        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
          const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;
          if (tokenType !== types.WhiteSpace && tokenType !== types.Comment) {
            if (idx-- === 0) {
              return tokenType;
            }
          }
        }
        return types.EOF;
      }
      lookupOffset(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }
        return this.source.length;
      }
      lookupOffsetNonSC(idx) {
        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
          const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;
          if (tokenType !== types.WhiteSpace && tokenType !== types.Comment) {
            if (idx-- === 0) {
              return offset - this.tokenIndex;
            }
          }
        }
        return types.EOF;
      }
      lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return utils.cmpStr(
            this.source,
            this.offsetAndType[offset - 1] & OFFSET_MASK,
            this.offsetAndType[offset] & OFFSET_MASK,
            referenceStr
          );
        }
        return false;
      }
      getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
          return this.tokenStart;
        }
        if (tokenIndex > 0) {
          return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }
        return this.firstCharOffset;
      }
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      }
      isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
      }
      isDelim(code, offset) {
        if (offset) {
          return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
        }
        return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;
      }
      skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.next();
        }
      }
      next() {
        let next = this.tokenIndex + 1;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.tokenEnd;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.eof = true;
          this.tokenIndex = this.tokenCount;
          this.tokenType = types.EOF;
          this.tokenStart = this.tokenEnd = this.source.length;
        }
      }
      skipSC() {
        while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {
          this.next();
        }
      }
      skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd = 0;
        let offset = 0;
        loop:
          for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
            switch (stopConsume(this.source.charCodeAt(offset))) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
                  cursor = balanceEnd;
                }
            }
          }
        this.skip(cursor - this.tokenIndex);
      }
      forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
          const start = offset;
          const item = this.offsetAndType[i];
          const end = item & OFFSET_MASK;
          const type = item >> TYPE_SHIFT;
          offset = end;
          fn(type, start, end, i);
        }
      }
      dump() {
        const tokens = new Array(this.tokenCount);
        this.forEachToken((type, start, end, index) => {
          tokens[index] = {
            idx: index,
            type: names[type],
            chunk: this.source.substring(start, end),
            balance: this.balance[index]
          };
        });
        return tokens;
      }
    };
    exports2.TokenStream = TokenStream;
  }
});

// node_modules/css-tree/cjs/tokenizer/index.cjs
var require_tokenizer = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/index.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var names = require_names();
    var OffsetToLocation = require_OffsetToLocation();
    var TokenStream = require_TokenStream();
    function tokenize(source, onToken) {
      function getCharCode(offset2) {
        return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
      }
      function consumeNumericToken() {
        offset = utils.consumeNumber(source, offset);
        if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
          type = types.Dimension;
          offset = utils.consumeName(source, offset);
          return;
        }
        if (getCharCode(offset) === 37) {
          type = types.Percentage;
          offset++;
          return;
        }
        type = types.Number;
      }
      function consumeIdentLikeToken() {
        const nameStartOffset = offset;
        offset = utils.consumeName(source, offset);
        if (utils.cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
          offset = utils.findWhiteSpaceEnd(source, offset + 1);
          if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
            type = types.Function;
            offset = nameStartOffset + 4;
            return;
          }
          consumeUrlToken();
          return;
        }
        if (getCharCode(offset) === 40) {
          type = types.Function;
          offset++;
          return;
        }
        type = types.Ident;
      }
      function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
          endingCodePoint = getCharCode(offset++);
        }
        type = types.String;
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // ending code point
            case endingCodePoint:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <string-token>.
            // return;
            // newline
            case charCodeDefinitions.WhiteSpaceCategory:
              if (charCodeDefinitions.isNewline(code)) {
                offset += utils.getNewlineLength(source, offset, code);
                type = types.BadString;
                return;
              }
              break;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (offset === source.length - 1) {
                break;
              }
              const nextCode = getCharCode(offset + 1);
              if (charCodeDefinitions.isNewline(nextCode)) {
                offset += utils.getNewlineLength(source, offset + 1, nextCode);
              } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
                offset = utils.consumeEscaped(source, offset) - 1;
              }
              break;
          }
        }
      }
      function consumeUrlToken() {
        type = types.Url;
        offset = utils.findWhiteSpaceEnd(source, offset);
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // U+0029 RIGHT PARENTHESIS ())
            case 41:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <url-token>.
            // return;
            // whitespace
            case charCodeDefinitions.WhiteSpaceCategory:
              offset = utils.findWhiteSpaceEnd(source, offset);
              if (getCharCode(offset) === 41 || offset >= source.length) {
                if (offset < source.length) {
                  offset++;
                }
                return;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+0022 QUOTATION MARK (")
            // U+0027 APOSTROPHE (')
            // U+0028 LEFT PARENTHESIS (()
            // non-printable code point
            case 34:
            case 39:
            case 40:
            case charCodeDefinitions.NonPrintableCategory:
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
                offset = utils.consumeEscaped(source, offset) - 1;
                break;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
          }
        }
      }
      source = String(source || "");
      const sourceLength = source.length;
      let start = charCodeDefinitions.isBOM(getCharCode(0));
      let offset = start;
      let type;
      while (offset < sourceLength) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          // whitespace
          case charCodeDefinitions.WhiteSpaceCategory:
            type = types.WhiteSpace;
            offset = utils.findWhiteSpaceEnd(source, offset + 1);
            break;
          // U+0022 QUOTATION MARK (")
          case 34:
            consumeStringToken();
            break;
          // U+0023 NUMBER SIGN (#)
          case 35:
            if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
              type = types.Hash;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0027 APOSTROPHE (')
          case 39:
            consumeStringToken();
            break;
          // U+0028 LEFT PARENTHESIS (()
          case 40:
            type = types.LeftParenthesis;
            offset++;
            break;
          // U+0029 RIGHT PARENTHESIS ())
          case 41:
            type = types.RightParenthesis;
            offset++;
            break;
          // U+002B PLUS SIGN (+)
          case 43:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002C COMMA (,)
          case 44:
            type = types.Comma;
            offset++;
            break;
          // U+002D HYPHEN-MINUS (-)
          case 45:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                type = types.CDC;
                offset = offset + 3;
              } else {
                if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                  consumeIdentLikeToken();
                } else {
                  type = types.Delim;
                  offset++;
                }
              }
            }
            break;
          // U+002E FULL STOP (.)
          case 46:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002F SOLIDUS (/)
          case 47:
            if (getCharCode(offset + 1) === 42) {
              type = types.Comment;
              offset = source.indexOf("*/", offset + 2);
              offset = offset === -1 ? source.length : offset + 2;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+003A COLON (:)
          case 58:
            type = types.Colon;
            offset++;
            break;
          // U+003B SEMICOLON (;)
          case 59:
            type = types.Semicolon;
            offset++;
            break;
          // U+003C LESS-THAN SIGN (<)
          case 60:
            if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
              type = types.CDO;
              offset = offset + 4;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0040 COMMERCIAL AT (@)
          case 64:
            if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
              type = types.AtKeyword;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005B LEFT SQUARE BRACKET ([)
          case 91:
            type = types.LeftSquareBracket;
            offset++;
            break;
          // U+005C REVERSE SOLIDUS (\)
          case 92:
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              consumeIdentLikeToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005D RIGHT SQUARE BRACKET (])
          case 93:
            type = types.RightSquareBracket;
            offset++;
            break;
          // U+007B LEFT CURLY BRACKET ({)
          case 123:
            type = types.LeftCurlyBracket;
            offset++;
            break;
          // U+007D RIGHT CURLY BRACKET (})
          case 125:
            type = types.RightCurlyBracket;
            offset++;
            break;
          // digit
          case charCodeDefinitions.DigitCategory:
            consumeNumericToken();
            break;
          // name-start code point
          case charCodeDefinitions.NameStartCategory:
            consumeIdentLikeToken();
            break;
          // EOF
          // case EofCategory:
          // Return an <EOF-token>.
          // break;
          // anything else
          default:
            type = types.Delim;
            offset++;
        }
        onToken(type, start, start = offset);
      }
    }
    exports2.AtKeyword = types.AtKeyword;
    exports2.BadString = types.BadString;
    exports2.BadUrl = types.BadUrl;
    exports2.CDC = types.CDC;
    exports2.CDO = types.CDO;
    exports2.Colon = types.Colon;
    exports2.Comma = types.Comma;
    exports2.Comment = types.Comment;
    exports2.Delim = types.Delim;
    exports2.Dimension = types.Dimension;
    exports2.EOF = types.EOF;
    exports2.Function = types.Function;
    exports2.Hash = types.Hash;
    exports2.Ident = types.Ident;
    exports2.LeftCurlyBracket = types.LeftCurlyBracket;
    exports2.LeftParenthesis = types.LeftParenthesis;
    exports2.LeftSquareBracket = types.LeftSquareBracket;
    exports2.Number = types.Number;
    exports2.Percentage = types.Percentage;
    exports2.RightCurlyBracket = types.RightCurlyBracket;
    exports2.RightParenthesis = types.RightParenthesis;
    exports2.RightSquareBracket = types.RightSquareBracket;
    exports2.Semicolon = types.Semicolon;
    exports2.String = types.String;
    exports2.Url = types.Url;
    exports2.WhiteSpace = types.WhiteSpace;
    exports2.tokenTypes = types;
    exports2.DigitCategory = charCodeDefinitions.DigitCategory;
    exports2.EofCategory = charCodeDefinitions.EofCategory;
    exports2.NameStartCategory = charCodeDefinitions.NameStartCategory;
    exports2.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
    exports2.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeDefinitions.charCodeCategory;
    exports2.isBOM = charCodeDefinitions.isBOM;
    exports2.isDigit = charCodeDefinitions.isDigit;
    exports2.isHexDigit = charCodeDefinitions.isHexDigit;
    exports2.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    exports2.isLetter = charCodeDefinitions.isLetter;
    exports2.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
    exports2.isName = charCodeDefinitions.isName;
    exports2.isNameStart = charCodeDefinitions.isNameStart;
    exports2.isNewline = charCodeDefinitions.isNewline;
    exports2.isNonAscii = charCodeDefinitions.isNonAscii;
    exports2.isNonPrintable = charCodeDefinitions.isNonPrintable;
    exports2.isNumberStart = charCodeDefinitions.isNumberStart;
    exports2.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
    exports2.isValidEscape = charCodeDefinitions.isValidEscape;
    exports2.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
    exports2.cmpChar = utils.cmpChar;
    exports2.cmpStr = utils.cmpStr;
    exports2.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
    exports2.consumeEscaped = utils.consumeEscaped;
    exports2.consumeName = utils.consumeName;
    exports2.consumeNumber = utils.consumeNumber;
    exports2.decodeEscaped = utils.decodeEscaped;
    exports2.findDecimalNumberEnd = utils.findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = utils.findWhiteSpaceStart;
    exports2.getNewlineLength = utils.getNewlineLength;
    exports2.tokenNames = names;
    exports2.OffsetToLocation = OffsetToLocation.OffsetToLocation;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.tokenize = tokenize;
  }
});

// node_modules/css-tree/cjs/utils/List.cjs
var require_List = __commonJS({
  "node_modules/css-tree/cjs/utils/List.cjs"(exports2) {
    "use strict";
    var releasedCursors = null;
    var List = class _List {
      static createItem(data) {
        return {
          prev: null,
          next: null,
          data
        };
      }
      constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
      }
      createItem(data) {
        return _List.createItem(data);
      }
      // cursor helpers
      allocateCursor(prev, next) {
        let cursor;
        if (releasedCursors !== null) {
          cursor = releasedCursors;
          releasedCursors = releasedCursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = this.cursor;
        } else {
          cursor = {
            prev,
            next,
            cursor: this.cursor
          };
        }
        this.cursor = cursor;
        return cursor;
      }
      releaseCursor() {
        const { cursor } = this;
        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
      }
      updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      }
      *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          yield cursor.data;
        }
      }
      // getters
      get size() {
        let size = 0;
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          size++;
        }
        return size;
      }
      get isEmpty() {
        return this.head === null;
      }
      get first() {
        return this.head && this.head.data;
      }
      get last() {
        return this.tail && this.tail.data;
      }
      // convertors
      fromArray(array) {
        let cursor = null;
        this.head = null;
        for (let data of array) {
          const item = _List.createItem(data);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      }
      toArray() {
        return [...this];
      }
      toJSON() {
        return [...this];
      }
      // array-like methods
      forEach(fn, thisArg = this) {
        const cursor = this.allocateCursor(null, this.head);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      forEachRight(fn, thisArg = this) {
        const cursor = this.allocateCursor(this.tail, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      reduce(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      reduceRight(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            return true;
          }
        }
        return false;
      }
      map(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }
        return result;
      }
      filter(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
        }
        return result;
      }
      nextUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(null, start);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      prevUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(start, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      // mutation
      clear() {
        this.head = null;
        this.tail = null;
      }
      copy() {
        const result = new _List();
        for (let data of this) {
          result.appendData(data);
        }
        return result;
      }
      prepend(item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      }
      prependData(data) {
        return this.prepend(_List.createItem(data));
      }
      append(item) {
        return this.insert(item);
      }
      appendData(data) {
        return this.insert(_List.createItem(data));
      }
      insert(item, before = null) {
        if (before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      }
      insertData(data, before) {
        return this.insert(_List.createItem(data), before);
      }
      remove(item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      }
      push(data) {
        this.insert(_List.createItem(data));
      }
      pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
      }
      unshift(data) {
        this.prepend(_List.createItem(data));
      }
      shift() {
        return this.head !== null ? this.remove(this.head) : null;
      }
      prependList(list) {
        return this.insertList(list, this.head);
      }
      appendList(list) {
        return this.insertList(list);
      }
      insertList(list, before) {
        if (list.head === null) {
          return this;
        }
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, list.tail, before, list.head);
          if (before.prev !== null) {
            before.prev.next = list.head;
            list.head.prev = before.prev;
          } else {
            this.head = list.head;
          }
          before.prev = list.tail;
          list.tail.next = before;
        } else {
          this.updateCursors(this.tail, list.tail, null, list.head);
          if (this.tail !== null) {
            this.tail.next = list.head;
            list.head.prev = this.tail;
          } else {
            this.head = list.head;
          }
          this.tail = list.tail;
        }
        list.head = null;
        list.tail = null;
        return this;
      }
      replace(oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      }
    };
    exports2.List = List;
  }
});

// node_modules/css-tree/cjs/utils/create-custom-error.cjs
var require_create_custom_error = __commonJS({
  "node_modules/css-tree/cjs/utils/create-custom-error.cjs"(exports2) {
    "use strict";
    function createCustomError(name, message) {
      const error = Object.create(SyntaxError.prototype);
      const errorStack = new Error();
      return Object.assign(error, {
        name,
        message,
        get stack() {
          return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
        }
      });
    }
    exports2.createCustomError = createCustomError;
  }
});

// node_modules/css-tree/cjs/parser/SyntaxError.cjs
var require_SyntaxError = __commonJS({
  "node_modules/css-tree/cjs/parser/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    var MAX_LINE_LENGTH = 100;
    var OFFSET_CORRECTION = 60;
    var TAB_REPLACEMENT = "    ";
    function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
      function processLines(start, end) {
        return lines.slice(start, end).map(
          (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
        ).join("\n");
      }
      const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
      const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
      const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
      const startLine = Math.max(1, line - extraLines) - 1;
      const endLine = Math.min(line + extraLines, lines.length + 1);
      const maxNumLength = Math.max(4, String(endLine).length) + 1;
      let cutLeft = 0;
      column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
      if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
      }
      for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
          lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
          lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
      }
      return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join("-") + "^",
        processLines(line, endLine)
      ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
    }
    function SyntaxError2(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {
      const error = Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
          return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
          return `Parse error: ${message}
` + sourceFragment({ source, line, column, baseLine, baseColumn }, 2);
        }
      });
      return error;
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/css-tree/cjs/parser/sequence.cjs
var require_sequence = __commonJS({
  "node_modules/css-tree/cjs/parser/sequence.cjs"(exports2) {
    "use strict";
    var types = require_types();
    function readSequence(recognizer) {
      const children = this.createList();
      let space = false;
      const context = {
        recognizer
      };
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
            this.next();
            continue;
          case types.WhiteSpace:
            space = true;
            this.next();
            continue;
        }
        let child = recognizer.getNode.call(this, context);
        if (child === void 0) {
          break;
        }
        if (space) {
          if (recognizer.onWhiteSpace) {
            recognizer.onWhiteSpace.call(this, child, children, context);
          }
          space = false;
        }
        children.push(child);
      }
      if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
      }
      return children;
    }
    exports2.readSequence = readSequence;
  }
});

// node_modules/css-tree/cjs/parser/create.cjs
var require_create = __commonJS({
  "node_modules/css-tree/cjs/parser/create.cjs"(exports2) {
    "use strict";
    var List = require_List();
    var SyntaxError2 = require_SyntaxError();
    var index = require_tokenizer();
    var sequence = require_sequence();
    var OffsetToLocation = require_OffsetToLocation();
    var TokenStream = require_TokenStream();
    var utils = require_utils();
    var types = require_types();
    var names = require_names();
    var NOOP = () => {
    };
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var SEMICOLON = 59;
    var LEFTCURLYBRACKET = 123;
    var NULL = 0;
    function createParseContext(name) {
      return function() {
        return this[name]();
      };
    }
    function fetchParseValues(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const name of Object.keys(dict)) {
        const item = dict[name];
        const fn = item.parse || item;
        if (fn) {
          result[name] = fn;
        }
      }
      return result;
    }
    function processConfig(config) {
      const parseConfig = {
        context: /* @__PURE__ */ Object.create(null),
        features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
        scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
      };
      for (const [name, context] of Object.entries(config.parseContext)) {
        switch (typeof context) {
          case "function":
            parseConfig.context[name] = context;
            break;
          case "string":
            parseConfig.context[name] = createParseContext(context);
            break;
        }
      }
      return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
      };
    }
    function createParser(config) {
      let source = "";
      let filename = "<unknown>";
      let needPositions = false;
      let onParseError = NOOP;
      let onParseErrorThrow = false;
      const locationMap = new OffsetToLocation.OffsetToLocation();
      const parser = Object.assign(new TokenStream.TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: sequence.readSequence,
        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
          return code === LEFTCURLYBRACKET ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
          return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
          return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
          return code === SEMICOLON ? 2 : 0;
        },
        createList() {
          return new List.List();
        },
        createSingleNodeList(node) {
          return new List.List().appendData(node);
        },
        getFirstListNode(list) {
          return list && list.first;
        },
        getLastListNode(list) {
          return list && list.last;
        },
        parseWithFallback(consumer, fallback) {
          const startIndex = this.tokenIndex;
          try {
            return consumer.call(this);
          } catch (e) {
            if (onParseErrorThrow) {
              throw e;
            }
            this.skip(startIndex - this.tokenIndex);
            const fallbackNode = fallback.call(this);
            onParseErrorThrow = true;
            onParseError(e, fallbackNode);
            onParseErrorThrow = false;
            return fallbackNode;
          }
        },
        lookupNonWSType(offset) {
          let type;
          do {
            type = this.lookupType(offset++);
            if (type !== types.WhiteSpace && type !== types.Comment) {
              return type;
            }
          } while (type !== NULL);
          return NULL;
        },
        charCodeAt(offset) {
          return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
          return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
          return this.source.substring(start, this.tokenStart);
        },
        cmpChar(offset, charCode) {
          return utils.cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
          return utils.cmpStr(source, offsetStart, offsetEnd, str);
        },
        consume(tokenType) {
          const start = this.tokenStart;
          this.eat(tokenType);
          return this.substrToCursor(start);
        },
        consumeFunctionName() {
          const name = source.substring(this.tokenStart, this.tokenEnd - 1);
          this.eat(types.Function);
          return name;
        },
        consumeNumber(type) {
          const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));
          this.eat(type);
          return number;
        },
        eat(tokenType) {
          if (this.tokenType !== tokenType) {
            const tokenName = names[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
            let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
            let offset = this.tokenStart;
            switch (tokenType) {
              case types.Ident:
                if (this.tokenType === types.Function || this.tokenType === types.Url) {
                  offset = this.tokenEnd - 1;
                  message = "Identifier is expected but function found";
                } else {
                  message = "Identifier is expected";
                }
                break;
              case types.Hash:
                if (this.isDelim(NUMBERSIGN)) {
                  this.next();
                  offset++;
                  message = "Name is expected";
                }
                break;
              case types.Percentage:
                if (this.tokenType === types.Number) {
                  offset = this.tokenEnd;
                  message = "Percent sign is expected";
                }
                break;
            }
            this.error(message, offset);
          }
          this.next();
        },
        eatIdent(name) {
          if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {
            this.error(`Identifier "${name}" is expected`);
          }
          this.next();
        },
        eatDelim(code) {
          if (!this.isDelim(code)) {
            this.error(`Delim "${String.fromCharCode(code)}" is expected`);
          }
          this.next();
        },
        getLocation(start, end) {
          if (needPositions) {
            return locationMap.getLocationRange(
              start,
              end,
              filename
            );
          }
          return null;
        },
        getLocationFromList(list) {
          if (needPositions) {
            const head = this.getFirstListNode(list);
            const tail = this.getLastListNode(list);
            return locationMap.getLocationRange(
              head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
              tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
              filename
            );
          }
          return null;
        },
        error(message, offset) {
          const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
          throw new SyntaxError2.SyntaxError(
            message || "Unexpected input",
            source,
            location.offset,
            location.line,
            location.column,
            locationMap.startLine,
            locationMap.startColumn
          );
        }
      });
      const parse = function(source_, options) {
        source = source_;
        options = options || {};
        parser.setSource(source, index.tokenize);
        locationMap.setSource(
          source,
          options.offset,
          options.line,
          options.column
        );
        filename = options.filename || "<unknown>";
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
        onParseErrorThrow = false;
        parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
        const { context = "default", onComment } = options;
        if (context in parser.context === false) {
          throw new Error("Unknown context `" + context + "`");
        }
        if (typeof onComment === "function") {
          parser.forEachToken((type, start, end) => {
            if (type === types.Comment) {
              const loc = parser.getLocation(start, end);
              const value = utils.cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
              onComment(value, loc);
            }
          });
        }
        const ast = parser.context[context].call(parser, options);
        if (!parser.eof) {
          parser.error();
        }
        return ast;
      };
      return Object.assign(parse, {
        SyntaxError: SyntaxError2.SyntaxError,
        config: parser.config
      });
    }
    exports2.createParser = createParser;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path2 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path2 = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path2);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path2.indexOf("/", start);
        if (i === -1) {
          parts.push(path2.slice(start));
          break;
        } else {
          parts.push(path2.slice(start, i));
          while (i < path2.length && path2[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path2;
        return urlGenerate(url);
      }
      return path2;
    });
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = (function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/css-tree/cjs/generator/sourceMap.cjs
var require_sourceMap = __commonJS({
  "node_modules/css-tree/cjs/generator/sourceMap.cjs"(exports2) {
    "use strict";
    var sourceMapGenerator_js = require_source_map_generator();
    var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
    function generateSourceMap(handlers) {
      const map = new sourceMapGenerator_js.SourceMapGenerator();
      const generated = {
        line: 1,
        column: 0
      };
      const original = {
        line: 0,
        // should be zero to add first mapping
        column: 0
      };
      const activatedGenerated = {
        line: 1,
        column: 0
      };
      const activatedMapping = {
        generated: activatedGenerated
      };
      let line = 1;
      let column = 0;
      let sourceMappingActive = false;
      const origHandlersNode = handlers.node;
      handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
          const nodeLine = node.loc.start.line;
          const nodeColumn = node.loc.start.column - 1;
          if (original.line !== nodeLine || original.column !== nodeColumn) {
            original.line = nodeLine;
            original.column = nodeColumn;
            generated.line = line;
            generated.column = column;
            if (sourceMappingActive) {
              sourceMappingActive = false;
              if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                map.addMapping(activatedMapping);
              }
            }
            sourceMappingActive = true;
            map.addMapping({
              source: node.loc.source,
              original,
              generated
            });
          }
        }
        origHandlersNode.call(this, node);
        if (sourceMappingActive && trackNodes.has(node.type)) {
          activatedGenerated.line = line;
          activatedGenerated.column = column;
        }
      };
      const origHandlersEmit = handlers.emit;
      handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
          if (value.charCodeAt(i) === 10) {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        origHandlersEmit(value, type, auto);
      };
      const origHandlersResult = handlers.result;
      handlers.result = function() {
        if (sourceMappingActive) {
          map.addMapping(activatedMapping);
        }
        return {
          css: origHandlersResult(),
          map
        };
      };
      return handlers;
    }
    exports2.generateSourceMap = generateSourceMap;
  }
});

// node_modules/css-tree/cjs/generator/token-before.cjs
var require_token_before = __commonJS({
  "node_modules/css-tree/cjs/generator/token-before.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var code = (type, value) => {
      if (type === types.Delim) {
        type = value;
      }
      if (typeof type === "string") {
        const charCode = type.charCodeAt(0);
        return charCode > 127 ? 32768 : charCode << 8;
      }
      return type;
    };
    var specPairs = [
      [types.Ident, types.Ident],
      [types.Ident, types.Function],
      [types.Ident, types.Url],
      [types.Ident, types.BadUrl],
      [types.Ident, "-"],
      [types.Ident, types.Number],
      [types.Ident, types.Percentage],
      [types.Ident, types.Dimension],
      [types.Ident, types.CDC],
      [types.Ident, types.LeftParenthesis],
      [types.AtKeyword, types.Ident],
      [types.AtKeyword, types.Function],
      [types.AtKeyword, types.Url],
      [types.AtKeyword, types.BadUrl],
      [types.AtKeyword, "-"],
      [types.AtKeyword, types.Number],
      [types.AtKeyword, types.Percentage],
      [types.AtKeyword, types.Dimension],
      [types.AtKeyword, types.CDC],
      [types.Hash, types.Ident],
      [types.Hash, types.Function],
      [types.Hash, types.Url],
      [types.Hash, types.BadUrl],
      [types.Hash, "-"],
      [types.Hash, types.Number],
      [types.Hash, types.Percentage],
      [types.Hash, types.Dimension],
      [types.Hash, types.CDC],
      [types.Dimension, types.Ident],
      [types.Dimension, types.Function],
      [types.Dimension, types.Url],
      [types.Dimension, types.BadUrl],
      [types.Dimension, "-"],
      [types.Dimension, types.Number],
      [types.Dimension, types.Percentage],
      [types.Dimension, types.Dimension],
      [types.Dimension, types.CDC],
      ["#", types.Ident],
      ["#", types.Function],
      ["#", types.Url],
      ["#", types.BadUrl],
      ["#", "-"],
      ["#", types.Number],
      ["#", types.Percentage],
      ["#", types.Dimension],
      ["#", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["-", types.Ident],
      ["-", types.Function],
      ["-", types.Url],
      ["-", types.BadUrl],
      ["-", "-"],
      ["-", types.Number],
      ["-", types.Percentage],
      ["-", types.Dimension],
      ["-", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [types.Number, types.Ident],
      [types.Number, types.Function],
      [types.Number, types.Url],
      [types.Number, types.BadUrl],
      [types.Number, types.Number],
      [types.Number, types.Percentage],
      [types.Number, types.Dimension],
      [types.Number, "%"],
      [types.Number, types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["@", types.Ident],
      ["@", types.Function],
      ["@", types.Url],
      ["@", types.BadUrl],
      ["@", "-"],
      ["@", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [".", types.Number],
      [".", types.Percentage],
      [".", types.Dimension],
      ["+", types.Number],
      ["+", types.Percentage],
      ["+", types.Dimension],
      ["/", "*"]
    ];
    var safePairs = specPairs.concat([
      [types.Ident, types.Hash],
      [types.Dimension, types.Hash],
      [types.Hash, types.Hash],
      [types.AtKeyword, types.LeftParenthesis],
      [types.AtKeyword, types.String],
      [types.AtKeyword, types.Colon],
      [types.Percentage, types.Percentage],
      [types.Percentage, types.Dimension],
      [types.Percentage, types.Function],
      [types.Percentage, "-"],
      [types.RightParenthesis, types.Ident],
      [types.RightParenthesis, types.Function],
      [types.RightParenthesis, types.Percentage],
      [types.RightParenthesis, types.Dimension],
      [types.RightParenthesis, types.Hash],
      [types.RightParenthesis, "-"]
    ]);
    function createMap(pairs) {
      const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => code(prev) << 16 | code(next))
      );
      return function(prevCode, type, value) {
        const nextCode = code(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs = nextCharCode === HYPHENMINUS && type !== types.Ident && type !== types.Function && type !== types.CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
        if (emitWs) {
          this.emit(" ", types.WhiteSpace, true);
        }
        return nextCode;
      };
    }
    var spec = createMap(specPairs);
    var safe = createMap(safePairs);
    exports2.safe = safe;
    exports2.spec = spec;
  }
});

// node_modules/css-tree/cjs/generator/create.cjs
var require_create2 = __commonJS({
  "node_modules/css-tree/cjs/generator/create.cjs"(exports2) {
    "use strict";
    var index = require_tokenizer();
    var sourceMap = require_sourceMap();
    var tokenBefore = require_token_before();
    var types = require_types();
    var REVERSESOLIDUS = 92;
    function processChildren(node, delimeter) {
      if (typeof delimeter === "function") {
        let prev = null;
        node.children.forEach((node2) => {
          if (prev !== null) {
            delimeter.call(this, prev);
          }
          this.node(node2);
          prev = node2;
        });
        return;
      }
      node.children.forEach(this.node, this);
    }
    function processChunk(chunk) {
      index.tokenize(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
      });
    }
    function createGenerator(config) {
      const types$1 = /* @__PURE__ */ new Map();
      for (let [name, item] of Object.entries(config.node)) {
        const fn = item.generate || item;
        if (typeof fn === "function") {
          types$1.set(name, item.generate || item);
        }
      }
      return function(node, options) {
        let buffer = "";
        let prevCode = 0;
        let handlers = {
          node(node2) {
            if (types$1.has(node2.type)) {
              types$1.get(node2.type).call(publicApi, node2);
            } else {
              throw new Error("Unknown node type: " + node2.type);
            }
          },
          tokenBefore: tokenBefore.safe,
          token(type, value) {
            prevCode = this.tokenBefore(prevCode, type, value);
            this.emit(value, type, false);
            if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
              this.emit("\n", types.WhiteSpace, true);
            }
          },
          emit(value) {
            buffer += value;
          },
          result() {
            return buffer;
          }
        };
        if (options) {
          if (typeof options.decorator === "function") {
            handlers = options.decorator(handlers);
          }
          if (options.sourceMap) {
            handlers = sourceMap.generateSourceMap(handlers);
          }
          if (options.mode in tokenBefore) {
            handlers.tokenBefore = tokenBefore[options.mode];
          }
        }
        const publicApi = {
          node: (node2) => handlers.node(node2),
          children: processChildren,
          token: (type, value) => handlers.token(type, value),
          tokenize: processChunk
        };
        handlers.node(node);
        return handlers.result();
      };
    }
    exports2.createGenerator = createGenerator;
  }
});

// node_modules/css-tree/cjs/convertor/create.cjs
var require_create3 = __commonJS({
  "node_modules/css-tree/cjs/convertor/create.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function createConvertor(walk) {
      return {
        fromPlainObject(ast) {
          walk(ast, {
            enter(node) {
              if (node.children && node.children instanceof List.List === false) {
                node.children = new List.List().fromArray(node.children);
              }
            }
          });
          return ast;
        },
        toPlainObject(ast) {
          walk(ast, {
            leave(node) {
              if (node.children && node.children instanceof List.List) {
                node.children = node.children.toArray();
              }
            }
          });
          return ast;
        }
      };
    }
    exports2.createConvertor = createConvertor;
  }
});

// node_modules/css-tree/cjs/walker/create.cjs
var require_create4 = __commonJS({
  "node_modules/css-tree/cjs/walker/create.cjs"(exports2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function invokeForType(fn, type) {
      return function(node, item, list) {
        if (node.type === type) {
          fn.call(this, node, item, list);
        }
      };
    }
    function getWalkersFromStructure(name, nodeType) {
      const structure = nodeType.structure;
      const walkers = [];
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        let fieldTypes = structure[key];
        const walker = {
          name: key,
          type: false,
          nullable: false
        };
        if (!Array.isArray(fieldTypes)) {
          fieldTypes = [fieldTypes];
        }
        for (const fieldType of fieldTypes) {
          if (fieldType === null) {
            walker.nullable = true;
          } else if (typeof fieldType === "string") {
            walker.type = "node";
          } else if (Array.isArray(fieldType)) {
            walker.type = "list";
          }
        }
        if (walker.type) {
          walkers.push(walker);
        }
      }
      if (walkers.length) {
        return {
          context: nodeType.walkContext,
          fields: walkers
        };
      }
      return null;
    }
    function getTypesFromConfig(config) {
      const types = {};
      for (const name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          const nodeType = config.node[name];
          if (!nodeType.structure) {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
          types[name] = getWalkersFromStructure(name, nodeType);
        }
      }
      return types;
    }
    function createTypeIterator(config, reverse) {
      const fields = config.fields.slice();
      const contextName = config.context;
      const useContext = typeof contextName === "string";
      if (reverse) {
        fields.reverse();
      }
      return function(node, context, walk, walkReducer) {
        let prevContextValue;
        if (useContext) {
          prevContextValue = context[contextName];
          context[contextName] = node;
        }
        for (const field of fields) {
          const ref = node[field.name];
          if (!field.nullable || ref) {
            if (field.type === "list") {
              const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
              if (breakWalk) {
                return true;
              }
            } else if (walk(ref)) {
              return true;
            }
          }
        }
        if (useContext) {
          context[contextName] = prevContextValue;
        }
      };
    }
    function createFastTraveralMap({
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }) {
      return {
        Atrule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Rule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Declaration: {
          StyleSheet,
          Atrule,
          Rule,
          Block,
          DeclarationList
        }
      };
    }
    function createWalker(config) {
      const types = getTypesFromConfig(config);
      const iteratorsNatural = {};
      const iteratorsReverse = {};
      const breakWalk = Symbol("break-walk");
      const skipNode = Symbol("skip-node");
      for (const name in types) {
        if (hasOwnProperty2.call(types, name) && types[name] !== null) {
          iteratorsNatural[name] = createTypeIterator(types[name], false);
          iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
      }
      const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
      const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
      const walk = function(root, options) {
        function walkNode(node, item, list) {
          const enterRet = enter.call(context, node, item, list);
          if (enterRet === breakWalk) {
            return true;
          }
          if (enterRet === skipNode) {
            return false;
          }
          if (iterators.hasOwnProperty(node.type)) {
            if (iterators[node.type](node, context, walkNode, walkReducer)) {
              return true;
            }
          }
          if (leave.call(context, node, item, list) === breakWalk) {
            return true;
          }
          return false;
        }
        let enter = noop;
        let leave = noop;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
          break: breakWalk,
          skip: skipNode,
          root,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
          if (options.reverse) {
            iterators = iteratorsReverse;
          }
          if (options.visit) {
            if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
              iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
            } else if (!types.hasOwnProperty(options.visit)) {
              throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
            }
            enter = invokeForType(enter, options.visit);
            leave = invokeForType(leave, options.visit);
          }
        }
        if (enter === noop && leave === noop) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walkNode(root);
      };
      walk.break = breakWalk;
      walk.skip = skipNode;
      walk.find = function(ast, fn) {
        let found = null;
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        });
        return found;
      };
      walk.findLast = function(ast, fn) {
        let found = null;
        walk(ast, {
          reverse: true,
          enter(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          }
        });
        return found;
      };
      walk.findAll = function(ast, fn) {
        const found = [];
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found.push(node);
          }
        });
        return found;
      };
      return walk;
    }
    exports2.createWalker = createWalker;
  }
});

// node_modules/css-tree/cjs/definition-syntax/generate.cjs
var require_generate = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/generate.cjs"(exports2) {
    "use strict";
    function noop(value) {
      return value;
    }
    function generateMultiplier(multiplier) {
      const { min, max, comma } = multiplier;
      if (min === 0 && max === 0) {
        return comma ? "#?" : "*";
      }
      if (min === 0 && max === 1) {
        return "?";
      }
      if (min === 1 && max === 0) {
        return comma ? "#" : "+";
      }
      if (min === 1 && max === 1) {
        return "";
      }
      return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
    }
    function generateTypeOpts(node) {
      switch (node.type) {
        case "Range":
          return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
    }
    function generateSequence(node, decorate, forceBraces, compact) {
      const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
      const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
      if (node.explicit || forceBraces) {
        return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
      }
      return result;
    }
    function internalGenerate(node, decorate, forceBraces, compact) {
      let result;
      switch (node.type) {
        case "Group":
          result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
        case "Boolean":
          result = "<boolean-expr[" + internalGenerate(node.term, decorate, forceBraces, compact) + "]>";
          break;
        case "Type":
          result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
          break;
        case "Property":
          result = "<'" + node.name + "'>";
          break;
        case "Keyword":
          result = node.name;
          break;
        case "AtKeyword":
          result = "@" + node.name;
          break;
        case "Function":
          result = node.name + "(";
          break;
        case "String":
        case "Token":
          result = node.value;
          break;
        case "Comma":
          result = ",";
          break;
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
      return decorate(result, node);
    }
    function generate(node, options) {
      let decorate = noop;
      let forceBraces = false;
      let compact = false;
      if (typeof options === "function") {
        decorate = options;
      } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === "function") {
          decorate = options.decorate;
        }
      }
      return internalGenerate(node, decorate, forceBraces, compact);
    }
    exports2.generate = generate;
  }
});

// node_modules/css-tree/cjs/lexer/error.cjs
var require_error = __commonJS({
  "node_modules/css-tree/cjs/lexer/error.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    var generate = require_generate();
    var defaultLoc = { offset: 0, line: 1, column: 1 };
    function locateMismatch(matchResult, node) {
      const tokens = matchResult.tokens;
      const longestMatch = matchResult.longestMatch;
      const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
      const badNode = mismatchNode !== node ? mismatchNode : null;
      let mismatchOffset = 0;
      let mismatchLength = 0;
      let entries = 0;
      let css = "";
      let start;
      let end;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;
        if (i === longestMatch) {
          mismatchLength = token.length;
          mismatchOffset = css.length;
        }
        if (badNode !== null && tokens[i].node === badNode) {
          if (i <= longestMatch) {
            entries++;
          } else {
            entries = 0;
          }
        }
        css += token;
      }
      if (longestMatch === tokens.length || entries > 1) {
        start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
        end = buildLoc(start);
      } else {
        start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
      }
      return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      };
    }
    function fromLoc(node, point) {
      const value = node && node.loc && node.loc[point];
      if (value) {
        return "line" in value ? buildLoc(value) : value;
      }
      return null;
    }
    function buildLoc({ offset, line, column }, extra) {
      const loc = {
        offset,
        line,
        column
      };
      if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);
        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
      }
      return loc;
    }
    var SyntaxReferenceError = function(type, referenceName) {
      const error = createCustomError.createCustomError(
        "SyntaxReferenceError",
        type + (referenceName ? " `" + referenceName + "`" : "")
      );
      error.reference = referenceName;
      return error;
    };
    var SyntaxMatchError = function(message, syntax, node, matchResult) {
      const error = createCustomError.createCustomError("SyntaxMatchError", message);
      const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      } = locateMismatch(matchResult, node);
      error.rawMessage = message;
      error.syntax = syntax ? generate.generate(syntax) : "<generic>";
      error.css = css;
      error.mismatchOffset = mismatchOffset;
      error.mismatchLength = mismatchLength;
      error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
      Object.assign(error, start);
      error.loc = {
        source: node && node.loc && node.loc.source || "<unknown>",
        start,
        end
      };
      return error;
    };
    exports2.SyntaxMatchError = SyntaxMatchError;
    exports2.SyntaxReferenceError = SyntaxReferenceError;
  }
});

// node_modules/css-tree/cjs/utils/names.cjs
var require_names2 = __commonJS({
  "node_modules/css-tree/cjs/utils/names.cjs"(exports2) {
    "use strict";
    var keywords = /* @__PURE__ */ new Map();
    var properties = /* @__PURE__ */ new Map();
    var HYPHENMINUS = 45;
    var keyword = getKeywordDescriptor;
    var property = getPropertyDescriptor;
    var vendorPrefix = getVendorPrefix;
    function isCustomProperty(str, offset) {
      offset = offset || 0;
      return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
    }
    function getVendorPrefix(str, offset) {
      offset = offset || 0;
      if (str.length - offset >= 3) {
        if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
          const secondDashIndex = str.indexOf("-", offset + 2);
          if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
          }
        }
      }
      return "";
    }
    function getKeywordDescriptor(keyword2) {
      if (keywords.has(keyword2)) {
        return keywords.get(keyword2);
      }
      const name = keyword2.toLowerCase();
      let descriptor = keywords.get(name);
      if (descriptor === void 0) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : "";
        descriptor = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          prefix: vendor,
          vendor,
          custom
        });
      }
      keywords.set(keyword2, descriptor);
      return descriptor;
    }
    function getPropertyDescriptor(property2) {
      if (properties.has(property2)) {
        return properties.get(property2);
      }
      let name = property2;
      let hack = property2[0];
      if (hack === "/") {
        hack = property2[1] === "/" ? "//" : "/";
      } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
        hack = "";
      }
      const custom = isCustomProperty(name, hack.length);
      if (!custom) {
        name = name.toLowerCase();
        if (properties.has(name)) {
          const descriptor2 = properties.get(name);
          properties.set(property2, descriptor2);
          return descriptor2;
        }
      }
      const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
      const prefix = name.substr(0, hack.length + vendor.length);
      const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
      });
      properties.set(property2, descriptor);
      return descriptor;
    }
    exports2.isCustomProperty = isCustomProperty;
    exports2.keyword = keyword;
    exports2.property = property;
    exports2.vendorPrefix = vendorPrefix;
  }
});

// node_modules/css-tree/cjs/lexer/generic-const.cjs
var require_generic_const = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-const.cjs"(exports2) {
    "use strict";
    var cssWideKeywords = [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ];
    exports2.cssWideKeywords = cssWideKeywords;
  }
});

// node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs
var require_generic_an_plus_b = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var types = require_types();
    var utils = require_utils();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function skipSC(token, offset, getNextToken) {
      while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {
        token = getNextToken(++offset);
      }
      return offset;
    }
    function checkInteger(token, valueOffset, disallowSign, offset) {
      if (!token) {
        return 0;
      }
      const code = token.value.charCodeAt(valueOffset);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          return 0;
        }
        valueOffset++;
      }
      for (; valueOffset < token.value.length; valueOffset++) {
        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
          return 0;
        }
      }
      return offset + 1;
    }
    function consumeB(token, offset_, getNextToken) {
      let sign = false;
      let offset = skipSC(token, offset_, getNextToken);
      token = getNextToken(offset);
      if (token === null) {
        return offset_;
      }
      if (token.type !== types.Number) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
          sign = true;
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          if (token === null || token.type !== types.Number) {
            return 0;
          }
        } else {
          return offset_;
        }
      }
      if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
          return 0;
        }
      }
      return checkInteger(token, sign ? 0 : 1, sign, offset);
    }
    function anPlusB(token, getNextToken) {
      let offset = 0;
      if (!token) {
        return 0;
      }
      if (token.type === types.Number) {
        return checkInteger(token, 0, ALLOW_SIGN, offset);
      } else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {
        if (!utils.cmpChar(token.value, 1, N)) {
          return 0;
        }
        switch (token.value.length) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // -n- <signless-integer>
          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // <dashndashdigit-ident>
          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Ident || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident) {
        if (token.type !== types.Ident) {
          token = getNextToken(++offset);
        }
        if (token === null || !utils.cmpChar(token.value, 0, N)) {
          return 0;
        }
        switch (token.value.length) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // '+'? n- <signless-integer>
          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // '+'? <ndashdigit-ident>
          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Dimension) {
        let code = token.value.charCodeAt(0);
        let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
        let i = sign;
        for (; i < token.value.length; i++) {
          if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
            break;
          }
        }
        if (i === sign) {
          return 0;
        }
        if (!utils.cmpChar(token.value, i, N)) {
          return 0;
        }
        if (i + 1 === token.value.length) {
          return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
          if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
            return 0;
          }
          if (i + 2 === token.value.length) {
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          } else {
            return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
          }
        }
      }
      return 0;
    }
    module2.exports = anPlusB;
  }
});

// node_modules/css-tree/cjs/lexer/generic-urange.cjs
var require_generic_urange = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-urange.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var types = require_types();
    var utils = require_utils();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function startsWith(token, code) {
      return token.value.charCodeAt(0) === code;
    }
    function hexSequence(token, offset, allowDash) {
      let hexlen = 0;
      for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
          hexSequence(token, offset + hexlen + 1, false);
          return 6;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          return 0;
        }
        if (++hexlen > 6) {
          return 0;
        }
      }
      return hexlen;
    }
    function withQuestionMarkSequence(consumed, length, getNextToken) {
      if (!consumed) {
        return 0;
      }
      while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
          return 0;
        }
        length++;
      }
      return length;
    }
    function urange(token, getNextToken) {
      let length = 0;
      if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (token.type === types.Ident) {
          return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }
        if (isDelim(token, QUESTIONMARK)) {
          return withQuestionMarkSequence(1, ++length, getNextToken);
        }
        return 0;
      }
      if (token.type === types.Number) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return length;
        }
        if (token.type === types.Dimension || token.type === types.Number) {
          if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
            return 0;
          }
          return length + 1;
        }
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
      }
      if (token.type === types.Dimension) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
      }
      return 0;
    }
    module2.exports = urange;
  }
});

// node_modules/css-tree/cjs/lexer/generic.cjs
var require_generic = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic.cjs"(exports2) {
    "use strict";
    var genericConst = require_generic_const();
    var genericAnPlusB = require_generic_an_plus_b();
    var genericUrange = require_generic_urange();
    var charCodeDefinitions = require_char_code_definitions();
    var types = require_types();
    var utils = require_utils();
    var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
    var balancePair = /* @__PURE__ */ new Map([
      [types.Function, types.RightParenthesis],
      [types.LeftParenthesis, types.RightParenthesis],
      [types.LeftSquareBracket, types.RightSquareBracket],
      [types.LeftCurlyBracket, types.RightCurlyBracket]
    ]);
    function charCodeAt(str, index) {
      return index < str.length ? str.charCodeAt(index) : 0;
    }
    function eqStr(actual, expected) {
      return utils.cmpStr(actual, 0, actual.length, expected);
    }
    function eqStrAny(actual, expected) {
      for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
          return true;
        }
      }
      return false;
    }
    function isPostfixIeHack(str, offset) {
      if (offset !== str.length - 2) {
        return false;
      }
      return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
      charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
    }
    function outOfRange(opts, value, numEnd) {
      if (opts && opts.type === "Range") {
        const num = Number(
          numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
        );
        if (isNaN(num)) {
          return true;
        }
        if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
          return true;
        }
        if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
          return true;
        }
      }
      return false;
    }
    function consumeFunction(token, getNextToken) {
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              if (balanceStash.length === 0) {
                length++;
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function calc(next) {
      return function(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {
          return consumeFunction(token, getNextToken);
        }
        return next(token, getNextToken, opts);
      };
    }
    function tokenType(expectedTokenType) {
      return function(token) {
        if (token === null || token.type !== expectedTokenType) {
          return 0;
        }
        return 1;
      };
    }
    function customIdent(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      const name = token.value.toLowerCase();
      if (eqStrAny(name, genericConst.cssWideKeywords)) {
        return 0;
      }
      if (eqStr(name, "default")) {
        return 0;
      }
      return 1;
    }
    function dashedIdent(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
        return 0;
      }
      return 1;
    }
    function customPropertyName(token) {
      if (!dashedIdent(token)) {
        return 0;
      }
      if (token.value === "--") {
        return 0;
      }
      return 1;
    }
    function hexColor(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      const length = token.value.length;
      if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
      }
      for (let i = 1; i < length; i++) {
        if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      return 1;
    }
    function idSelector(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
      }
      return 1;
    }
    function declarationValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            // ... or top-level <semicolon-token> tokens
            case types.Semicolon:
              if (balanceCloseType === 0) {
                break scan;
              }
              break;
            // ... or <delim-token> tokens with a value of "!"
            case types.Delim:
              if (balanceCloseType === 0 && token.value === "!") {
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function anyValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function dimension(type) {
      if (type) {
        type = new Set(type);
      }
      return function(token, getNextToken, opts) {
        if (token === null || token.type !== types.Dimension) {
          return 0;
        }
        const numberEnd = utils.consumeNumber(token.value, 0);
        if (type !== null) {
          const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
          const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
          if (type.has(unit.toLowerCase()) === false) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      };
    }
    function percentage(token, getNextToken, opts) {
      if (token === null || token.type !== types.Percentage) {
        return 0;
      }
      if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
      }
      return 1;
    }
    function zero(next) {
      if (typeof next !== "function") {
        next = function() {
          return 0;
        };
      }
      return function(token, getNextToken, opts) {
        if (token !== null && token.type === types.Number) {
          if (Number(token.value) === 0) {
            return 1;
          }
        }
        return next(token, getNextToken, opts);
      };
    }
    function number(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      const numberEnd = utils.consumeNumber(token.value, 0);
      const isNumber = numberEnd === token.value.length;
      if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    }
    function integer(token, getNextToken, opts) {
      if (token === null || token.type !== types.Number) {
        return 0;
      }
      let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
      charCodeAt(token.value, 0) === 45 ? 1 : 0;
      for (; i < token.value.length; i++) {
        if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, i)) {
        return 0;
      }
      return 1;
    }
    var tokenTypes = {
      "ident-token": tokenType(types.Ident),
      "function-token": tokenType(types.Function),
      "at-keyword-token": tokenType(types.AtKeyword),
      "hash-token": tokenType(types.Hash),
      "string-token": tokenType(types.String),
      "bad-string-token": tokenType(types.BadString),
      "url-token": tokenType(types.Url),
      "bad-url-token": tokenType(types.BadUrl),
      "delim-token": tokenType(types.Delim),
      "number-token": tokenType(types.Number),
      "percentage-token": tokenType(types.Percentage),
      "dimension-token": tokenType(types.Dimension),
      "whitespace-token": tokenType(types.WhiteSpace),
      "CDO-token": tokenType(types.CDO),
      "CDC-token": tokenType(types.CDC),
      "colon-token": tokenType(types.Colon),
      "semicolon-token": tokenType(types.Semicolon),
      "comma-token": tokenType(types.Comma),
      "[-token": tokenType(types.LeftSquareBracket),
      "]-token": tokenType(types.RightSquareBracket),
      "(-token": tokenType(types.LeftParenthesis),
      ")-token": tokenType(types.RightParenthesis),
      "{-token": tokenType(types.LeftCurlyBracket),
      "}-token": tokenType(types.RightCurlyBracket)
    };
    var productionTypes = {
      // token type aliases
      "string": tokenType(types.String),
      "ident": tokenType(types.Ident),
      // percentage
      "percentage": calc(percentage),
      // numeric
      "zero": zero(),
      "number": calc(number),
      "integer": calc(integer),
      // complex types
      "custom-ident": customIdent,
      "dashed-ident": dashedIdent,
      "custom-property-name": customPropertyName,
      "hex-color": hexColor,
      "id-selector": idSelector,
      // element( <id-selector> )
      "an-plus-b": genericAnPlusB,
      "urange": genericUrange,
      "declaration-value": declarationValue,
      "any-value": anyValue
    };
    function createDemensionTypes(units) {
      const {
        angle,
        decibel,
        frequency,
        flex,
        length,
        resolution,
        semitones,
        time
      } = units || {};
      return {
        "dimension": calc(dimension(null)),
        "angle": calc(dimension(angle)),
        "decibel": calc(dimension(decibel)),
        "frequency": calc(dimension(frequency)),
        "flex": calc(dimension(flex)),
        "length": calc(zero(dimension(length))),
        "resolution": calc(dimension(resolution)),
        "semitones": calc(dimension(semitones)),
        "time": calc(dimension(time))
      };
    }
    function createGenericTypes(units) {
      return {
        ...tokenTypes,
        ...productionTypes,
        ...createDemensionTypes(units)
      };
    }
    exports2.createDemensionTypes = createDemensionTypes;
    exports2.createGenericTypes = createGenericTypes;
    exports2.productionTypes = productionTypes;
    exports2.tokenTypes = tokenTypes;
  }
});

// node_modules/css-tree/cjs/lexer/units.cjs
var require_units = __commonJS({
  "node_modules/css-tree/cjs/lexer/units.cjs"(exports2) {
    "use strict";
    var length = [
      // absolute length units https://www.w3.org/TR/css-values-3/#lengths
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ];
    var angle = ["deg", "grad", "rad", "turn"];
    var time = ["s", "ms"];
    var frequency = ["hz", "khz"];
    var resolution = ["dpi", "dpcm", "dppx", "x"];
    var flex = ["fr"];
    var decibel = ["db"];
    var semitones = ["st"];
    exports2.angle = angle;
    exports2.decibel = decibel;
    exports2.flex = flex;
    exports2.frequency = frequency;
    exports2.length = length;
    exports2.resolution = resolution;
    exports2.semitones = semitones;
    exports2.time = time;
  }
});

// node_modules/css-tree/cjs/lexer/prepare-tokens.cjs
var require_prepare_tokens = __commonJS({
  "node_modules/css-tree/cjs/lexer/prepare-tokens.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer();
    var astToTokens = {
      decorator(handlers) {
        const tokens = [];
        let curNode = null;
        return {
          ...handlers,
          node(node) {
            const tmp = curNode;
            curNode = node;
            handlers.node.call(this, node);
            curNode = tmp;
          },
          emit(value, type, auto) {
            tokens.push({
              type,
              value,
              node: auto ? null : curNode
            });
          },
          result() {
            return tokens;
          }
        };
      }
    };
    function stringToTokens(str) {
      const tokens = [];
      index.tokenize(
        str,
        (type, start, end) => tokens.push({
          type,
          value: str.slice(start, end),
          node: null
        })
      );
      return tokens;
    }
    function prepareTokens(value, syntax) {
      if (typeof value === "string") {
        return stringToTokens(value);
      }
      return syntax.generate(value, astToTokens);
    }
    module2.exports = prepareTokens;
  }
});

// node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs
var require_SyntaxError2 = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    function SyntaxError2(message, input, offset) {
      return Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        input,
        offset,
        rawMessage: message,
        message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
      });
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/css-tree/cjs/definition-syntax/scanner.cjs
var require_scanner = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/scanner.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError2();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var NAME_CHAR = new Uint8Array(128).map(
      (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
    );
    var Scanner = class {
      constructor(str) {
        this.str = str;
        this.pos = 0;
      }
      charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
      }
      charCode() {
        return this.charCodeAt(this.pos);
      }
      isNameCharCode(code = this.charCode()) {
        return code < 128 && NAME_CHAR[code] === 1;
      }
      nextCharCode() {
        return this.charCodeAt(this.pos + 1);
      }
      nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
      }
      skipWs() {
        this.pos = this.findWsEnd(this.pos);
      }
      findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
          const code = this.str.charCodeAt(pos);
          if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
          }
        }
        return pos;
      }
      substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
      }
      eat(code) {
        if (this.charCode() !== code) {
          this.error("Expect `" + String.fromCharCode(code) + "`");
        }
        this.pos++;
      }
      peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      }
      error(message) {
        throw new SyntaxError2.SyntaxError(message, this.str, this.pos);
      }
      scanSpaces() {
        return this.substringToPos(this.findWsEnd(this.pos));
      }
      scanWord() {
        let end = this.pos;
        for (; end < this.str.length; end++) {
          const code = this.str.charCodeAt(end);
          if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
          }
        }
        if (this.pos === end) {
          this.error("Expect a keyword");
        }
        return this.substringToPos(end);
      }
      scanNumber() {
        let end = this.pos;
        for (; end < this.str.length; end++) {
          const code = this.str.charCodeAt(end);
          if (code < 48 || code > 57) {
            break;
          }
        }
        if (this.pos === end) {
          this.error("Expect a number");
        }
        return this.substringToPos(end);
      }
      scanString() {
        const end = this.str.indexOf("'", this.pos + 1);
        if (end === -1) {
          this.pos = this.str.length;
          this.error("Expect an apostrophe");
        }
        return this.substringToPos(end + 1);
      }
    };
    exports2.Scanner = Scanner;
  }
});

// node_modules/css-tree/cjs/definition-syntax/parse.cjs
var require_parse = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/parse.cjs"(exports2) {
    "use strict";
    var scanner = require_scanner();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var COMMA = 44;
    var HYPERMINUS = 45;
    var LESSTHANSIGN = 60;
    var GREATERTHANSIGN = 62;
    var QUESTIONMARK = 63;
    var COMMERCIALAT = 64;
    var LEFTSQUAREBRACKET = 91;
    var RIGHTSQUAREBRACKET = 93;
    var LEFTCURLYBRACKET = 123;
    var VERTICALLINE = 124;
    var RIGHTCURLYBRACKET = 125;
    var INFINITY = 8734;
    var COMBINATOR_PRECEDENCE = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function readMultiplierRange(scanner2) {
      let min = null;
      let max = null;
      scanner2.eat(LEFTCURLYBRACKET);
      scanner2.skipWs();
      min = scanner2.scanNumber(scanner2);
      scanner2.skipWs();
      if (scanner2.charCode() === COMMA) {
        scanner2.pos++;
        scanner2.skipWs();
        if (scanner2.charCode() !== RIGHTCURLYBRACKET) {
          max = scanner2.scanNumber(scanner2);
          scanner2.skipWs();
        }
      } else {
        max = min;
      }
      scanner2.eat(RIGHTCURLYBRACKET);
      return {
        min: Number(min),
        max: max ? Number(max) : 0
      };
    }
    function readMultiplier(scanner2) {
      let range = null;
      let comma = false;
      switch (scanner2.charCode()) {
        case ASTERISK:
          scanner2.pos++;
          range = {
            min: 0,
            max: 0
          };
          break;
        case PLUSSIGN:
          scanner2.pos++;
          range = {
            min: 1,
            max: 0
          };
          break;
        case QUESTIONMARK:
          scanner2.pos++;
          range = {
            min: 0,
            max: 1
          };
          break;
        case NUMBERSIGN:
          scanner2.pos++;
          comma = true;
          if (scanner2.charCode() === LEFTCURLYBRACKET) {
            range = readMultiplierRange(scanner2);
          } else if (scanner2.charCode() === QUESTIONMARK) {
            scanner2.pos++;
            range = {
              min: 0,
              max: 0
            };
          } else {
            range = {
              min: 1,
              max: 0
            };
          }
          break;
        case LEFTCURLYBRACKET:
          range = readMultiplierRange(scanner2);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma,
        min: range.min,
        max: range.max,
        term: null
      };
    }
    function maybeMultiplied(scanner2, node) {
      const multiplier = readMultiplier(scanner2);
      if (multiplier !== null) {
        multiplier.term = node;
        if (scanner2.charCode() === NUMBERSIGN && scanner2.charCodeAt(scanner2.pos - 1) === PLUSSIGN) {
          return maybeMultiplied(scanner2, multiplier);
        }
        return multiplier;
      }
      return node;
    }
    function maybeToken(scanner2) {
      const ch = scanner2.peek();
      if (ch === "") {
        return null;
      }
      return maybeMultiplied(scanner2, {
        type: "Token",
        value: ch
      });
    }
    function readProperty(scanner2) {
      let name;
      scanner2.eat(LESSTHANSIGN);
      scanner2.eat(APOSTROPHE);
      name = scanner2.scanWord();
      scanner2.eat(APOSTROPHE);
      scanner2.eat(GREATERTHANSIGN);
      return maybeMultiplied(scanner2, {
        type: "Property",
        name
      });
    }
    function readTypeRange(scanner2) {
      let min = null;
      let max = null;
      let sign = 1;
      scanner2.eat(LEFTSQUAREBRACKET);
      if (scanner2.charCode() === HYPERMINUS) {
        scanner2.peek();
        sign = -1;
      }
      if (sign == -1 && scanner2.charCode() === INFINITY) {
        scanner2.peek();
      } else {
        min = sign * Number(scanner2.scanNumber(scanner2));
        if (scanner2.isNameCharCode()) {
          min += scanner2.scanWord();
        }
      }
      scanner2.skipWs();
      scanner2.eat(COMMA);
      scanner2.skipWs();
      if (scanner2.charCode() === INFINITY) {
        scanner2.peek();
      } else {
        sign = 1;
        if (scanner2.charCode() === HYPERMINUS) {
          scanner2.peek();
          sign = -1;
        }
        max = sign * Number(scanner2.scanNumber(scanner2));
        if (scanner2.isNameCharCode()) {
          max += scanner2.scanWord();
        }
      }
      scanner2.eat(RIGHTSQUAREBRACKET);
      return {
        type: "Range",
        min,
        max
      };
    }
    function readType(scanner2) {
      let name;
      let opts = null;
      scanner2.eat(LESSTHANSIGN);
      name = scanner2.scanWord();
      if (name === "boolean-expr") {
        scanner2.eat(LEFTSQUAREBRACKET);
        const implicitGroup = readImplicitGroup(scanner2, RIGHTSQUAREBRACKET);
        scanner2.eat(RIGHTSQUAREBRACKET);
        scanner2.eat(GREATERTHANSIGN);
        return maybeMultiplied(scanner2, {
          type: "Boolean",
          term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
        });
      }
      if (scanner2.charCode() === LEFTPARENTHESIS && scanner2.nextCharCode() === RIGHTPARENTHESIS) {
        scanner2.pos += 2;
        name += "()";
      }
      if (scanner2.charCodeAt(scanner2.findWsEnd(scanner2.pos)) === LEFTSQUAREBRACKET) {
        scanner2.skipWs();
        opts = readTypeRange(scanner2);
      }
      scanner2.eat(GREATERTHANSIGN);
      return maybeMultiplied(scanner2, {
        type: "Type",
        name,
        opts
      });
    }
    function readKeywordOrFunction(scanner2) {
      const name = scanner2.scanWord();
      if (scanner2.charCode() === LEFTPARENTHESIS) {
        scanner2.pos++;
        return {
          type: "Function",
          name
        };
      }
      return maybeMultiplied(scanner2, {
        type: "Keyword",
        name
      });
    }
    function regroupTerms(terms, combinators) {
      function createGroup(terms2, combinator2) {
        return {
          type: "Group",
          terms: terms2,
          combinator: combinator2,
          disallowEmpty: false,
          explicit: false
        };
      }
      let combinator;
      combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
      while (combinators.length > 0) {
        combinator = combinators.shift();
        let i = 0;
        let subgroupStart = 0;
        for (; i < terms.length; i++) {
          const term = terms[i];
          if (term.type === "Combinator") {
            if (term.value === combinator) {
              if (subgroupStart === -1) {
                subgroupStart = i - 1;
              }
              terms.splice(i, 1);
              i--;
            } else {
              if (subgroupStart !== -1 && i - subgroupStart > 1) {
                terms.splice(
                  subgroupStart,
                  i - subgroupStart,
                  createGroup(terms.slice(subgroupStart, i), combinator)
                );
                i = subgroupStart + 1;
              }
              subgroupStart = -1;
            }
          }
        }
        if (subgroupStart !== -1 && combinators.length) {
          terms.splice(
            subgroupStart,
            i - subgroupStart,
            createGroup(terms.slice(subgroupStart, i), combinator)
          );
        }
      }
      return combinator;
    }
    function readImplicitGroup(scanner2, stopCharCode) {
      const combinators = /* @__PURE__ */ Object.create(null);
      const terms = [];
      let token;
      let prevToken = null;
      let prevTokenPos = scanner2.pos;
      while (scanner2.charCode() !== stopCharCode && (token = peek(scanner2, stopCharCode))) {
        if (token.type !== "Spaces") {
          if (token.type === "Combinator") {
            if (prevToken === null || prevToken.type === "Combinator") {
              scanner2.pos = prevTokenPos;
              scanner2.error("Unexpected combinator");
            }
            combinators[token.value] = true;
          } else if (prevToken !== null && prevToken.type !== "Combinator") {
            combinators[" "] = true;
            terms.push({
              type: "Combinator",
              value: " "
            });
          }
          terms.push(token);
          prevToken = token;
          prevTokenPos = scanner2.pos;
        }
      }
      if (prevToken !== null && prevToken.type === "Combinator") {
        scanner2.pos -= prevTokenPos;
        scanner2.error("Unexpected combinator");
      }
      return {
        type: "Group",
        terms,
        combinator: regroupTerms(terms, combinators) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function readGroup(scanner2, stopCharCode) {
      let result;
      scanner2.eat(LEFTSQUAREBRACKET);
      result = readImplicitGroup(scanner2, stopCharCode);
      scanner2.eat(RIGHTSQUAREBRACKET);
      result.explicit = true;
      if (scanner2.charCode() === EXCLAMATIONMARK) {
        scanner2.pos++;
        result.disallowEmpty = true;
      }
      return result;
    }
    function peek(scanner2, stopCharCode) {
      let code = scanner2.charCode();
      switch (code) {
        case RIGHTSQUAREBRACKET:
          break;
        case LEFTSQUAREBRACKET:
          return maybeMultiplied(scanner2, readGroup(scanner2, stopCharCode));
        case LESSTHANSIGN:
          return scanner2.nextCharCode() === APOSTROPHE ? readProperty(scanner2) : readType(scanner2);
        case VERTICALLINE:
          return {
            type: "Combinator",
            value: scanner2.substringToPos(
              scanner2.pos + (scanner2.nextCharCode() === VERTICALLINE ? 2 : 1)
            )
          };
        case AMPERSAND:
          scanner2.pos++;
          scanner2.eat(AMPERSAND);
          return {
            type: "Combinator",
            value: "&&"
          };
        case COMMA:
          scanner2.pos++;
          return {
            type: "Comma"
          };
        case APOSTROPHE:
          return maybeMultiplied(scanner2, {
            type: "String",
            value: scanner2.scanString()
          });
        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
          return {
            type: "Spaces",
            value: scanner2.scanSpaces()
          };
        case COMMERCIALAT:
          code = scanner2.nextCharCode();
          if (scanner2.isNameCharCode(code)) {
            scanner2.pos++;
            return {
              type: "AtKeyword",
              name: scanner2.scanWord()
            };
          }
          return maybeToken(scanner2);
        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
          break;
        case LEFTCURLYBRACKET:
          code = scanner2.nextCharCode();
          if (code < 48 || code > 57) {
            return maybeToken(scanner2);
          }
          break;
        default:
          if (scanner2.isNameCharCode(code)) {
            return readKeywordOrFunction(scanner2);
          }
          return maybeToken(scanner2);
      }
    }
    function parse(source) {
      const scanner$1 = new scanner.Scanner(source);
      const result = readImplicitGroup(scanner$1);
      if (scanner$1.pos !== source.length) {
        scanner$1.error("Unexpected input");
      }
      if (result.terms.length === 1 && result.terms[0].type === "Group") {
        return result.terms[0];
      }
      return result;
    }
    exports2.parse = parse;
  }
});

// node_modules/css-tree/cjs/lexer/match-graph.cjs
var require_match_graph = __commonJS({
  "node_modules/css-tree/cjs/lexer/match-graph.cjs"(exports2) {
    "use strict";
    var parse = require_parse();
    var MATCH = { type: "Match" };
    var MISMATCH = { type: "Mismatch" };
    var DISALLOW_EMPTY = { type: "DisallowEmpty" };
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function createCondition(match, thenBranch, elseBranch) {
      if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
      }
      if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
      }
      if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
      }
      return {
        type: "If",
        match,
        then: thenBranch,
        else: elseBranch
      };
    }
    function isFunctionType(name) {
      return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
    }
    function isEnumCapatible(term) {
      return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
    }
    function groupNode(terms, combinator = " ", explicit = false) {
      return {
        type: "Group",
        terms,
        combinator,
        disallowEmpty: false,
        explicit
      };
    }
    function replaceTypeInGraph(node, replacements, visited = /* @__PURE__ */ new Set()) {
      if (!visited.has(node)) {
        visited.add(node);
        switch (node.type) {
          case "If":
            node.match = replaceTypeInGraph(node.match, replacements, visited);
            node.then = replaceTypeInGraph(node.then, replacements, visited);
            node.else = replaceTypeInGraph(node.else, replacements, visited);
            break;
          case "Type":
            return replacements[node.name] || node;
        }
      }
      return node;
    }
    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
      switch (combinator) {
        case " ": {
          let result = MATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            result = createCondition(
              term,
              result,
              MISMATCH
            );
          }
          return result;
        }
        case "|": {
          let result = MISMATCH;
          let map = null;
          for (let i = terms.length - 1; i >= 0; i--) {
            let term = terms[i];
            if (isEnumCapatible(term)) {
              if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                map = /* @__PURE__ */ Object.create(null);
                result = createCondition(
                  {
                    type: "Enum",
                    map
                  },
                  MATCH,
                  result
                );
              }
              if (map !== null) {
                const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                if (key in map === false) {
                  map[key] = term;
                  continue;
                }
              }
            }
            map = null;
            result = createCondition(
              term,
              MATCH,
              result
            );
          }
          return result;
        }
        case "&&": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: true
            };
          }
          let result = MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                false
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
        case "||": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: false
            };
          }
          let result = atLeastOneTermMatched ? MATCH : MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                true
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
      }
    }
    function buildMultiplierMatchGraph(node) {
      let result = MATCH;
      let matchTerm = buildMatchGraphInternal(node.term);
      if (node.max === 0) {
        matchTerm = createCondition(
          matchTerm,
          DISALLOW_EMPTY,
          MISMATCH
        );
        result = createCondition(
          matchTerm,
          null,
          // will be a loop
          MISMATCH
        );
        result.then = createCondition(
          MATCH,
          MATCH,
          result
          // make a loop
        );
        if (node.comma) {
          result.then.else = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
      } else {
        for (let i = node.min || 1; i <= node.max; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            createCondition(
              MATCH,
              MATCH,
              result
            ),
            MISMATCH
          );
        }
      }
      if (node.min === 0) {
        result = createCondition(
          MATCH,
          MATCH,
          result
        );
      } else {
        for (let i = 0; i < node.min - 1; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            result,
            MISMATCH
          );
        }
      }
      return result;
    }
    function buildMatchGraphInternal(node) {
      if (typeof node === "function") {
        return {
          type: "Generic",
          fn: node
        };
      }
      switch (node.type) {
        case "Group": {
          let result = buildGroupMatchGraph(
            node.combinator,
            node.terms.map(buildMatchGraphInternal),
            false
          );
          if (node.disallowEmpty) {
            result = createCondition(
              result,
              DISALLOW_EMPTY,
              MISMATCH
            );
          }
          return result;
        }
        case "Multiplier":
          return buildMultiplierMatchGraph(node);
        // https://drafts.csswg.org/css-values-5/#boolean
        case "Boolean": {
          const term = buildMatchGraphInternal(node.term);
          const matchNode = buildMatchGraphInternal(groupNode([
            groupNode([
              { type: "Keyword", name: "not" },
              { type: "Type", name: "!boolean-group" }
            ]),
            groupNode([
              { type: "Type", name: "!boolean-group" },
              groupNode([
                { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
                  { type: "Keyword", name: "and" },
                  { type: "Type", name: "!boolean-group" }
                ]) },
                { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
                  { type: "Keyword", name: "or" },
                  { type: "Type", name: "!boolean-group" }
                ]) }
              ], "|")
            ])
          ], "|"));
          const booleanGroup = buildMatchGraphInternal(
            groupNode([
              { type: "Type", name: "!term" },
              groupNode([
                { type: "Token", value: "(" },
                { type: "Type", name: "!self" },
                { type: "Token", value: ")" }
              ]),
              { type: "Type", name: "general-enclosed" }
            ], "|")
          );
          replaceTypeInGraph(booleanGroup, { "!term": term, "!self": matchNode });
          replaceTypeInGraph(matchNode, { "!boolean-group": booleanGroup });
          return matchNode;
        }
        case "Type":
        case "Property":
          return {
            type: node.type,
            name: node.name,
            syntax: node
          };
        case "Keyword":
          return {
            type: node.type,
            name: node.name.toLowerCase(),
            syntax: node
          };
        case "AtKeyword":
          return {
            type: node.type,
            name: "@" + node.name.toLowerCase(),
            syntax: node
          };
        case "Function":
          return {
            type: node.type,
            name: node.name.toLowerCase() + "(",
            syntax: node
          };
        case "String":
          if (node.value.length === 3) {
            return {
              type: "Token",
              value: node.value.charAt(1),
              syntax: node
            };
          }
          return {
            type: node.type,
            value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
            syntax: node
          };
        case "Token":
          return {
            type: node.type,
            value: node.value,
            syntax: node
          };
        case "Comma":
          return {
            type: node.type,
            syntax: node
          };
        default:
          throw new Error("Unknown node type:", node.type);
      }
    }
    function buildMatchGraph(syntaxTree, ref) {
      if (typeof syntaxTree === "string") {
        syntaxTree = parse.parse(syntaxTree);
      }
      return {
        type: "MatchGraph",
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
      };
    }
    exports2.DISALLOW_EMPTY = DISALLOW_EMPTY;
    exports2.MATCH = MATCH;
    exports2.MISMATCH = MISMATCH;
    exports2.buildMatchGraph = buildMatchGraph;
  }
});

// node_modules/css-tree/cjs/lexer/match.cjs
var require_match = __commonJS({
  "node_modules/css-tree/cjs/lexer/match.cjs"(exports2) {
    "use strict";
    var matchGraph = require_match_graph();
    var types = require_types();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var STUB = 0;
    var TOKEN = 1;
    var OPEN_SYNTAX = 2;
    var CLOSE_SYNTAX = 3;
    var EXIT_REASON_MATCH = "Match";
    var EXIT_REASON_MISMATCH = "Mismatch";
    var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
    var ITERATION_LIMIT = 15e3;
    function reverseList(list) {
      let prev = null;
      let next = null;
      let item = list;
      while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
      }
      return prev;
    }
    function areStringsEqualCaseInsensitive(testStr, referenceStr) {
      if (testStr.length !== referenceStr.length) {
        return false;
      }
      for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);
        if (testCode >= 65 && testCode <= 90) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function isContextEdgeDelim(token) {
      if (token.type !== types.Delim) {
        return false;
      }
      return token.value !== "?";
    }
    function isCommaContextStart(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);
    }
    function isCommaContextEnd(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === "/";
    }
    function internalMatch(tokens, state, syntaxes) {
      function moveToNextToken() {
        do {
          tokenIndex++;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));
      }
      function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;
        return nextIndex < tokens.length ? tokens[nextIndex] : null;
      }
      function stateSnapshotFromSyntax(nextState, prev) {
        return {
          nextState,
          matchStack,
          syntaxStack,
          thenStack,
          tokenIndex,
          prev
        };
      }
      function pushThenStack(nextState) {
        thenStack = {
          nextState,
          matchStack,
          syntaxStack,
          prev: thenStack
        };
      }
      function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
      }
      function addTokenToMatch() {
        matchStack = {
          type: TOKEN,
          syntax: state.syntax,
          token,
          prev: matchStack
        };
        moveToNextToken();
        syntaxStash = null;
        if (tokenIndex > longestMatch) {
          longestMatch = tokenIndex;
        }
      }
      function openSyntax() {
        syntaxStack = {
          syntax: state.syntax,
          opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
          prev: syntaxStack
        };
        matchStack = {
          type: OPEN_SYNTAX,
          syntax: state.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
          matchStack = matchStack.prev;
        } else {
          matchStack = {
            type: CLOSE_SYNTAX,
            syntax: syntaxStack.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        syntaxStack = syntaxStack.prev;
      }
      let syntaxStack = null;
      let thenStack = null;
      let elseStack = null;
      let syntaxStash = null;
      let iterationCount = 0;
      let exitReason = null;
      let token = null;
      let tokenIndex = -1;
      let longestMatch = 0;
      let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
      };
      moveToNextToken();
      while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        switch (state.type) {
          case "Match":
            if (thenStack === null) {
              if (token !== null) {
                if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                  state = matchGraph.MISMATCH;
                  break;
                }
              }
              exitReason = EXIT_REASON_MATCH;
              break;
            }
            state = thenStack.nextState;
            if (state === matchGraph.DISALLOW_EMPTY) {
              if (thenStack.matchStack === matchStack) {
                state = matchGraph.MISMATCH;
                break;
              } else {
                state = matchGraph.MATCH;
              }
            }
            while (thenStack.syntaxStack !== syntaxStack) {
              closeSyntax();
            }
            thenStack = thenStack.prev;
            break;
          case "Mismatch":
            if (syntaxStash !== null && syntaxStash !== false) {
              if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                elseStack = syntaxStash;
                syntaxStash = false;
              }
            } else if (elseStack === null) {
              exitReason = EXIT_REASON_MISMATCH;
              break;
            }
            state = elseStack.nextState;
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenIndex = elseStack.tokenIndex;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
            elseStack = elseStack.prev;
            break;
          case "MatchGraph":
            state = state.match;
            break;
          case "If":
            if (state.else !== matchGraph.MISMATCH) {
              pushElseStack(state.else);
            }
            if (state.then !== matchGraph.MATCH) {
              pushThenStack(state.then);
            }
            state = state.match;
            break;
          case "MatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer": {
            const terms = state.syntax.terms;
            if (state.index === terms.length) {
              if (state.mask === 0 || state.syntax.all) {
                state = matchGraph.MISMATCH;
                break;
              }
              state = matchGraph.MATCH;
              break;
            }
            if (state.mask === (1 << terms.length) - 1) {
              state = matchGraph.MATCH;
              break;
            }
            for (; state.index < terms.length; state.index++) {
              const matchFlag = 1 << state.index;
              if ((state.mask & matchFlag) === 0) {
                pushElseStack(state);
                pushThenStack({
                  type: "AddMatchOnce",
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                });
                state = terms[state.index++];
                break;
              }
            }
            break;
          }
          case "AddMatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state.syntax,
              index: 0,
              mask: state.mask
            };
            break;
          case "Enum":
            if (token !== null) {
              let name = token.value.toLowerCase();
              if (name.indexOf("\\") !== -1) {
                name = name.replace(/\\[09].*$/, "");
              }
              if (hasOwnProperty2.call(state.map, name)) {
                state = state.map[name];
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          case "Generic": {
            const opts = syntaxStack !== null ? syntaxStack.opts : null;
            const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
            if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
              while (tokenIndex < lastTokenIndex2) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          }
          case "Type":
          case "Property": {
            const syntaxDict = state.type === "Type" ? "types" : "properties";
            const dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
            if (!dictSyntax || !dictSyntax.match) {
              throw new Error(
                "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
              );
            }
            if (syntaxStash !== false && token !== null && state.type === "Type") {
              const lowPriorityMatching = (
                // https://drafts.csswg.org/css-values-4/#custom-idents
                // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                // can only claim the keyword if no other unfulfilled production can claim it.
                state.name === "custom-ident" && token.type === types.Ident || // https://drafts.csswg.org/css-values-4/#lengths
                // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                // it must parse as a <number>
                state.name === "length" && token.value === "0"
              );
              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }
                state = matchGraph.MISMATCH;
                break;
              }
            }
            openSyntax();
            state = dictSyntax.matchRef || dictSyntax.match;
            break;
          }
          case "Keyword": {
            const name = state.name;
            if (token !== null) {
              let keywordName = token.value;
              if (keywordName.indexOf("\\") !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, "");
              }
              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          }
          case "AtKeyword":
          case "Function":
            if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Token":
            if (token !== null && token.value === state.value) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Comma":
            if (token !== null && token.type === types.Comma) {
              if (isCommaContextStart(matchStack.token)) {
                state = matchGraph.MISMATCH;
              } else {
                addTokenToMatch();
                state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
              }
            } else {
              state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
            }
            break;
          case "String":
            let string = "";
            let lastTokenIndex = tokenIndex;
            for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
              string += tokens[lastTokenIndex].value;
            }
            if (areStringsEqualCaseInsensitive(string, state.value)) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          default:
            throw new Error("Unknown node type: " + state.type);
        }
      }
      switch (exitReason) {
        case null:
          console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
          exitReason = EXIT_REASON_ITERATION_LIMIT;
          matchStack = null;
          break;
        case EXIT_REASON_MATCH:
          while (syntaxStack !== null) {
            closeSyntax();
          }
          break;
        default:
          matchStack = null;
      }
      return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
      };
    }
    function matchAsList(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match !== null) {
        let item = reverseList(matchResult.match).prev;
        matchResult.match = [];
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
            case CLOSE_SYNTAX:
              matchResult.match.push({
                type: item.type,
                syntax: item.syntax
              });
              break;
            default:
              matchResult.match.push({
                token: item.token.value,
                node: item.token.node
              });
              break;
          }
          item = item.prev;
        }
      }
      return matchResult;
    }
    function matchAsTree(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match === null) {
        return matchResult;
      }
      let item = matchResult.match;
      let host = matchResult.match = {
        syntax: matchGraph2.syntax || null,
        match: []
      };
      const hostStack = [host];
      item = reverseList(item).prev;
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
            host.match.push(host = {
              syntax: item.syntax,
              match: []
            });
            hostStack.push(host);
            break;
          case CLOSE_SYNTAX:
            hostStack.pop();
            host = hostStack[hostStack.length - 1];
            break;
          default:
            host.match.push({
              syntax: item.syntax || null,
              token: item.token.value,
              node: item.token.node
            });
        }
        item = item.prev;
      }
      return matchResult;
    }
    exports2.matchAsList = matchAsList;
    exports2.matchAsTree = matchAsTree;
  }
});

// node_modules/css-tree/cjs/lexer/trace.cjs
var require_trace = __commonJS({
  "node_modules/css-tree/cjs/lexer/trace.cjs"(exports2) {
    "use strict";
    function getTrace(node) {
      function shouldPutToTrace(syntax) {
        if (syntax === null) {
          return false;
        }
        return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
      }
      function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
          for (let i = 0; i < matchNode.match.length; i++) {
            if (hasMatch(matchNode.match[i])) {
              if (shouldPutToTrace(matchNode.syntax)) {
                result.unshift(matchNode.syntax);
              }
              return true;
            }
          }
        } else if (matchNode.node === node) {
          result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
          return true;
        }
        return false;
      }
      let result = null;
      if (this.matched !== null) {
        hasMatch(this.matched);
      }
      return result;
    }
    function isType(node, type) {
      return testNode(this, node, (match) => match.type === "Type" && match.name === type);
    }
    function isProperty(node, property) {
      return testNode(this, node, (match) => match.type === "Property" && match.name === property);
    }
    function isKeyword(node) {
      return testNode(this, node, (match) => match.type === "Keyword");
    }
    function testNode(match, node, fn) {
      const trace = getTrace.call(match, node);
      if (trace === null) {
        return false;
      }
      return trace.some(fn);
    }
    exports2.getTrace = getTrace;
    exports2.isKeyword = isKeyword;
    exports2.isProperty = isProperty;
    exports2.isType = isType;
  }
});

// node_modules/css-tree/cjs/lexer/search.cjs
var require_search = __commonJS({
  "node_modules/css-tree/cjs/lexer/search.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function getFirstMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getFirstMatchNode(matchNode.match[0]);
    }
    function getLastMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    }
    function matchFragments(lexer, ast, match, type, name) {
      function findFragments(matchNode) {
        if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
          const start = getFirstMatchNode(matchNode);
          const end = getLastMatchNode(matchNode);
          lexer.syntax.walk(ast, function(node, item, list) {
            if (node === start) {
              const nodes = new List.List();
              do {
                nodes.appendData(item.data);
                if (item.data === end) {
                  break;
                }
                item = item.next;
              } while (item !== null);
              fragments.push({
                parent: list,
                nodes
              });
            }
          });
        }
        if (Array.isArray(matchNode.match)) {
          matchNode.match.forEach(findFragments);
        }
      }
      const fragments = [];
      if (match.matched !== null) {
        findFragments(match.matched);
      }
      return fragments;
    }
    exports2.matchFragments = matchFragments;
  }
});

// node_modules/css-tree/cjs/lexer/structure.cjs
var require_structure = __commonJS({
  "node_modules/css-tree/cjs/lexer/structure.cjs"(exports2) {
    "use strict";
    var List = require_List();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function isValidNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
    function isValidLocation(loc) {
      return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
    }
    function createNodeStructureChecker(type, fields) {
      return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
          return warn(node, "Type of node should be an Object");
        }
        for (let key in node) {
          let valid = true;
          if (hasOwnProperty2.call(node, key) === false) {
            continue;
          }
          if (key === "type") {
            if (node.type !== type) {
              warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
            }
          } else if (key === "loc") {
            if (node.loc === null) {
              continue;
            } else if (node.loc && node.loc.constructor === Object) {
              if (typeof node.loc.source !== "string") {
                key += ".source";
              } else if (!isValidLocation(node.loc.start)) {
                key += ".start";
              } else if (!isValidLocation(node.loc.end)) {
                key += ".end";
              } else {
                continue;
              }
            }
            valid = false;
          } else if (fields.hasOwnProperty(key)) {
            valid = false;
            for (let i = 0; !valid && i < fields[key].length; i++) {
              const fieldType = fields[key][i];
              switch (fieldType) {
                case String:
                  valid = typeof node[key] === "string";
                  break;
                case Boolean:
                  valid = typeof node[key] === "boolean";
                  break;
                case null:
                  valid = node[key] === null;
                  break;
                default:
                  if (typeof fieldType === "string") {
                    valid = node[key] && node[key].type === fieldType;
                  } else if (Array.isArray(fieldType)) {
                    valid = node[key] instanceof List.List;
                  }
              }
            }
          } else {
            warn(node, "Unknown field `" + key + "` for " + type + " node type");
          }
          if (!valid) {
            warn(node, "Bad value for `" + type + "." + key + "`");
          }
        }
        for (const key in fields) {
          if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
            warn(node, "Field `" + type + "." + key + "` is missed");
          }
        }
      };
    }
    function genTypesList(fieldTypes, path2) {
      const docsTypes = [];
      for (let i = 0; i < fieldTypes.length; i++) {
        const fieldType = fieldTypes[i];
        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name.toLowerCase());
        } else if (fieldType === null) {
          docsTypes.push("null");
        } else if (typeof fieldType === "string") {
          docsTypes.push(fieldType);
        } else if (Array.isArray(fieldType)) {
          docsTypes.push("List<" + (genTypesList(fieldType, path2) || "any") + ">");
        } else {
          throw new Error("Wrong value `" + fieldType + "` in `" + path2 + "` structure definition");
        }
      }
      return docsTypes.join(" | ");
    }
    function processStructure(name, nodeType) {
      const structure = nodeType.structure;
      const fields = {
        type: String,
        loc: true
      };
      const docs = {
        type: '"' + name + '"'
      };
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
        docs[key] = genTypesList(fieldTypes, name + "." + key);
      }
      return {
        docs,
        check: createNodeStructureChecker(name, fields)
      };
    }
    function getStructureFromConfig(config) {
      const structure = {};
      if (config.node) {
        for (const name in config.node) {
          if (hasOwnProperty2.call(config.node, name)) {
            const nodeType = config.node[name];
            if (nodeType.structure) {
              structure[name] = processStructure(name, nodeType);
            } else {
              throw new Error("Missed `structure` field in `" + name + "` node type definition");
            }
          }
        }
      }
      return structure;
    }
    exports2.getStructureFromConfig = getStructureFromConfig;
  }
});

// node_modules/css-tree/cjs/definition-syntax/walk.cjs
var require_walk = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/walk.cjs"(exports2) {
    "use strict";
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function walk(node, options, context) {
      function walk2(node2) {
        enter.call(context, node2);
        switch (node2.type) {
          case "Group":
            node2.terms.forEach(walk2);
            break;
          case "Multiplier":
          case "Boolean":
            walk2(node2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + node2.type);
        }
        leave.call(context, node2);
      }
      let enter = noop;
      let leave = noop;
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walk2(node);
    }
    exports2.walk = walk;
  }
});

// node_modules/css-tree/cjs/lexer/Lexer.cjs
var require_Lexer = __commonJS({
  "node_modules/css-tree/cjs/lexer/Lexer.cjs"(exports2) {
    "use strict";
    var error = require_error();
    var names = require_names2();
    var genericConst = require_generic_const();
    var generic = require_generic();
    var units = require_units();
    var prepareTokens = require_prepare_tokens();
    var matchGraph = require_match_graph();
    var match = require_match();
    var trace = require_trace();
    var search = require_search();
    var structure = require_structure();
    var parse = require_parse();
    var generate = require_generate();
    var walk = require_walk();
    function dumpMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const name in map) {
        if (map[name].syntax) {
          result[name] = syntaxAsAst ? map[name].syntax : generate.generate(map[name].syntax, { compact });
        }
      }
      return result;
    }
    function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
          prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate.generate(atrule.prelude.syntax, { compact })),
          descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
      }
      return result;
    }
    function valueHasVar(tokens) {
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === "var(") {
          return true;
        }
      }
      return false;
    }
    function syntaxHasTopLevelCommaMultiplier(syntax) {
      const singleTerm = syntax.terms[0];
      return syntax.explicit === false && syntax.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
    }
    function buildMatchResult(matched, error2, iterations) {
      return {
        matched,
        iterations,
        error: error2,
        ...trace
      };
    }
    function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
      const tokens = prepareTokens(value, lexer.syntax);
      let result;
      if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
      }
      if (useCssWideKeywords) {
        result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
      }
      if (!useCssWideKeywords || !result.match) {
        result = match.matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
          return buildMatchResult(
            null,
            new error.SyntaxMatchError(result.reason, syntax.syntax, value, result),
            result.iterations
          );
        }
      }
      return buildMatchResult(result.match, null, result.iterations);
    }
    var Lexer = class {
      constructor(config, syntax, structure$1) {
        this.cssWideKeywords = genericConst.cssWideKeywords;
        this.syntax = syntax;
        this.generic = false;
        this.units = { ...units };
        this.atrules = /* @__PURE__ */ Object.create(null);
        this.properties = /* @__PURE__ */ Object.create(null);
        this.types = /* @__PURE__ */ Object.create(null);
        this.structure = structure$1 || structure.getStructureFromConfig(config);
        if (config) {
          if (config.cssWideKeywords) {
            this.cssWideKeywords = config.cssWideKeywords;
          }
          if (config.units) {
            for (const group of Object.keys(units)) {
              if (Array.isArray(config.units[group])) {
                this.units[group] = config.units[group];
              }
            }
          }
          if (config.types) {
            for (const [name, type] of Object.entries(config.types)) {
              this.addType_(name, type);
            }
          }
          if (config.generic) {
            this.generic = true;
            for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {
              this.addType_(name, value);
            }
          }
          if (config.atrules) {
            for (const [name, atrule] of Object.entries(config.atrules)) {
              this.addAtrule_(name, atrule);
            }
          }
          if (config.properties) {
            for (const [name, property] of Object.entries(config.properties)) {
              this.addProperty_(name, property);
            }
          }
        }
        this.cssWideKeywordsSyntax = matchGraph.buildMatchGraph(this.cssWideKeywords.join(" |  "));
      }
      checkStructure(ast) {
        function collectWarning(node, message) {
          warns.push({ node, message });
        }
        const structure2 = this.structure;
        const warns = [];
        this.syntax.walk(ast, function(node) {
          if (structure2.hasOwnProperty(node.type)) {
            structure2[node.type].check(node, collectWarning);
          } else {
            collectWarning(node, "Unknown node type `" + node.type + "`");
          }
        });
        return warns.length ? warns : false;
      }
      createDescriptor(syntax, type, name, parent = null) {
        const ref = {
          type,
          name
        };
        const descriptor = {
          type,
          name,
          parent,
          serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
          syntax: null,
          match: null,
          matchRef: null
          // used for properties when a syntax referenced as <'property'> in other syntax definitions
        };
        if (typeof syntax === "function") {
          descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
        } else {
          if (typeof syntax === "string") {
            Object.defineProperty(descriptor, "syntax", {
              get() {
                Object.defineProperty(descriptor, "syntax", {
                  value: parse.parse(syntax)
                });
                return descriptor.syntax;
              }
            });
          } else {
            descriptor.syntax = syntax;
          }
          Object.defineProperty(descriptor, "match", {
            get() {
              Object.defineProperty(descriptor, "match", {
                value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
              });
              return descriptor.match;
            }
          });
          if (type === "Property") {
            Object.defineProperty(descriptor, "matchRef", {
              get() {
                const syntax2 = descriptor.syntax;
                const value = syntaxHasTopLevelCommaMultiplier(syntax2) ? matchGraph.buildMatchGraph({
                  ...syntax2,
                  terms: [syntax2.terms[0].term]
                }, ref) : null;
                Object.defineProperty(descriptor, "matchRef", {
                  value
                });
                return value;
              }
            });
          }
        }
        return descriptor;
      }
      addAtrule_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.atrules[name] = {
          type: "Atrule",
          name,
          prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
          descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
            (map, descName) => {
              map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
              return map;
            },
            /* @__PURE__ */ Object.create(null)
          ) : null
        };
      }
      addProperty_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.properties[name] = this.createDescriptor(syntax, "Property", name);
      }
      addType_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.types[name] = this.createDescriptor(syntax, "Type", name);
      }
      checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
          return new error.SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
        }
      }
      checkAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtruleName(atruleName);
        if (error2) {
          return error2;
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude && prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
        }
        if (atrule.prelude && !prelude) {
          if (!matchSyntax(this, atrule.prelude, "", false).matched) {
            return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
          }
        }
      }
      checkAtruleDescriptorName(atruleName, descriptorName) {
        const error$1 = this.checkAtruleName(atruleName);
        if (error$1) {
          return error$1;
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        if (!atrule.descriptors) {
          return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
        }
        if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
          return new error.SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
        }
      }
      checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
          return new error.SyntaxReferenceError("Unknown property", propertyName);
        }
      }
      matchAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtrulePrelude(atruleName, prelude);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude) {
          return buildMatchResult(null, null);
        }
        return matchSyntax(this, atrule.prelude, prelude || "", false);
      }
      matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
      }
      matchDeclaration(node) {
        if (node.type !== "Declaration") {
          return buildMatchResult(null, new Error("Not a Declaration node"));
        }
        return this.matchProperty(node.property, node.value);
      }
      matchProperty(propertyName, value) {
        if (names.property(propertyName).custom) {
          return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
        }
        const error2 = this.checkPropertyName(propertyName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        return matchSyntax(this, this.getProperty(propertyName), value, true);
      }
      matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);
        if (!typeSyntax) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Unknown type", typeName));
        }
        return matchSyntax(this, typeSyntax, value, false);
      }
      match(syntax, value) {
        if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Bad syntax"));
        }
        if (typeof syntax === "string" || !syntax.match) {
          syntax = this.createDescriptor(syntax, "Type", "anonymous");
        }
        return matchSyntax(this, syntax, value, false);
      }
      findValueFragments(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
      }
      findDeclarationValueFragments(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
      }
      findAllFragments(ast, type, name) {
        const result = [];
        this.syntax.walk(ast, {
          visit: "Declaration",
          enter: (declaration) => {
            result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
          }
        });
        return result;
      }
      getAtrule(atruleName, fallbackBasename = true) {
        const atrule = names.keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
        return atruleEntry || null;
      }
      getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);
        return atrule && atrule.prelude || null;
      }
      getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
      }
      getProperty(propertyName, fallbackBasename = true) {
        const property = names.property(propertyName);
        const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
        return propertyEntry || null;
      }
      getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
      }
      validate() {
        function syntaxRef(name, isType) {
          return isType ? `<${name}>` : `<'${name}'>`;
        }
        function validate(syntax, name, broken, descriptor) {
          if (broken.has(name)) {
            return broken.get(name);
          }
          broken.set(name, false);
          if (descriptor.syntax !== null) {
            walk.walk(descriptor.syntax, function(node) {
              if (node.type !== "Type" && node.type !== "Property") {
                return;
              }
              const map = node.type === "Type" ? syntax.types : syntax.properties;
              const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
              if (!hasOwnProperty.call(map, node.name)) {
                errors.push(`${syntaxRef(name, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
                broken.set(name, true);
              } else if (validate(syntax, node.name, brokenMap, map[node.name])) {
                errors.push(`${syntaxRef(name, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node.name, node.type === "Type")}`);
                broken.set(name, true);
              }
            }, this);
          }
        }
        const errors = [];
        let brokenTypes = /* @__PURE__ */ new Map();
        let brokenProperties = /* @__PURE__ */ new Map();
        for (const key in this.types) {
          validate(this, key, brokenTypes, this.types[key]);
        }
        for (const key in this.properties) {
          validate(this, key, brokenProperties, this.properties[key]);
        }
        const brokenTypesArray = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
        const brokenPropertiesArray = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
        if (brokenTypesArray.length || brokenPropertiesArray.length) {
          return {
            errors,
            types: brokenTypesArray,
            properties: brokenPropertiesArray
          };
        }
        return null;
      }
      dump(syntaxAsAst, pretty) {
        return {
          generic: this.generic,
          cssWideKeywords: this.cssWideKeywords,
          units: this.units,
          types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
          properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
          atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
      }
      toString() {
        return JSON.stringify(this.dump());
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/css-tree/cjs/syntax/config/mix.cjs
var require_mix = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/mix.cjs"(exports2, module2) {
    "use strict";
    function appendOrSet(a, b) {
      if (typeof b === "string" && /^\s*\|/.test(b)) {
        return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
      }
      return b || null;
    }
    function sliceProps(obj, props) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        if (value) {
          result[key] = {};
          for (const prop of Object.keys(value)) {
            if (props.includes(prop)) {
              result[key][prop] = value[prop];
            }
          }
        }
      }
      return result;
    }
    function mix(dest, src) {
      const result = { ...dest };
      for (const [prop, value] of Object.entries(src)) {
        switch (prop) {
          case "generic":
            result[prop] = Boolean(value);
            break;
          case "cssWideKeywords":
            result[prop] = dest[prop] ? [...dest[prop], ...value] : value || [];
            break;
          case "units":
            result[prop] = { ...dest[prop] };
            for (const [name, patch] of Object.entries(value)) {
              result[prop][name] = Array.isArray(patch) ? patch : [];
            }
            break;
          case "atrules":
            result[prop] = { ...dest[prop] };
            for (const [name, atrule] of Object.entries(value)) {
              const exists = result[prop][name] || {};
              const current = result[prop][name] = {
                prelude: exists.prelude || null,
                descriptors: {
                  ...exists.descriptors
                }
              };
              if (!atrule) {
                continue;
              }
              current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;
              for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
                current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
              }
              if (!Object.keys(current.descriptors).length) {
                current.descriptors = null;
              }
            }
            break;
          case "types":
          case "properties":
            result[prop] = { ...dest[prop] };
            for (const [name, syntax] of Object.entries(value)) {
              result[prop][name] = appendOrSet(result[prop][name], syntax);
            }
            break;
          case "scope":
          case "features":
            result[prop] = { ...dest[prop] };
            for (const [name, props] of Object.entries(value)) {
              result[prop][name] = { ...result[prop][name], ...props };
            }
            break;
          case "parseContext":
            result[prop] = {
              ...dest[prop],
              ...value
            };
            break;
          case "atrule":
          case "pseudo":
            result[prop] = {
              ...dest[prop],
              ...sliceProps(value, ["parse"])
            };
            break;
          case "node":
            result[prop] = {
              ...dest[prop],
              ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
            };
            break;
        }
      }
      return result;
    }
    module2.exports = mix;
  }
});

// node_modules/css-tree/cjs/syntax/create.cjs
var require_create5 = __commonJS({
  "node_modules/css-tree/cjs/syntax/create.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer();
    var create = require_create();
    var create$2 = require_create2();
    var create$3 = require_create3();
    var create$1 = require_create4();
    var Lexer = require_Lexer();
    var mix = require_mix();
    function createSyntax(config) {
      const parse = create.createParser(config);
      const walk = create$1.createWalker(config);
      const generate = create$2.createGenerator(config);
      const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);
      const syntax = {
        lexer: null,
        createLexer: (config2) => new Lexer.Lexer(config2, syntax, syntax.lexer.structure),
        tokenize: index.tokenize,
        parse,
        generate,
        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,
        fromPlainObject,
        toPlainObject,
        fork(extension) {
          const base = mix({}, config);
          return createSyntax(
            typeof extension === "function" ? extension(base) : mix(base, extension)
          );
        }
      };
      syntax.lexer = new Lexer.Lexer({
        generic: config.generic,
        cssWideKeywords: config.cssWideKeywords,
        units: config.units,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
      }, syntax);
      return syntax;
    }
    var createSyntax$1 = (config) => createSyntax(mix({}, config));
    module2.exports = createSyntax$1;
  }
});

// node_modules/css-tree/data/patch.json
var require_patch = __commonJS({
  "node_modules/css-tree/data/patch.json"(exports2, module2) {
    module2.exports = {
      atrules: {
        charset: {
          prelude: "<string>"
        },
        container: {
          prelude: "[ <container-name> ]? <container-condition>"
        },
        "font-face": {
          descriptors: {
            "unicode-range": {
              comment: "replaces <unicode-range>, an old production name",
              syntax: "<urange>#"
            }
          }
        },
        nest: {
          prelude: "<complex-selector-list>"
        },
        scope: {
          prelude: "[ ( <scope-start> ) ]? [ to ( <scope-end> ) ]?"
        },
        "position-try": {
          comment: "The list of descriptors: https://developer.mozilla.org/en-US/docs/Web/CSS/@position-try",
          descriptors: {
            top: "<'top'>",
            left: "<'left'>",
            bottom: "<'bottom'>",
            right: "<'right'>",
            "inset-block-start": "<'inset-block-start'>",
            "inset-block-end": "<'inset-block-end'>",
            "inset-inline-start": "<'inset-inline-start'>",
            "inset-inline-end": "<'inset-inline-end'>",
            "inset-block": "<'inset-block'>",
            "inset-inline": "<'inset-inline'>",
            inset: "<'inset'>",
            "margin-top": "<'margin-top'>",
            "margin-left": "<'margin-left'>",
            "margin-bottom": "<'margin-bottom'>",
            "margin-right": "<'margin-right'>",
            "margin-block-start": "<'margin-block-start'>",
            "margin-block-end": "<'margin-block-end'>",
            "margin-inline-start": "<'margin-inline-start'>",
            "margin-inline-end": "<'margin-inline-end'>",
            margin: "<'margin'>",
            "margin-block": "<'margin-block'>",
            "margin-inline": "<'margin-inline'>",
            width: "<'width'>",
            height: "<'height'>",
            "min-width": "<'min-width'>",
            "min-height": "<'min-height'>",
            "max-width": "<'max-width'>",
            "max-height": "<'max-height'>",
            "block-size": "<'block-size'>",
            "inline-size": "<'inline-size'>",
            "min-block-size": "<'min-block-size'>",
            "min-inline-size": "<'min-inline-size'>",
            "max-block-size": "<'max-block-size'>",
            "max-inline-size": "<'max-inline-size'>",
            "align-self": "<'align-self'> | anchor-center",
            "justify-self": "<'justify-self'> | anchor-center"
          }
        }
      },
      properties: {
        "-moz-background-clip": {
          comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "padding | border"
        },
        "-moz-border-radius-bottomleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
          syntax: "<'border-bottom-left-radius'>"
        },
        "-moz-border-radius-bottomright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-border-radius-topleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
          syntax: "<'border-top-left-radius'>"
        },
        "-moz-border-radius-topright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-control-character-visibility": {
          comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
          syntax: "visible | hidden"
        },
        "-moz-osx-font-smoothing": {
          comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | grayscale"
        },
        "-moz-user-select": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "none | text | all | -moz-none"
        },
        "-ms-flex-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "start | end | center | baseline | stretch"
        },
        "-ms-flex-item-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "auto | start | end | center | baseline | stretch"
        },
        "-ms-flex-line-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
          syntax: "start | end | center | justify | distribute | stretch"
        },
        "-ms-flex-negative": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-shrink'>"
        },
        "-ms-flex-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
          syntax: "start | end | center | justify | distribute"
        },
        "-ms-flex-order": {
          comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
          syntax: "<integer>"
        },
        "-ms-flex-positive": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-grow'>"
        },
        "-ms-flex-preferred-size": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-basis'>"
        },
        "-ms-interpolation-mode": {
          comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
          syntax: "nearest-neighbor | bicubic"
        },
        "-ms-grid-column-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-grid-row-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-hyphenate-limit-last": {
          comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
          syntax: "none | always | column | page | spread"
        },
        "-webkit-appearance": {
          comment: "webkit specific keywords",
          references: [
            "http://css-infos.net/property/-webkit-appearance"
          ],
          syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
        },
        "-webkit-background-clip": {
          comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "[ <box> | border | padding | content | text ]#"
        },
        "-webkit-column-break-after": {
          comment: "added, http://help.dottoro.com/lcrthhhv.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-before": {
          comment: "added, http://help.dottoro.com/lcxquvkf.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-inside": {
          comment: "added, http://help.dottoro.com/lclhnthl.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-font-smoothing": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | none | antialiased | subpixel-antialiased"
        },
        "-webkit-mask-box-image": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
        },
        "-webkit-print-color-adjust": {
          comment: "missed",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
          ],
          syntax: "economy | exact"
        },
        "-webkit-text-security": {
          comment: "missed; http://help.dottoro.com/lcbkewgt.php",
          syntax: "none | circle | disc | square"
        },
        "-webkit-user-drag": {
          comment: "missed; http://help.dottoro.com/lcbixvwm.php",
          syntax: "none | element | auto"
        },
        "-webkit-user-select": {
          comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "auto | none | text | all"
        },
        "alignment-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
          ],
          syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
        },
        "background-clip": {
          comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
          references: [
            "https://github.com/csstree/csstree/issues/190"
          ],
          syntax: "<bg-clip>#"
        },
        "baseline-shift": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
          ],
          syntax: "baseline | sub | super | <svg-length>"
        },
        behavior: {
          comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
          syntax: "<url>+"
        },
        "container-type": {
          comment: "https://www.w3.org/TR/css-contain-3/#propdef-container-type",
          syntax: "normal || [ size | inline-size ]"
        },
        cue: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'cue-before'> <'cue-after'>?"
        },
        "cue-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        "cue-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        cursor: {
          comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
          references: [
            "https://www.sitepoint.com/css3-cursor-styles/"
          ],
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
        },
        display: {
          comment: "extended with -ms-flexbox",
          syntax: "| <-non-standard-display>"
        },
        position: {
          comment: "extended with -webkit-sticky",
          syntax: "| -webkit-sticky"
        },
        "dominant-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
          ],
          syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
        },
        "image-rendering": {
          comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
            "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
          ],
          syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
        },
        fill: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<paint>"
        },
        "fill-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<number-zero-one>"
        },
        filter: {
          comment: "extend with IE legacy syntaxes",
          syntax: "| <-ms-filter-function-list>"
        },
        font: {
          comment: "align with font-4, fix <'font-family'>#, add non standard fonts",
          references: [
            "https://drafts.csswg.org/css-fonts-4/#font-prop",
            "https://github.com/w3c/csswg-drafts/pull/10832",
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "[ [ <'font-style'> || <font-variant-css2> || <'font-weight'> || <font-width-css3> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'># ] | <system-family-name> | <-non-standard-font>"
        },
        "glyph-orientation-horizontal": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
          ],
          syntax: "<angle>"
        },
        "glyph-orientation-vertical": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
          ],
          syntax: "<angle>"
        },
        kerning: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#KerningProperty"
          ],
          syntax: "auto | <svg-length>"
        },
        "letter-spacing": {
          comment: "fix syntax <length> -> <length-percentage>",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
          ],
          syntax: "normal | <length-percentage>"
        },
        "max-width": {
          comment: "extend by non-standard size keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "| stretch | <-non-standard-size>"
        },
        "max-height": {
          comment: "extend by non-standard size keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "| stretch | <-non-standard-size>"
        },
        width: {
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
            "https://github.com/csstree/stylelint-validator/issues/29"
          ],
          syntax: "| stretch | <-non-standard-size>"
        },
        height: {
          syntax: "| stretch | <-non-standard-size>"
        },
        "min-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "| stretch | <-non-standard-size>"
        },
        "min-height": {
          syntax: "| stretch | <-non-standard-size>"
        },
        overflow: {
          comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "| <-non-standard-overflow>"
        },
        pause: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'pause-before'> <'pause-after'>?"
        },
        "pause-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "pause-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        rest: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'rest-before'> <'rest-after'>?"
        },
        "rest-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "rest-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "scroll-timeline": {
          comment: "fix according to spec",
          references: [
            "https://www.w3.org/TR/scroll-animations-1/#scroll-timeline-shorthand"
          ],
          syntax: "[ <'scroll-timeline-name'> || <'scroll-timeline-axis'> ]#"
        },
        "scroll-timeline-name": {
          comment: "fix according to spec",
          references: [
            "https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"
          ],
          syntax: "[ none | <dashed-ident> ]#"
        },
        src: {
          comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
        },
        speak: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | never | always"
        },
        "speak-as": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
        },
        stroke: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<paint>"
        },
        "stroke-dasharray": {
          comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "none | [ <svg-length>+ ]#"
        },
        "stroke-dashoffset": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "stroke-linejoin": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "miter | round | bevel"
        },
        "stroke-miterlimit": {
          comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-one-or-greater>"
        },
        "stroke-width": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "text-wrap": {
          comment: "broken in mdn/data",
          syntax: "<'text-wrap-mode'> || <'text-wrap-style'>"
        },
        "unicode-bidi": {
          comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
          syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
        },
        "unicode-range": {
          comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
          syntax: "<urange>#"
        },
        "voice-balance": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<number> | left | center | right | leftwards | rightwards"
        },
        "voice-duration": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | <time>"
        },
        "voice-family": {
          comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
        },
        "voice-pitch": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-range": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-rate": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
        },
        "voice-stress": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | strong | moderate | none | reduced"
        },
        "voice-volume": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
        },
        "writing-mode": {
          comment: "extend with SVG keywords",
          syntax: "| <svg-writing-mode>"
        },
        "white-space-trim": {
          syntax: "none | discard-before || discard-after || discard-inner",
          comment: "missed, https://www.w3.org/TR/css-text-4/#white-space-trim"
        },
        "word-break": {
          syntax: "normal | break-all | keep-all | break-word | auto-phrase",
          comment: "added in Chrome/Edge 119, not covered by a spec currently (2024-09-02)",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/CSS/word-break"
          ]
        }
      },
      types: {
        "-legacy-gradient": {
          comment: "added collection of legacy gradient syntaxes",
          syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
        },
        "-legacy-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-repeating-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-linear-gradient-arguments": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
        },
        "-legacy-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-repeating-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-radial-gradient-arguments": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
        },
        "-legacy-radial-gradient-size": {
          comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
          syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
        },
        "-legacy-radial-gradient-shape": {
          comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
          syntax: "circle | ellipse"
        },
        "-non-standard-font": {
          comment: "non standard fonts",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
        },
        "-non-standard-color": {
          comment: "non standard colors",
          references: [
            "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
            "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
          ],
          syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
        },
        "-non-standard-image-rendering": {
          comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
          syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
        },
        "-non-standard-overflow": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "overlay | -moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
        },
        "-non-standard-size": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "intrinsic | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-min-content | -webkit-max-content  | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content"
        },
        "-webkit-gradient()": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
          syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
        },
        "-webkit-gradient-color-stop": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
        },
        "-webkit-gradient-point": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
        },
        "-webkit-gradient-radius": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "<length> | <percentage>"
        },
        "-webkit-gradient-type": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "linear | radial"
        },
        "-webkit-mask-box-repeat": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "repeat | stretch | round"
        },
        "-ms-filter-function-list": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function>+"
        },
        "-ms-filter-function": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
        },
        "-ms-filter-function-progid": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
        },
        "-ms-filter-function-legacy": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<ident-token> | <function-token> <any-value>? )"
        },
        "absolute-color-base": {
          comment: "https://www.w3.org/TR/css-color-4/#color-syntax",
          syntax: "<hex-color> | <absolute-color-function> | <named-color> | transparent"
        },
        "absolute-color-function": {
          comment: "https://www.w3.org/TR/css-color-4/#color-syntax",
          syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <oklab()> | <oklch()> | <color()>"
        },
        age: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "child | young | old"
        },
        "anchor-name": {
          comment: "missed in mdn/data",
          syntax: "<dashed-ident>"
        },
        "attr-name": {
          syntax: "<wq-name>"
        },
        "attr-fallback": {
          syntax: "<any-value>"
        },
        "bg-clip": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
          syntax: "<box> | border | text"
        },
        bottom: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "content-list": {
          comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
          syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
        },
        "container-name": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "<custom-ident>"
        },
        "container-condition": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "not <query-in-parens> | <query-in-parens> [ [ and <query-in-parens> ]* | [ or <query-in-parens> ]* ]"
        },
        "coord-box": {
          syntax: "content-box | padding-box | border-box | fill-box | stroke-box | view-box"
        },
        "element()": {
          comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
          syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
        },
        "generic-voice": {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "[ <age>? <gender> <integer>? ]"
        },
        gender: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "male | female | neutral"
        },
        "general-enclosed": {
          comment: "remove ident-token, optional any-value, brackets (see https://drafts.csswg.org/mediaqueries-5/#typedef-general-enclosed)",
          syntax: "[ <function-token> <any-value>? ) ] | [ ( <any-value>? ) ]"
        },
        "generic-family": {
          comment: "new definition on font-4, https://drafts.csswg.org/css-fonts-4/#typedef-generic-family",
          syntax: "<generic-script-specific>| <generic-complete> | <generic-incomplete> | <-non-standard-generic-family>"
        },
        "generic-script-specific": {
          syntax: "generic(kai) | generic(fangsong) | generic(nastaliq)"
        },
        "generic-complete": {
          syntax: "serif | sans-serif | system-ui | cursive | fantasy | math | monospace"
        },
        "generic-incomplete": {
          syntax: "ui-serif | ui-sans-serif | ui-monospace | ui-rounded"
        },
        "-non-standard-generic-family": {
          syntax: "-apple-system | BlinkMacSystemFont",
          references: [
            "https://css-tricks.com/snippets/css/system-font-stack/",
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ]
        },
        gradient: {
          comment: "added legacy syntaxes support",
          syntax: "| <-legacy-gradient>"
        },
        left: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        color: {
          comment: "css-color-5, added non standard color names",
          syntax: "<color-base> | currentColor | <system-color> | <device-cmyk()>  | <light-dark()> | <-non-standard-color>"
        },
        "color-base": {
          syntax: "<hex-color> | <color-function> | <named-color> | <color-mix()> | transparent"
        },
        "color-function": {
          syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <oklab()> | <oklch()> | <color()>"
        },
        "device-cmyk()": {
          syntax: "<legacy-device-cmyk-syntax> | <modern-device-cmyk-syntax>"
        },
        "legacy-device-cmyk-syntax": {
          syntax: "device-cmyk( <number>#{4} )"
        },
        "modern-device-cmyk-syntax": {
          syntax: "device-cmyk( <cmyk-component>{4} [ / [ <alpha-value> | none ] ]? )"
        },
        "cmyk-component": {
          syntax: "<number> | <percentage> | none"
        },
        "color-mix()": {
          syntax: "color-mix( <color-interpolation-method> , [ <color> && <percentage [0,100]>? ]#{2} )"
        },
        "color-interpolation-method": {
          syntax: "in [ <rectangular-color-space> | <polar-color-space> <hue-interpolation-method>? | <custom-color-space> ]"
        },
        "color-space": {
          syntax: "<rectangular-color-space> | <polar-color-space> | <custom-color-space>"
        },
        "custom-color-space": {
          syntax: "<dashed-ident>"
        },
        paint: {
          comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
          syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
        },
        "palette-identifier": {
          comment: "<palette-identifier> is parsed as a <dashed-ident> (https://drafts.csswg.org/css-fonts/#typedef-font-palette-palette-identifier)",
          syntax: "<dashed-ident>"
        },
        right: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        shape: {
          comment: "missed spaces in function body and add backwards compatible syntax",
          syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
        },
        "scope-start": {
          syntax: "<forgiving-selector-list>"
        },
        "scope-end": {
          syntax: "<forgiving-selector-list>"
        },
        "forgiving-selector-list": {
          syntax: "<complex-real-selector-list>"
        },
        "forgiving-relative-selector-list": {
          syntax: "<relative-real-selector-list>"
        },
        "selector-list": {
          syntax: "<complex-selector-list>"
        },
        "complex-real-selector-list": {
          syntax: "<complex-real-selector>#"
        },
        "simple-selector-list": {
          syntax: "<simple-selector>#"
        },
        "relative-real-selector-list": {
          syntax: "<relative-real-selector>#"
        },
        "complex-selector": {
          syntax: "<complex-selector-unit> [ <combinator>? <complex-selector-unit> ]*"
        },
        "complex-selector-unit": {
          syntax: "[ <compound-selector>? <pseudo-compound-selector>* ]!"
        },
        "complex-real-selector": {
          syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
        },
        "relative-real-selector": {
          syntax: "<combinator>? <complex-real-selector>"
        },
        "compound-selector": {
          syntax: "[ <type-selector>? <subclass-selector>* ]!"
        },
        "pseudo-compound-selector": {
          syntax: " <pseudo-element-selector> <pseudo-class-selector>*"
        },
        "simple-selector": {
          syntax: "<type-selector> | <subclass-selector>"
        },
        combinator: {
          syntax: "'>' | '+' | '~' | [ '|' '|' ]"
        },
        "pseudo-element-selector": {
          syntax: "':' <pseudo-class-selector> | <legacy-pseudo-element-selector>"
        },
        "legacy-pseudo-element-selector": {
          syntax: " ':' [before | after | first-line | first-letter]"
        },
        "single-animation-composition": {
          comment: "missed definition",
          references: [
            "https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"
          ],
          syntax: "replace | add | accumulate"
        },
        "svg-length": {
          comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
          references: [
            "https://www.w3.org/TR/SVG11/coords.html#Units"
          ],
          syntax: "<percentage> | <length> | <number>"
        },
        "svg-writing-mode": {
          comment: "SVG specific keywords (deprecated for CSS)",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
            "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
          ],
          syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
        },
        top: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        x: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        y: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        declaration: {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
        },
        "declaration-list": {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "[ <declaration>? ';' ]* <declaration>?"
        },
        url: {
          comment: "https://drafts.csswg.org/css-values-4/#urls",
          syntax: "url( <string> <url-modifier>* ) | <url-token>"
        },
        "url-modifier": {
          comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
          syntax: "<ident> | <function-token> <any-value> )"
        },
        "number-zero-one": {
          syntax: "<number [0,1]>"
        },
        "number-one-or-greater": {
          syntax: "<number [1,\u221E]>"
        },
        "color()": {
          syntax: "color( <colorspace-params> [ / [ <alpha-value> | none ] ]? )"
        },
        "colorspace-params": {
          syntax: "[ <predefined-rgb-params> | <xyz-params>]"
        },
        "predefined-rgb-params": {
          syntax: "<predefined-rgb> [ <number> | <percentage> | none ]{3}"
        },
        "predefined-rgb": {
          syntax: "srgb | srgb-linear | display-p3 | a98-rgb | prophoto-rgb | rec2020"
        },
        "xyz-params": {
          syntax: "<xyz-space> [ <number> | <percentage> | none ]{3}"
        },
        "xyz-space": {
          syntax: "xyz | xyz-d50 | xyz-d65"
        },
        "oklab()": {
          comment: "https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch",
          syntax: "oklab( [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
        },
        "oklch()": {
          comment: "https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch",
          syntax: "oklch( [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
        },
        "offset-path": {
          syntax: "<ray()> | <url> | <basic-shape>"
        },
        "basic-shape": {
          syntax: "<inset()> | <xywh()> | <rect()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
        },
        "rect()": {
          comment: "missed, https://drafts.csswg.org/css-shapes/#supported-basic-shapes",
          syntax: "rect( [ <length-percentage> | auto ]{4} [ round <'border-radius'> ]? )"
        },
        "xywh()": {
          comment: "missed, https://drafts.csswg.org/css-shapes/#supported-basic-shapes",
          syntax: "xywh( <length-percentage>{2} <length-percentage [0,\u221E]>{2} [ round <'border-radius'> ]? )"
        },
        "query-in-parens": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "( <container-condition> ) | ( <size-feature> ) | style( <style-query> ) | <general-enclosed>"
        },
        "size-feature": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#typedef-size-feature",
          syntax: "<mf-plain> | <mf-boolean> | <mf-range>"
        },
        "style-feature": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#typedef-style-feature",
          syntax: "<declaration>"
        },
        "style-query": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "<style-condition> | <style-feature>"
        },
        "style-condition": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "not <style-in-parens> | <style-in-parens> [ [ and <style-in-parens> ]* | [ or <style-in-parens> ]* ]"
        },
        "style-in-parens": {
          comment: "missed, https://drafts.csswg.org/css-contain-3/#container-rule",
          syntax: "( <style-condition> ) | ( <style-feature> ) | <general-enclosed>"
        },
        "-non-standard-display": {
          syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
        },
        "inset-area": {
          syntax: "[ [ left | center | right | span-left | span-right | x-start | x-end | span-x-start | span-x-end | x-self-start | x-self-end | span-x-self-start | span-x-self-end | span-all ] || [ top | center | bottom | span-top | span-bottom | y-start | y-end | span-y-start | span-y-end | y-self-start | y-self-end | span-y-self-start | span-y-self-end | span-all ] | [ block-start | center | block-end | span-block-start | span-block-end | span-all ] || [ inline-start | center | inline-end | span-inline-start | span-inline-end | span-all ] | [ self-block-start | self-block-end | span-self-block-start | span-self-block-end | span-all ] || [ self-inline-start | self-inline-end | span-self-inline-start | span-self-inline-end | span-all ] | [ start | center | end | span-start | span-end | span-all ]{1,2} | [ self-start | center | self-end | span-self-start | span-self-end | span-all ]{1,2} ]",
          comment: "initial name for <position-area> before renamed",
          references: [
            "https://www.w3.org/TR/css-anchor-position-1/#inset-area"
          ]
        },
        "position-area": {
          syntax: "[ [ left | center | right | span-left | span-right | x-start | x-end | span-x-start | span-x-end | x-self-start | x-self-end | span-x-self-start | span-x-self-end | span-all ] || [ top | center | bottom | span-top | span-bottom | y-start | y-end | span-y-start | span-y-end | y-self-start | y-self-end | span-y-self-start | span-y-self-end | span-all ] | [ block-start | center | block-end | span-block-start | span-block-end | span-all ] || [ inline-start | center | inline-end | span-inline-start | span-inline-end | span-all ] | [ self-block-start | center | self-block-end | span-self-block-start | span-self-block-end | span-all ] || [ self-inline-start | center | self-inline-end | span-self-inline-start | span-self-inline-end | span-all ] | [ start | center | end | span-start | span-end | span-all ]{1,2} | [ self-start | center | self-end | span-self-start | span-self-end | span-all ]{1,2} ]",
          comment: "replaced <inset-area>",
          references: [
            "https://drafts.csswg.org/css-anchor-position-1/#typedef-position-area"
          ]
        },
        "anchor()": {
          syntax: "anchor( <anchor-element>? && <anchor-side>, <length-percentage>? )",
          comment: "missed",
          references: [
            "https://drafts.csswg.org/css-anchor-position-1/#anchor-pos"
          ]
        },
        "anchor-side": {
          syntax: "inside | outside | top | left | right | bottom | start | end | self-start | self-end | <percentage> | center"
        },
        "anchor-size()": {
          syntax: "anchor-size( [ <anchor-element> || <anchor-size> ]? , <length-percentage>? )",
          comment: "missed",
          references: [
            "https://drafts.csswg.org/css-anchor-position-1/#funcdef-anchor-size"
          ]
        },
        "anchor-size": {
          syntax: "width | height | block | inline | self-block | self-inline"
        },
        "anchor-element": {
          syntax: "<dashed-ident>",
          comment: "missed, https://drafts.csswg.org/css-anchor-position-1/#typedef-anchor-element"
        },
        "try-size": {
          syntax: "most-width | most-height | most-block-size | most-inline-size",
          comment: "missed, https://drafts.csswg.org/css-anchor-position-1/#typedef-try-size"
        },
        "try-tactic": {
          syntax: "flip-block || flip-inline || flip-start",
          comment: "missed, https://drafts.csswg.org/css-anchor-position-1/#typedef-position-try-fallbacks-try-tactic"
        },
        "font-variant-css2": {
          syntax: "normal | small-caps",
          comment: "new definition on font-4, https://drafts.csswg.org/css-fonts-4/#font-variant-css21-values"
        },
        "font-width-css3": {
          syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded",
          comment: "new definition on font-4, https://drafts.csswg.org/css-fonts-4/#font-width-css3-values"
        },
        "system-family-name": {
          syntax: "caption | icon | menu | message-box | small-caption | status-bar",
          comment: "new definition on font-4, https://drafts.csswg.org/css-fonts-4/#system-family-name-value"
        }
      }
    };
  }
});

// node_modules/css-tree/cjs/data-patch.cjs
var require_data_patch = __commonJS({
  "node_modules/css-tree/cjs/data-patch.cjs"(exports2, module2) {
    "use strict";
    var patch = require_patch();
    var patch$1 = patch;
    module2.exports = patch$1;
  }
});

// node_modules/mdn-data/css/at-rules.json
var require_at_rules = __commonJS({
  "node_modules/mdn-data/css/at-rules.json"(exports2, module2) {
    module2.exports = {
      "@charset": {
        syntax: '@charset "<charset>";',
        groups: [
          "CSS Charsets"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
      },
      "@counter-style": {
        syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
        interfaces: [
          "CSSCounterStyleRule"
        ],
        groups: [
          "CSS Counter Styles"
        ],
        descriptors: {
          "additive-symbols": {
            syntax: "[ <integer> && <symbol> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          fallback: {
            syntax: "<counter-style-name>",
            media: "all",
            initial: "decimal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          negative: {
            syntax: "<symbol> <symbol>?",
            media: "all",
            initial: '"-" hyphen-minus',
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          pad: {
            syntax: "<integer> && <symbol>",
            media: "all",
            initial: '0 ""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          prefix: {
            syntax: "<symbol>",
            media: "all",
            initial: '""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          range: {
            syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "speak-as": {
            syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          suffix: {
            syntax: "<symbol>",
            media: "all",
            initial: '". "',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          symbols: {
            syntax: "<symbol>+",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          system: {
            syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
            media: "all",
            initial: "symbolic",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
      },
      "@document": {
        syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
      },
      "@font-palette-values": {
        syntax: "@font-palette-values <dashed-ident> {  <declaration-list> }",
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "base-palette": {
            syntax: "light | dark | <integer [0,\u221E]>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-family": {
            syntax: "<family-name>#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "override-colors": {
            syntax: "[ <integer [0,\u221E]> <absolute-color-base> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-palette-values"
      },
      "@font-face": {
        syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
        interfaces: [
          "CSSFontFaceRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "ascent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "descent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "font-display": {
            syntax: "[ auto | block | swap | fallback | optional ]",
            media: "visual",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "font-family": {
            syntax: "<family-name>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-feature-settings": {
            syntax: "normal | <feature-tag-value>#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-variation-settings": {
            syntax: "normal | [ <string> <number> ]#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-stretch": {
            syntax: "<font-stretch-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-style": {
            syntax: "normal | italic | oblique <angle>{0,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-weight": {
            syntax: "<font-weight-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "line-gap-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "size-adjust": {
            syntax: "<percentage>",
            media: "all",
            initial: "100%",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          src: {
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "unicode-range": {
            syntax: "<unicode-range>#",
            media: "all",
            initial: "U+0-10FFFF",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
      },
      "@font-feature-values": {
        syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
        interfaces: [
          "CSSFontFeatureValuesRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
      },
      "@import": {
        syntax: "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
      },
      "@keyframes": {
        syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
        interfaces: [
          "CSSKeyframeRule",
          "CSSKeyframesRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
      },
      "@layer": {
        syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
        interfaces: [
          "CSSLayerBlockRule",
          "CSSLayerStatementRule"
        ],
        groups: [
          "CSS Cascading and Inheritance"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
      },
      "@media": {
        syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSMediaRule",
          "CSSCustomMediaRule"
        ],
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
      },
      "@namespace": {
        syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
        groups: [
          "CSS Namespaces"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
      },
      "@page": {
        syntax: "@page <page-selector-list> {\n  <page-body>\n}",
        interfaces: [
          "CSSPageRule"
        ],
        groups: [
          "CSS Pages"
        ],
        descriptors: {
          bleed: {
            syntax: "auto | <length>",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          marks: {
            syntax: "none | [ crop || cross ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "none",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "page-orientation": {
            syntax: "upright | rotate-left | rotate-right ",
            media: [
              "visual",
              "paged"
            ],
            initial: "upright",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          size: {
            syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecifiedRelativeToAbsoluteLengths",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
      },
      "@position-try": {
        syntax: "@position-try <dashed-ident> {\n  <declaration-list>\n}",
        interfaces: [
          "CSSPositionTryRule"
        ],
        groups: [
          "CSS Positioning"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@position-try"
      },
      "@property": {
        syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
        interfaces: [
          "CSS",
          "CSSPropertyRule"
        ],
        groups: [
          "CSS Houdini"
        ],
        descriptors: {
          syntax: {
            syntax: "<string>",
            media: "all",
            percentages: "no",
            initial: "n/a (required)",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          inherits: {
            syntax: "true | false",
            media: "all",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "initial-value": {
            syntax: "<declaration-value>?",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          }
        },
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
      },
      "@scope": {
        syntax: "@scope [(<scope-start>)]? [to (<scope-end>)]? {\n  <rule-list>\n}",
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scope"
      },
      "@starting-style": {
        syntax: "@starting-style {\n  <declaration-list> | <group-rule-body>\n}",
        interfaces: [
          "CSSStartingStyleRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@starting-style"
      },
      "@supports": {
        syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSSupportsRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
      }
    };
  }
});

// node_modules/mdn-data/css/properties.json
var require_properties = __commonJS({
  "node_modules/mdn-data/css/properties.json"(exports2, module2) {
    module2.exports = {
      "--*": {
        syntax: "<declaration-value>",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Variables"
        ],
        initial: "seeProse",
        appliesto: "allElements",
        computed: "asSpecifiedWithVarsSubstituted",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
      },
      "-ms-accelerator": {
        syntax: "false | true",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "false",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
      },
      "-ms-block-progression": {
        syntax: "tb | rl | bt | lr",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "tb",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
      },
      "-ms-content-zoom-chaining": {
        syntax: "none | chained",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
      },
      "-ms-content-zooming": {
        syntax: "none | zoom",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "zoomForTheTopLevelNoneForTheRest",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
      },
      "-ms-content-zoom-limit": {
        syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
      },
      "-ms-content-zoom-limit-max": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "maxZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "400%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
      },
      "-ms-content-zoom-limit-min": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "minZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "100%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
      },
      "-ms-content-zoom-snap": {
        syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
      },
      "-ms-content-zoom-snap-points": {
        syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0%, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
      },
      "-ms-content-zoom-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
      },
      "-ms-filter": {
        syntax: "<string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: '""',
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
      },
      "-ms-flow-from": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
      },
      "-ms-flow-into": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "iframeElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
      },
      "-ms-grid-columns": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
      },
      "-ms-grid-rows": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
      },
      "-ms-high-contrast-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
      },
      "-ms-hyphenate-limit-chars": {
        syntax: "auto | <integer>{1,3}",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
      },
      "-ms-hyphenate-limit-lines": {
        syntax: "no-limit | <integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "no-limit",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
      },
      "-ms-hyphenate-limit-zone": {
        syntax: "<percentage> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToLineBoxWidth",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
      },
      "-ms-ime-align": {
        syntax: "auto | after",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
      },
      "-ms-overflow-style": {
        syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
      },
      "-ms-scrollbar-3dlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
      },
      "-ms-scrollbar-arrow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ButtonText",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
      },
      "-ms-scrollbar-base-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
      },
      "-ms-scrollbar-darkshadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
      },
      "-ms-scrollbar-face-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDFace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
      },
      "-ms-scrollbar-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDHighlight",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
      },
      "-ms-scrollbar-shadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
      },
      "-ms-scrollbar-track-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "Scrollbar",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
      },
      "-ms-scroll-chaining": {
        syntax: "chained | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "chained",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
      },
      "-ms-scroll-limit": {
        syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
      },
      "-ms-scroll-limit-x-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
      },
      "-ms-scroll-limit-x-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
      },
      "-ms-scroll-limit-y-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
      },
      "-ms-scroll-limit-y-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
      },
      "-ms-scroll-rails": {
        syntax: "none | railed",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "railed",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
      },
      "-ms-scroll-snap-points-x": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
      },
      "-ms-scroll-snap-points-y": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
      },
      "-ms-scroll-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
      },
      "-ms-scroll-snap-x": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
      },
      "-ms-scroll-snap-y": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
      },
      "-ms-scroll-translation": {
        syntax: "none | vertical-to-horizontal",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
      },
      "-ms-text-autospace": {
        syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
      },
      "-ms-touch-select": {
        syntax: "grippers | none",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "grippers",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
      },
      "-ms-user-select": {
        syntax: "none | element | text",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "text",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
      },
      "-ms-wrap-flow": {
        syntax: "auto | both | start | end | maximum | clear",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
      },
      "-ms-wrap-margin": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "exclusionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
      },
      "-ms-wrap-through": {
        syntax: "wrap | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "wrap",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
      },
      "-moz-appearance": {
        syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-moz-binding": {
        syntax: "<url> | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
      },
      "-moz-border-bottom-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
      },
      "-moz-border-left-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
      },
      "-moz-border-right-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
      },
      "-moz-border-top-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
      },
      "-moz-context-properties": {
        syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsThatCanReferenceImages",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
      },
      "-moz-float-edge": {
        syntax: "border-box | content-box | margin-box | padding-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "content-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
      },
      "-moz-force-broken-image-icon": {
        syntax: "0 | 1",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "images",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
      },
      "-moz-image-region": {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "xulImageElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
      },
      "-moz-orient": {
        syntax: "inline | block | horizontal | vertical",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "inline",
        appliesto: "anyElementEffectOnProgressAndMeter",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
      },
      "-moz-outline-radius": {
        syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        percentages: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        groups: [
          "Mozilla Extensions"
        ],
        initial: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        appliesto: "allElements",
        computed: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
      },
      "-moz-outline-radius-bottomleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
      },
      "-moz-outline-radius-bottomright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
      },
      "-moz-outline-radius-topleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
      },
      "-moz-outline-radius-topright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
      },
      "-moz-stack-sizing": {
        syntax: "ignore | stretch-to-fit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "stretch-to-fit",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
      },
      "-moz-text-blink": {
        syntax: "none | blink",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
      },
      "-moz-user-focus": {
        syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
      },
      "-moz-user-input": {
        syntax: "auto | none | enabled | disabled",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
      },
      "-moz-user-modify": {
        syntax: "read-only | read-write | write-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
      },
      "-moz-window-dragging": {
        syntax: "drag | no-drag",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "drag",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
      },
      "-moz-window-shadow": {
        syntax: "default | menu | tooltip | sheet | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "default",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
      },
      "-webkit-appearance": {
        syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-webkit-border-before": {
        syntax: "<'border-width'> || <'border-style'> || <color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: [
          "-webkit-border-before-width"
        ],
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "color"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
      },
      "-webkit-border-before-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "WebKit Extensions"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-box-reflect": {
        syntax: "[ above | below | right | left ]? <length>? <image>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
      },
      "-webkit-line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "WebKit Extensions",
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
      },
      "-webkit-mask": {
        syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "-webkit-mask-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
      },
      "-webkit-mask-clip": {
        syntax: "[ <box> | border | padding | content | text ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "border",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "-webkit-mask-composite": {
        syntax: "<composite-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "source-over",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
      },
      "-webkit-mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteURIOrNone",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "-webkit-mask-origin": {
        syntax: "[ <box> | border | padding | content ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "padding",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "-webkit-mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "-webkit-mask-position-x": {
        syntax: "[ <length-percentage> | left | center | right ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
      },
      "-webkit-mask-position-y": {
        syntax: "[ <length-percentage> | top | center | bottom ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
      },
      "-webkit-mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "-webkit-mask-repeat-x": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
      },
      "-webkit-mask-repeat-y": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
      },
      "-webkit-mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "-webkit-overflow-scrolling": {
        syntax: "auto | touch",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
      },
      "-webkit-tap-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "black",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
      },
      "-webkit-text-fill-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
      },
      "-webkit-text-stroke": {
        syntax: "<length> || <color>",
        media: "visual",
        inherited: true,
        animationType: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        order: "canonicalOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
      },
      "-webkit-text-stroke-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
      },
      "-webkit-text-stroke-width": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
      },
      "-webkit-touch-callout": {
        syntax: "default | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "default",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
      },
      "-webkit-user-modify": {
        syntax: "read-only | read-write | read-write-plaintext-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "accent-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
      },
      "align-content": {
        syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "blockContainersMultiColumnContainersFlexContainersGridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
      },
      "align-items": {
        syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
      },
      "align-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
        computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
      },
      "align-tracks": {
        syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
      },
      all: {
        syntax: "initial | inherit | unset | revert | revert-layer",
        media: "noPracticalMedia",
        inherited: false,
        animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "noPracticalInitialValue",
        appliesto: "allElements",
        computed: "asSpecifiedAppliesToEachProperty",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
      },
      "anchor-name": {
        syntax: "none | <dashed-ident>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsThatGenerateAPrincipalBox",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/anchor-name"
      },
      "anchor-scope": {
        syntax: "none | all | <dashed-ident>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/anchor-scope"
      },
      animation: {
        syntax: "<single-animation>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        appliesto: "allElements",
        computed: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-direction",
          "animation-iteration-count",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
      },
      "animation-composition": {
        syntax: "<single-animation-composition>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "replace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition"
      },
      "animation-delay": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
      },
      "animation-direction": {
        syntax: "<single-animation-direction>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
      },
      "animation-duration": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
      },
      "animation-fill-mode": {
        syntax: "<single-animation-fill-mode>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
      },
      "animation-iteration-count": {
        syntax: "<single-animation-iteration-count>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "1",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
      },
      "animation-name": {
        syntax: "[ none | <keyframes-name> ]#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
      },
      "animation-play-state": {
        syntax: "<single-animation-play-state>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "running",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
      },
      "animation-range": {
        syntax: "[ <'animation-range-start'> <'animation-range-end'>? ]#",
        media: "visual",
        inherited: false,
        animationType: [
          "animation-range-start",
          "animation-range-end"
        ],
        percentages: "relativeToTimelineRangeIfSpecifiedOtherwiseEntireTimeline",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-range-start",
          "animation-range-end"
        ],
        appliesto: "allElements",
        computed: [
          "animation-range-start",
          "animation-range-end"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-range"
      },
      "animation-range-end": {
        syntax: "[ normal | <length-percentage> | <timeline-range-name> <length-percentage>? ]#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "relativeToTimelineRangeIfSpecifiedOtherwiseEntireTimeline",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfNormalLengthPercentageOrNameLengthPercentage",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-range-end"
      },
      "animation-range-start": {
        syntax: "[ normal | <length-percentage> | <timeline-range-name> <length-percentage>? ]#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "relativeToTimelineRangeIfSpecifiedOtherwiseEntireTimeline",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfNormalLengthPercentageOrNameLengthPercentage",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-range-start"
      },
      "animation-timing-function": {
        syntax: "<easing-function>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
      },
      "animation-timeline": {
        syntax: "<single-animation-timeline>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "listEachItemIdentifierOrNoneAuto",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
      },
      appearance: {
        syntax: "none | auto | textfield | menulist-button | <compat-auto>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "aspect-ratio": {
        syntax: "auto || <ratio>",
        media: "all",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
      },
      azimuth: {
        syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
        media: "aural",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Speech"
        ],
        initial: "center",
        appliesto: "allElements",
        computed: "normalizedAngle",
        order: "orderOfAppearance",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
      },
      "backdrop-filter": {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
      },
      "backface-visibility": {
        syntax: "visible | hidden",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "visible",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
      },
      background: {
        syntax: "[ <bg-layer> , ]* <final-bg-layer>",
        media: "visual",
        inherited: false,
        animationType: [
          "background-color",
          "background-image",
          "background-clip",
          "background-position",
          "background-size",
          "background-repeat",
          "background-attachment"
        ],
        percentages: [
          "background-position",
          "background-size"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        appliesto: "allElements",
        computed: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
      },
      "background-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
      },
      "background-blend-mode": {
        syntax: "<blend-mode>#",
        media: "none",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
      },
      "background-clip": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "border-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
      },
      "background-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "transparent",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
      },
      "background-image": {
        syntax: "<bg-image>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
      },
      "background-origin": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
      },
      "background-position": {
        syntax: "<bg-position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: [
          "background-position-x",
          "background-position-y"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
      },
      "background-position-x": {
        syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageWidth",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
      },
      "background-position-y": {
        syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
      },
      "background-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "listEachItemHasTwoKeywordsOnePerDimension",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
      },
      "background-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
      },
      "block-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
      },
      border: {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-width",
          "border-style",
          "border-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-width",
          "border-style",
          "border-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
      },
      "border-block": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-width",
          "border-block-style",
          "border-block-color"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-block-width",
          "border-block-style",
          "border-block-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-block-width",
          "border-block-style",
          "border-block-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
      },
      "border-block-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
      },
      "border-block-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
      },
      "border-block-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
      },
      "border-block-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
      },
      "border-block-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
      },
      "border-block-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
      },
      "border-block-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
      },
      "border-block-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-block-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
      },
      "border-block-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
      },
      "border-block-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
      },
      "border-block-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
      },
      "border-bottom": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
      },
      "border-bottom-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
      },
      "border-bottom-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
      },
      "border-bottom-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
      },
      "border-bottom-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
      },
      "border-bottom-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
      },
      "border-collapse": {
        syntax: "collapse | separate",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "separate",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
      },
      "border-color": {
        syntax: "<color>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
      },
      "border-end-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
      },
      "border-end-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
      },
      "border-image": {
        syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        percentages: [
          "border-image-slice",
          "border-image-width"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ],
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
      },
      "border-image-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
      },
      "border-image-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "stretch",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
      },
      "border-image-slice": {
        syntax: "<number-percentage>{1,4} && fill?",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfBorderImage",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "100%",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
        order: "percentagesOrLengthsFollowedByFill",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
      },
      "border-image-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
      },
      "border-image-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToWidthOrHeightOfBorderImageArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "1",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
      },
      "border-inline": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-color",
          "border-inline-style",
          "border-inline-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-inline-width",
          "border-inline-style",
          "border-inline-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-inline-width",
          "border-inline-style",
          "border-inline-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
      },
      "border-inline-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-end-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
      },
      "border-inline-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
      },
      "border-inline-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
      },
      "border-inline-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
      },
      "border-inline-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
      },
      "border-inline-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
      },
      "border-inline-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
      },
      "border-inline-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
      },
      "border-inline-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
      },
      "border-inline-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
      },
      "border-inline-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
      },
      "border-left": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-left-color",
          "border-left-style",
          "border-left-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
      },
      "border-left-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
      },
      "border-left-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
      },
      "border-left-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
      },
      "border-radius": {
        syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: [
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-top-left-radius",
          "border-top-right-radius"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
      },
      "border-right": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-right-color",
          "border-right-style",
          "border-right-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
      },
      "border-right-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
      },
      "border-right-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
      },
      "border-right-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
      },
      "border-spacing": {
        syntax: "<length> <length>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "0",
        appliesto: "tableElements",
        computed: "twoAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
      },
      "border-start-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
      },
      "border-start-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
      },
      "border-style": {
        syntax: "<line-style>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-style",
          "border-left-style",
          "border-right-style",
          "border-top-style"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
      },
      "border-top": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-color",
          "border-top-style",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
      },
      "border-top-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
      },
      "border-top-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
      },
      "border-top-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
      },
      "border-top-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
      },
      "border-top-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
      },
      "border-width": {
        syntax: "<line-width>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
      },
      bottom: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
      },
      "box-align": {
        syntax: "start | center | end | baseline | stretch",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "stretch",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
      },
      "box-decoration-break": {
        syntax: "slice | clone",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "slice",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
      },
      "box-direction": {
        syntax: "normal | reverse | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "normal",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
      },
      "box-flex": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
      },
      "box-flex-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "inFlowChildrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
      },
      "box-lines": {
        syntax: "single | multiple",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "single",
        appliesto: "boxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
      },
      "box-ordinal-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "childrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
      },
      "box-orient": {
        syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "inlineAxisHorizontalInXUL",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
      },
      "box-pack": {
        syntax: "start | center | end | justify",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "start",
        appliesto: "elementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
      },
      "box-shadow": {
        syntax: "none | <shadow>#",
        media: "visual",
        inherited: false,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteLengthsSpecifiedColorAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
      },
      "box-sizing": {
        syntax: "content-box | border-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "content-box",
        appliesto: "allElementsAcceptingWidthOrHeight",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
      },
      "break-after": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
      },
      "break-before": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
      },
      "break-inside": {
        syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
      },
      "caption-side": {
        syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "top",
        appliesto: "tableCaptionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
      },
      caret: {
        syntax: "<'caret-color'> || <'caret-shape'>",
        media: "interactive",
        inherited: true,
        animationType: [
          "caret-color",
          "caret-shape"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "caret-color",
          "caret-shape"
        ],
        appliesto: "elementsThatAcceptInput",
        computed: [
          "caret-color",
          "caret-shape"
        ],
        order: "perGrammar",
        status: "standard"
      },
      "caret-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
      },
      "caret-shape": {
        syntax: "auto | bar | block | underscore",
        media: "interactive",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "elementsThatAcceptInput",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      clear: {
        syntax: "none | left | right | both | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
      },
      clip: {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: false,
        animationType: "rectangle",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "autoOrRectangle",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
      },
      "clip-path": {
        syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
      },
      "clip-rule": {
        syntax: "nonzero | evenodd",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "nonzero",
        appliesto: "limitedSVGElementsGraphics",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-rule"
      },
      color: {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "canvastext",
        appliesto: "allElementsAndText",
        computed: "computedColor",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
      },
      "color-interpolation-filters": {
        syntax: "auto | sRGB | linearRGB",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "linearRGB",
        appliesto: "limitedSVGElementsFilterPrimitives",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-rule"
      },
      "color-scheme": {
        syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
      },
      "column-count": {
        syntax: "<integer> | auto",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
      },
      "column-fill": {
        syntax: "auto | balance",
        media: "visualInContinuousMediaNoEffectInOverflowColumns",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "balance",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
      },
      "column-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "column-rule": {
        syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-rule-width",
          "column-rule-style",
          "column-rule-color"
        ],
        appliesto: "multicolElements",
        computed: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
      },
      "column-rule-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "currentcolor",
        appliesto: "multicolElements",
        computed: "computedColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
      },
      "column-rule-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
      },
      "column-rule-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "medium",
        appliesto: "multicolElements",
        computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
      },
      "column-span": {
        syntax: "none | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "inFlowBlockLevelElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
      },
      "column-width": {
        syntax: "<length> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "absoluteLengthZeroOrLarger",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
      },
      columns: {
        syntax: "<'column-width'> || <'column-count'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-width",
          "column-count"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-width",
          "column-count"
        ],
        appliesto: "blockContainersExceptTableWrappers",
        computed: [
          "column-width",
          "column-count"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
      },
      contain: {
        syntax: "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
        media: "all",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
      },
      "contain-intrinsic-size": {
        syntax: "[ auto? [ none | <length> ] ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        percentages: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        groups: [
          "CSS Containment"
        ],
        initial: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"
      },
      "contain-intrinsic-block-size": {
        syntax: "auto? [ none | <length> ]",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"
      },
      "contain-intrinsic-height": {
        syntax: "auto? [ none | <length> ]",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"
      },
      "contain-intrinsic-inline-size": {
        syntax: "auto? [ none | <length> ]",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"
      },
      "contain-intrinsic-width": {
        syntax: "auto? [ none | <length> ]",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"
      },
      container: {
        syntax: "<'container-name'> [ / <'container-type'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "container-name",
          "container-type"
        ],
        percentages: [
          "container-name",
          "container-type"
        ],
        groups: [
          "CSS Containment"
        ],
        initial: [
          "container-name",
          "container-type"
        ],
        appliesto: "allElements",
        computed: [
          "container-name",
          "container-type"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/container"
      },
      "container-name": {
        syntax: "none | <custom-ident>+",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "noneOrOrderedListOfIdentifiers",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/container-name"
      },
      "container-type": {
        syntax: "normal | size | inline-size",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/container-type"
      },
      content: {
        syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "normal",
        appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
        computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
      },
      "content-visibility": {
        syntax: "visible | auto | hidden",
        media: "all",
        inherited: false,
        animationType: "discreteButVisibleForDurationWhenAnimatedHidden",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "visible",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
      },
      "counter-increment": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
      },
      "counter-reset": {
        syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
      },
      "counter-set": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
      },
      cursor: {
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
      },
      d: {
        syntax: "none | path(<string>)",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsPath",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/d"
      },
      cx: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportWidth",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsEllipse",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cx"
      },
      cy: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportHeight",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsEllipse",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cy"
      },
      direction: {
        syntax: "ltr | rtl",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "ltr",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
      },
      display: {
        syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
        media: "all",
        inherited: false,
        animationType: "discreteButVisibleForDurationWhenAnimatedNone",
        percentages: "no",
        groups: [
          "CSS Display"
        ],
        initial: "inline",
        appliesto: "allElements",
        computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
      },
      "dominant-baseline": {
        syntax: "auto | text-bottom | alphabetic | ideographic | middle | central | mathematical | hanging | text-top",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainersInlineBoxesTableRowsSVGTextContentElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/dominant-baseline"
      },
      "empty-cells": {
        syntax: "show | hide",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "show",
        appliesto: "tableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
      },
      "field-sizing": {
        syntax: "content | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "fixed",
        appliesto: "elementsWithDefaultPreferredSize",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/field-sizing"
      },
      fill: {
        syntax: "none | <color> | <url> [none | <color>]? | context-fill | context-stroke",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "black",
        appliesto: "limitedSVGElementsShapeText",
        computed: "asColorOrAbsoluteURL",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/fill"
      },
      "fill-opacity": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "mapToRange0To1",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "1",
        appliesto: "limitedSVGElementsShapeText",
        computed: "specifiedValueNumberClipped0To1",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/fill-opacity"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "nonzero",
        appliesto: "limitedSVGElementsShapeText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/fill-rule"
      },
      filter: {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
      },
      flex: {
        syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        appliesto: "flexItemsAndInFlowPseudos",
        computed: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
      },
      "flex-basis": {
        syntax: "content | <'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToFlexContainersInnerMainSize",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "auto",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
      },
      "flex-direction": {
        syntax: "row | row-reverse | column | column-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "row",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
      },
      "flex-flow": {
        syntax: "<'flex-direction'> || <'flex-wrap'>",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-direction",
          "flex-wrap"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-direction",
          "flex-wrap"
        ],
        appliesto: "flexContainers",
        computed: [
          "flex-direction",
          "flex-wrap"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
      },
      "flex-grow": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
      },
      "flex-shrink": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "1",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
      },
      "flex-wrap": {
        syntax: "nowrap | wrap | wrap-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "nowrap",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
      },
      float: {
        syntax: "left | right | none | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsNoEffectIfDisplayNone",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
      },
      font: {
        syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
        media: "visual",
        inherited: true,
        animationType: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        percentages: [
          "font-size",
          "line-height"
        ],
        groups: [
          "CSS Fonts"
        ],
        initial: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        appliesto: "allElementsAndText",
        computed: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
      },
      "font-family": {
        syntax: "[ <family-name> | <generic-family> ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
      },
      "font-kerning": {
        syntax: "auto | normal | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
      },
      "font-language-override": {
        syntax: "normal | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
      },
      "font-optical-sizing": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
      },
      "font-palette": {
        syntax: "normal | light | dark | <palette-identifier>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard"
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "visual",
        inherited: true,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
      },
      "font-size": {
        syntax: "<absolute-size> | <relative-size> | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToParentElementsFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "medium",
        appliesto: "allElementsAndText",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
      },
      "font-size-adjust": {
        syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
        media: "visual",
        inherited: true,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
      },
      "font-smooth": {
        syntax: "auto | never | always | <absolute-size> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>",
        media: "visual",
        inherited: true,
        animationType: "fontStretch",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>?",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueTypeNormalAnimatesAsObliqueZeroDeg",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
      },
      "font-synthesis": {
        syntax: "none | [ weight || style || small-caps || position]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "weight style small-caps position ",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
      },
      "font-synthesis-position": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis-position"
      },
      "font-synthesis-small-caps": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis-small-caps"
      },
      "font-synthesis-style": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis-style"
      },
      "font-synthesis-weight": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis-weight"
      },
      "font-variant": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
      },
      "font-variant-alternates": {
        syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
      },
      "font-variant-caps": {
        syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
      },
      "font-variant-east-asian": {
        syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
      },
      "font-variant-emoji": {
        syntax: "normal | text | emoji | unicode",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard"
      },
      "font-variant-ligatures": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
      },
      "font-variant-numeric": {
        syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
      },
      "font-variant-position": {
        syntax: "normal | sub | super",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
      },
      "font-weight": {
        syntax: "<font-weight-absolute> | bolder | lighter",
        media: "visual",
        inherited: true,
        animationType: "fontWeight",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
      },
      "forced-color-adjust": {
        syntax: "auto | none | preserve-parent-color",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
      },
      gap: {
        syntax: "<'row-gap'> <'column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "row-gap",
          "column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "row-gap",
          "column-gap"
        ],
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: [
          "row-gap",
          "column-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      grid: {
        syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        percentages: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-auto-rows",
          "grid-auto-columns"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
      },
      "grid-area": {
        syntax: "<grid-line> [ / <grid-line> ]{0,3}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
      },
      "grid-auto-columns": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
      },
      "grid-auto-flow": {
        syntax: "[ row | column ] || dense",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "row",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
      },
      "grid-auto-rows": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
      },
      "grid-column": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-column-start",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-column-start",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
      },
      "grid-column-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
      },
      "grid-column-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "grid-column-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
      },
      "grid-gap": {
        syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      "grid-row": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-row-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-row-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
      },
      "grid-row-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
      },
      "grid-row-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "grid-row-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
      },
      "grid-template": {
        syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        percentages: [
          "grid-template-columns",
          "grid-template-rows"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
      },
      "grid-template-areas": {
        syntax: "none | <string>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
      },
      "grid-template-columns": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
      },
      "grid-template-rows": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
      },
      "hanging-punctuation": {
        syntax: "none | [ first || [ force-end | allow-end ] || last ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
      },
      height: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAutoOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
      },
      "hyphenate-character": {
        syntax: "auto | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
      },
      "hyphenate-limit-chars": {
        syntax: "[ auto | <integer> ]{1,3}",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-limit-chars"
      },
      hyphens: {
        syntax: "none | manual | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "manual",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
      },
      "image-orientation": {
        syntax: "from-image | <angle> | [ <angle>? flip ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "from-image",
        appliesto: "allElements",
        computed: "angleRoundedToNextQuarter",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
      },
      "image-rendering": {
        syntax: "auto | crisp-edges | pixelated",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
      },
      "image-resolution": {
        syntax: "[ from-image || <resolution> ] && snap?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "1dppx",
        appliesto: "allElements",
        computed: "asSpecifiedWithExceptionOfResolution",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ime-mode": {
        syntax: "auto | normal | active | inactive | disabled",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "textFields",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
      },
      "initial-letter": {
        syntax: "normal | [ <number> <integer>? ]",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "normal",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
      },
      "initial-letter-align": {
        syntax: "[ auto | alphabetic | hanging | ideographic ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "auto",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
      },
      "inline-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
      },
      "input-security": {
        syntax: "auto | none",
        media: "interactive",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "sensitiveTextInputs",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      inset: {
        syntax: "<'top'>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOrWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "top",
          "bottom",
          "left",
          "right"
        ],
        appliesto: "positionedElements",
        computed: [
          "top",
          "bottom",
          "left",
          "right"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
      },
      "inset-block": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "inset-block-start",
          "inset-block-end"
        ],
        appliesto: "positionedElements",
        computed: [
          "inset-block-start",
          "inset-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
      },
      "inset-block-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
      },
      "inset-block-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
      },
      "inset-inline": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "inset-inline-start",
          "inset-inline-end"
        ],
        appliesto: "positionedElements",
        computed: [
          "inset-inline-start",
          "inset-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
      },
      "inset-inline-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
      },
      "inset-inline-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
      },
      "interpolate-size": {
        syntax: "numeric-only | allow-keywords",
        media: "none",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Units"
        ],
        initial: "numeric-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/interpolate-size"
      },
      isolation: {
        syntax: "auto | isolate",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
      },
      "justify-content": {
        syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
      },
      "justify-items": {
        syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "legacy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
      },
      "justify-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
      },
      "justify-tracks": {
        syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
      },
      left: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
      },
      "letter-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumValueOfAbsoluteLengthOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
      },
      "line-break": {
        syntax: "auto | loose | normal | strict | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
      },
      "line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "line-height": {
        syntax: "normal | <number> | <length> | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "numberOrLength",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLengthOrAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
      },
      "line-height-step": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "absoluteLength",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
      },
      "list-style": {
        syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
        media: "visual",
        inherited: true,
        animationType: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: [
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ],
        appliesto: "listItems",
        computed: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
      },
      "list-style-image": {
        syntax: "<image> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "none",
        appliesto: "listItems",
        computed: "theKeywordListStyleImageNoneOrComputedValue",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
      },
      "list-style-position": {
        syntax: "inside | outside",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "outside",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
      },
      "list-style-type": {
        syntax: "<counter-style> | <string> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "disc",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
      },
      margin: {
        syntax: "[ <length> | <percentage> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
      },
      "margin-block": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "margin-block-start",
          "margin-block-end"
        ],
        appliesto: "sameAsMargin",
        computed: [
          "margin-block-start",
          "margin-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
      },
      "margin-block-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
      },
      "margin-block-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
      },
      "margin-bottom": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
      },
      "margin-inline": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "margin-inline-start",
          "margin-inline-end"
        ],
        appliesto: "sameAsMargin",
        computed: [
          "margin-inline-start",
          "margin-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
      },
      "margin-inline-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
      },
      "margin-inline-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
      },
      "margin-left": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
      },
      "margin-right": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
      },
      "margin-top": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
      },
      "margin-trim": {
        syntax: "none | in-flow | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "blockContainersAndMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
      },
      marker: {
        syntax: "none | <url>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: [
          "marker-start",
          "marker-mid",
          "marker-end"
        ],
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/marker"
      },
      "marker-end": {
        syntax: "none | <url>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/marker-end"
      },
      "marker-mid": {
        syntax: "none | <url>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/marker-mid"
      },
      "marker-start": {
        syntax: "none | <url>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/marker-start"
      },
      mask: {
        syntax: "<mask-layer>#",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        percentages: [
          "mask-position"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "mask-border": {
        syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        percentages: [
          "mask-border-slice",
          "mask-border-width"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
      },
      "mask-border-mode": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "alpha",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
      },
      "mask-border-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
      },
      "mask-border-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "stretch",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
      },
      "mask-border-slice": {
        syntax: "<number-percentage>{1,4} fill?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfMaskBorderImage",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
      },
      "mask-border-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
      },
      "mask-border-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToMaskBorderImageArea",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
      },
      "mask-clip": {
        syntax: "[ <geometry-box> | no-clip ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "mask-composite": {
        syntax: "<compositing-operator>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "add",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
      },
      "mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "mask-mode": {
        syntax: "<masking-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "match-source",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
      },
      "mask-origin": {
        syntax: "<geometry-box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "referToSizeOfMaskPaintingArea",
        groups: [
          "CSS Masking"
        ],
        initial: "0% 0%",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoKeywordsForOriginAndOffsets",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "repeat",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoDimensionKeywords",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableList",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "mask-type": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "luminance",
        appliesto: "maskElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
      },
      "masonry-auto-flow": {
        syntax: "[ pack | next ] || [ definite-first | ordered ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "pack",
        appliesto: "gridContainersWithMasonryLayout",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
      },
      "math-depth": {
        syntax: "auto-add | add(<integer>) | <integer>",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth"
      },
      "math-shift": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift"
      },
      "math-style": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
      },
      "max-block-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
      },
      "max-height": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
      },
      "max-inline-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
      },
      "max-lines": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "max-width": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
      },
      "min-block-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
      },
      "min-height": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
      },
      "min-inline-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
      },
      "min-width": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
      },
      "mix-blend-mode": {
        syntax: "<blend-mode> | plus-lighter",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
      },
      "object-fit": {
        syntax: "fill | contain | cover | none | scale-down",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "fill",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
      },
      "object-position": {
        syntax: "<position>",
        media: "visual",
        inherited: true,
        animationType: "repeatableList",
        percentages: "referToWidthAndHeightOfElement",
        groups: [
          "CSS Images"
        ],
        initial: "50% 50%",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
      },
      offset: {
        syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        percentages: [
          "offset-position",
          "offset-distance",
          "offset-anchor"
        ],
        groups: [
          "CSS Motion Path"
        ],
        initial: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        appliesto: "transformableElements",
        computed: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
      },
      "offset-anchor": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "relativeToWidthAndHeight",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-anchor"
      },
      "offset-distance": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToTotalPathLength",
        groups: [
          "CSS Motion Path"
        ],
        initial: "0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
      },
      "offset-path": {
        syntax: "none | <offset-path> || <coord-box>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
      },
      "offset-position": {
        syntax: "normal | auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "referToSizeOfContainingBlock",
        groups: [
          "CSS Motion Path"
        ],
        initial: "normal",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "experimental"
      },
      "offset-rotate": {
        syntax: "[ auto | reverse ] || <angle>",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
      },
      opacity: {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "mapToRange0To1",
        groups: [
          "CSS Color"
        ],
        initial: "1",
        appliesto: "allElements",
        computed: "specifiedValueNumberClipped0To1",
        order: "perGrammar",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
      },
      order: {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
      },
      orphans: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
      },
      outline: {
        syntax: "[ <'outline-width'> || <'outline-style'> || <'outline-color'> ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: [
          "outline-width",
          "outline-style",
          "outline-color"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "outline-width",
          "outline-style",
          "outline-color"
        ],
        appliesto: "allElements",
        computed: [
          "outline-width",
          "outline-style",
          "outline-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
      },
      "outline-color": {
        syntax: "auto | <color>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "autoForTranslucentColorRGBAOtherwiseRGB",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
      },
      "outline-offset": {
        syntax: "<length>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
      },
      "outline-style": {
        syntax: "auto | <'border-style'>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
      },
      "outline-width": {
        syntax: "<line-width>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLength0ForNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
      },
      overflow: {
        syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: [
          "overflow-x",
          "overflow-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
      },
      "overflow-anchor": {
        syntax: "auto | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Anchoring"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-block": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-clip-box": {
        syntax: "padding-box | content-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
      },
      "overflow-clip-margin": {
        syntax: "<visual-box> || <length [0,\u221E]>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "0px",
        appliesto: "allElements",
        computed: "theComputedLengthAndVisualBox",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-inline": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-wrap": {
        syntax: "normal | break-word | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "overflow-x": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
      },
      "overflow-y": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
      },
      overlay: {
        syntax: "none | auto",
        media: "visual",
        inherited: false,
        animationType: "discreteButVisibleForDurationWhenAnimatedNone",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overlay"
      },
      "overscroll-behavior": {
        syntax: "[ contain | none | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "overscroll-behavior-x",
          "overscroll-behavior-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
      },
      "overscroll-behavior-block": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
      },
      "overscroll-behavior-inline": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
      },
      "overscroll-behavior-x": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
      },
      "overscroll-behavior-y": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
      },
      padding: {
        syntax: "[ <length> | <percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
      },
      "padding-block": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "padding-block-start",
          "padding-block-end"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-block-start",
          "padding-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
      },
      "padding-block-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
      },
      "padding-block-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
      },
      "padding-bottom": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
      },
      "padding-inline": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "padding-inline-start",
          "padding-inline-end"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-inline-start",
          "padding-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
      },
      "padding-inline-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
      },
      "padding-inline-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
      },
      "padding-left": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
      },
      "padding-right": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
      },
      "padding-top": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
      },
      page: {
        syntax: "auto | <custom-ident>",
        media: "paged",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page"
      },
      "page-break-after": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
      },
      "page-break-before": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
      },
      "page-break-inside": {
        syntax: "auto | avoid",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
      },
      "paint-order": {
        syntax: "normal | [ fill || stroke || markers ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
      },
      perspective: {
        syntax: "none | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "absoluteLengthOrNone",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
      },
      "perspective-origin": {
        syntax: "<position>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50%",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
      },
      "place-content": {
        syntax: "<'align-content'> <'justify-content'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-content",
          "justify-content"
        ],
        appliesto: "multilineFlexContainers",
        computed: [
          "align-content",
          "justify-content"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
      },
      "place-items": {
        syntax: "<'align-items'> <'justify-items'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-items",
          "justify-items"
        ],
        appliesto: "allElements",
        computed: [
          "align-items",
          "justify-items"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
      },
      "place-self": {
        syntax: "<'align-self'> <'justify-self'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-self",
          "justify-self"
        ],
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: [
          "align-self",
          "justify-self"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
      },
      "pointer-events": {
        syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
      },
      position: {
        syntax: "static | relative | absolute | sticky | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "static",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
      },
      "position-anchor": {
        syntax: "auto | <anchor-name>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-anchor"
      },
      "position-area": {
        syntax: "none | <position-area>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "positionedElementsWithADefaultAnchorElement",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-area"
      },
      "position-try": {
        syntax: "<'position-try-order'>? <'position-try-fallbacks'>",
        media: "visual",
        inherited: false,
        animationType: [
          "position-try-fallbacks",
          "position-try-order"
        ],
        percentages: [
          "position-try-fallbacks",
          "position-try-order"
        ],
        groups: [
          "CSS Positioning"
        ],
        initial: [
          "position-try-fallbacks",
          "position-try-order"
        ],
        appliesto: "absolutelyPositionedElements",
        computed: [
          "position-try-fallbacks",
          "position-try-order"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-try"
      },
      "position-try-fallbacks": {
        syntax: "none | [ [<dashed-ident> || <try-tactic>] | <'position-area'> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "absolutelyPositionedElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-try-fallbacks"
      },
      "position-try-order": {
        syntax: "normal | <try-size>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "normal",
        appliesto: "absolutelyPositionedElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-try-order"
      },
      "position-visibility": {
        syntax: "always | [ anchors-valid || anchors-visible || no-overflow ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "anchors-visible",
        appliesto: "absolutelyPositionedElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position-visibility"
      },
      "print-color-adjust": {
        syntax: "economy | exact",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "economy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
      },
      quotes: {
        syntax: "none | auto | [ <string> <string> ]+",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
      },
      r: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportSize",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsCircle",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/r"
      },
      resize: {
        syntax: "none | both | horizontal | vertical | block | inline",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
      },
      right: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
      },
      rotate: {
        syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
      },
      "row-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "ruby-align": {
        syntax: "start | center | space-between | space-around",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "space-around",
        appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
      },
      "ruby-merge": {
        syntax: "separate | collapse | auto",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "separate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ruby-position": {
        syntax: "[ alternate || [ over | under ] ] | inter-character",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "alternate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
      },
      rx: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportWidth",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsEllipseRect",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rx"
      },
      ry: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportHeight",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsEllipseRect",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ry"
      },
      scale: {
        syntax: "none | [ <number> | <percentage> ]{1,3}",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
      },
      "scrollbar-color": {
        syntax: "auto | <color>{2}",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
      },
      "scrollbar-gutter": {
        syntax: "auto | stable && both-edges?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
      },
      "scrollbar-width": {
        syntax: "auto | thin | none",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
      },
      "scroll-behavior": {
        syntax: "auto | smooth",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
      },
      "scroll-margin": {
        syntax: "<length>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-bottom",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-bottom",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
      },
      "scroll-margin-block": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-block-start",
          "scroll-margin-block-end"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-block-start",
          "scroll-margin-block-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
      },
      "scroll-margin-block-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
      },
      "scroll-margin-block-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
      },
      "scroll-margin-bottom": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
      },
      "scroll-margin-inline": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-inline-start",
          "scroll-margin-inline-end"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-inline-start",
          "scroll-margin-inline-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
      },
      "scroll-margin-inline-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
      },
      "scroll-margin-inline-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
      },
      "scroll-margin-left": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
      },
      "scroll-margin-right": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
      },
      "scroll-margin-top": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
      },
      "scroll-padding": {
        syntax: "[ auto | <length-percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-bottom",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-bottom",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
      },
      "scroll-padding-block": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-block-start",
          "scroll-padding-block-end"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-block-start",
          "scroll-padding-block-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
      },
      "scroll-padding-block-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
      },
      "scroll-padding-block-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
      },
      "scroll-padding-bottom": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
      },
      "scroll-padding-inline": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-inline-start",
          "scroll-padding-inline-end"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-inline-start",
          "scroll-padding-inline-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
      },
      "scroll-padding-inline-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
      },
      "scroll-padding-inline-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
      },
      "scroll-padding-left": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
      },
      "scroll-padding-right": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
      },
      "scroll-padding-top": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
      },
      "scroll-snap-align": {
        syntax: "[ none | start | end | center ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
      },
      "scroll-snap-coordinate": {
        syntax: "none | <position>#",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "referToBorderBox",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
      },
      "scroll-snap-destination": {
        syntax: "<position>",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0px 0px",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
      },
      "scroll-snap-points-x": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
      },
      "scroll-snap-points-y": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
      },
      "scroll-snap-stop": {
        syntax: "normal | always",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
      },
      "scroll-snap-type": {
        syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
      },
      "scroll-snap-type-x": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
      },
      "scroll-snap-type-y": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
      },
      "scroll-timeline": {
        syntax: "[ <'scroll-timeline-name'> <'scroll-timeline-axis'>? ]#",
        media: "visual",
        inherited: false,
        animationType: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"
      },
      "scroll-timeline-axis": {
        syntax: "[ block | inline | x | y ]#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "block",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"
      },
      "scroll-timeline-name": {
        syntax: "none | <dashed-ident>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "noneOrOrderedListOfIdentifiers",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"
      },
      "shape-image-threshold": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "0.0",
        appliesto: "floats",
        computed: "specifiedValueNumberClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
      },
      "shape-margin": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Shapes"
        ],
        initial: "0",
        appliesto: "floats",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
      },
      "shape-outside": {
        syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "none",
        appliesto: "floats",
        computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
      },
      "shape-rendering": {
        syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "auto",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-rendering"
      },
      stroke: {
        syntax: "",
        media: "visual",
        inherited: true,
        animationType: [
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width"
        ],
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: [
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width"
        ],
        appliesto: "asLonghands",
        computed: "asLonghands",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke"
      },
      "stroke-dasharray": {
        syntax: "none | <dasharray>",
        media: "visual",
        inherited: true,
        animationType: "repeatableList",
        percentages: "referToSVGViewportDiagonal",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsShapes",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageOrKeyword",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-dasharray"
      },
      "stroke-dashoffset": {
        syntax: "<length-percentage> | <number>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportDiagonal",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsShapes",
        computed: "absoluteLengthOrPercentageNumbersConverted",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-dashoffset"
      },
      "stroke-linecap": {
        syntax: "butt | round | square",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "butt",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-linecap"
      },
      "stroke-linejoin": {
        syntax: "miter | miter-clip | round | bevel | arcs",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "miter",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-linejoin"
      },
      "stroke-miterlimit": {
        syntax: "<number>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "4",
        appliesto: "limitedSVGElementsShapes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-miterlimit"
      },
      "stroke-opacity": {
        syntax: "<'opacity'>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "1",
        appliesto: "limitedSVGElementsShapes",
        computed: "specifiedValueClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-opacity"
      },
      "stroke-width": {
        syntax: "<length-percentage> | <number>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportDiagonal",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "1px",
        appliesto: "limitedSVGElementsShapes",
        computed: "absoluteLengthOrPercentageNumbersConverted",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/stroke-width"
      },
      "tab-size": {
        syntax: "<integer> | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "8",
        appliesto: "blockContainers",
        computed: "specifiedIntegerOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
      },
      "table-layout": {
        syntax: "auto | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "auto",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
      },
      "text-align": {
        syntax: "start | end | left | right | center | justify | match-parent",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "startOrNamelessValueIfLTRRightIfRTL",
        appliesto: "blockContainers",
        computed: "asSpecifiedExceptMatchParent",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
      },
      "text-align-last": {
        syntax: "auto | start | end | left | right | center | justify",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
      },
      "text-anchor": {
        syntax: "start | middle | end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "start",
        appliesto: "limitedSVGElementsTextContent",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-anchor"
      },
      "text-combine-upright": {
        syntax: "none | all | [ digits <integer>? ]",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "none",
        appliesto: "nonReplacedInlineElements",
        computed: "keywordPlusIntegerIfDigits",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
      },
      "text-decoration": {
        syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line",
          "text-decoration-thickness"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line"
        ],
        appliesto: "allElements",
        computed: [
          "text-decoration-line",
          "text-decoration-style",
          "text-decoration-color",
          "text-decoration-thickness"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
      },
      "text-decoration-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
      },
      "text-decoration-line": {
        syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
      },
      "text-decoration-skip": {
        syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "objects",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
      },
      "text-decoration-skip-ink": {
        syntax: "auto | all | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
      },
      "text-decoration-style": {
        syntax: "solid | double | dotted | dashed | wavy",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "solid",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
      },
      "text-decoration-thickness": {
        syntax: "auto | from-font | <length> | <percentage> ",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
      },
      "text-emphasis": {
        syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
        media: "visual",
        inherited: true,
        animationType: [
          "text-emphasis-color",
          "text-emphasis-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        appliesto: "allElements",
        computed: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
      },
      "text-emphasis-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
      },
      "text-emphasis-position": {
        syntax: "auto | [ over | under ] && [ right | left ]?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
      },
      "text-emphasis-style": {
        syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
      },
      "text-indent": {
        syntax: "<length-percentage> && hanging? && each-line?",
        media: "visual",
        inherited: true,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Text"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "percentageOrAbsoluteLengthPlusKeywords",
        order: "lengthOrPercentageBeforeKeywords",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
      },
      "text-justify": {
        syntax: "auto | inter-character | inter-word | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
      },
      "text-orientation": {
        syntax: "mixed | upright | sideways",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "mixed",
        appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
      },
      "text-overflow": {
        syntax: "[ clip | ellipsis | <string> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "clip",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
      },
      "text-rendering": {
        syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "auto",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
      },
      "text-shadow": {
        syntax: "none | <shadow-t>#",
        media: "visual",
        inherited: true,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "colorPlusThreeAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
      },
      "text-size-adjust": {
        syntax: "none | auto | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfFont",
        groups: [
          "CSS Text"
        ],
        initial: "autoForSmartphoneBrowsersSupportingInflation",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
      },
      "text-spacing-trim": {
        syntax: "space-all | normal | space-first | trim-start | trim-both | trim-all | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-spacing-trim"
      },
      "text-transform": {
        syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
      },
      "text-underline-offset": {
        syntax: "auto | <length> | <percentage> ",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
      },
      "text-underline-position": {
        syntax: "auto | from-font | [ under || [ left | right ] ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
      },
      "text-wrap": {
        syntax: "<'text-wrap-mode> || <'text-wrap-style'>",
        media: "visual",
        inherited: true,
        animationType: [
          "text-wrap-mode",
          "text-wrap-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "wrap",
        appliesto: "textAndBlockContainers",
        computed: [
          "text-wrap-mode",
          "text-wrap-style"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-wrap"
      },
      "text-wrap-mode": {
        syntax: "auto | wrap | nowrap",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "wrap",
        appliesto: "textAndBlockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-wrap-mode"
      },
      "text-wrap-style": {
        syntax: "auto | balance | stable | pretty",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "textAndBlockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-wrap-style"
      },
      "timeline-scope": {
        syntax: "none | <dashed-ident>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "noneOrOrderedListOfIdentifiers",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/timeline-scope"
      },
      top: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
      },
      "touch-action": {
        syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
      },
      transform: {
        syntax: "none | <transform-list>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
      },
      "transform-box": {
        syntax: "content-box | border-box | fill-box | stroke-box | view-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "view-box",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
      },
      "transform-origin": {
        syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50% 0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
      },
      "transform-style": {
        syntax: "flat | preserve-3d",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "flat",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
      },
      transition: {
        syntax: "<single-transition>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function",
          "transition-behavior"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function",
          "transition-behavior"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
      },
      "transition-behavior": {
        syntax: "<transition-behavior-value>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-behavior"
      },
      "transition-delay": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
      },
      "transition-duration": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
      },
      "transition-property": {
        syntax: "none | <single-transition-property>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "all",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
      },
      "transition-timing-function": {
        syntax: "<easing-function>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
      },
      translate: {
        syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
      },
      "unicode-bidi": {
        syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "normal",
        appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
      },
      "user-select": {
        syntax: "auto | text | none | contain | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
      },
      "vector-effect": {
        syntax: "none | non-scaling-stroke | non-scaling-size | non-rotation | fixed-position",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "none",
        appliesto: "limitedSVGElementsGraphicsAndUse",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vector-effect"
      },
      "vertical-align": {
        syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToLineHeight",
        groups: [
          "CSS Table"
        ],
        initial: "baseline",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "absoluteLengthOrKeyword",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
      },
      "view-timeline": {
        syntax: "[ <'view-timeline-name'> <'view-timeline-axis'>? ]#",
        media: "visual",
        inherited: false,
        animationType: [
          "view-timeline-name",
          "view-timeline-axis"
        ],
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "view-timeline-name",
          "view-timeline-axis"
        ],
        appliesto: "allElements",
        computed: [
          "view-timeline-name",
          "view-timeline-axis"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/view-timeline"
      },
      "view-timeline-axis": {
        syntax: "[ block | inline | x | y ]#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "block",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/view-timeline-axis"
      },
      "view-timeline-inset": {
        syntax: "[ [ auto | <length-percentage> ]{1,2} ]#",
        media: "interactive",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToCorrespondingDimensionOfRelevantScrollport",
        groups: [
          "CSS Animations"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfPairsOfAutoOrLengthPercentage",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/view-timeline-inset"
      },
      "view-timeline-name": {
        syntax: "none | <dashed-ident>#",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "noneOrOrderedListOfIdentifiers",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/view-timeline-name"
      },
      "view-transition-name": {
        syntax: "none | <custom-ident>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS View Transitions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/view-transition-name"
      },
      visibility: {
        syntax: "visible | hidden | collapse",
        media: "visual",
        inherited: true,
        animationType: "visibility",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "visible",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
      },
      "white-space": {
        syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces | [ <'white-space-collapse'> || <'text-wrap'> || <'white-space-trim'> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
      },
      "white-space-collapse": {
        syntax: "collapse | discard | preserve | preserve-breaks | preserve-spaces | break-spaces",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "collapse",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space-collapse"
      },
      widows: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
      },
      width: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAutoOrAbsoluteLength",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
      },
      "will-change": {
        syntax: "auto | <animateable-feature>#",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Will Change"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
      },
      "word-break": {
        syntax: "normal | break-all | keep-all | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
      },
      "word-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToWidthOfAffectedGlyph",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
      },
      "word-wrap": {
        syntax: "normal | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "writing-mode": {
        syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "horizontal-tb",
        appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
      },
      x: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportWidth",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsGeometry",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/x"
      },
      y: {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSVGViewportHeight",
        groups: [
          "Scalable Vector Graphics"
        ],
        initial: "0",
        appliesto: "limitedSVGElementsGeometry",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/y"
      },
      "z-index": {
        syntax: "auto | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
      },
      zoom: {
        syntax: "normal | reset | <number> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
      }
    };
  }
});

// node_modules/mdn-data/css/syntaxes.json
var require_syntaxes = __commonJS({
  "node_modules/mdn-data/css/syntaxes.json"(exports2, module2) {
    module2.exports = {
      "abs()": {
        syntax: "abs( <calc-sum> )"
      },
      "absolute-size": {
        syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
      },
      "acos()": {
        syntax: "acos( <calc-sum> )"
      },
      "alpha-value": {
        syntax: "<number> | <percentage>"
      },
      "angle-percentage": {
        syntax: "<angle> | <percentage>"
      },
      "angular-color-hint": {
        syntax: "<angle-percentage>"
      },
      "angular-color-stop": {
        syntax: "<color> && <color-stop-angle>?"
      },
      "angular-color-stop-list": {
        syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
      },
      "animateable-feature": {
        syntax: "scroll-position | contents | <custom-ident>"
      },
      "asin()": {
        syntax: "asin( <calc-sum> )"
      },
      "atan()": {
        syntax: "atan( <calc-sum> )"
      },
      "atan2()": {
        syntax: "atan2( <calc-sum>, <calc-sum> )"
      },
      attachment: {
        syntax: "scroll | fixed | local"
      },
      "attr()": {
        syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
      },
      "attr-matcher": {
        syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
      },
      "attr-modifier": {
        syntax: "i | s"
      },
      "attribute-selector": {
        syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
      },
      "auto-repeat": {
        syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "auto-track-list": {
        syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
      },
      axis: {
        syntax: "block | inline | x | y"
      },
      "baseline-position": {
        syntax: "[ first | last ]? baseline"
      },
      "basic-shape": {
        syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
      },
      "bg-image": {
        syntax: "none | <image>"
      },
      "bg-layer": {
        syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "bg-position": {
        syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
      },
      "calc-constant": {
        syntax: "e | pi | infinity | -infinity | NaN"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <oklab()> | <oklch()> | <color()> | <hex-color> | <named-color> | <system-color> | <deprecated-system-color> | currentcolor | transparent"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      "color-interpolation-method": {
        syntax: "in [ <rectangular-color-space> | <polar-color-space> <hue-interpolation-method>? ]"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      "cos()": {
        syntax: "cos( <calc-sum> )"
      },
      counter: {
        syntax: "<counter()> | <counters()>"
      },
      "counter()": {
        syntax: "counter( <counter-name>, <counter-style>? )"
      },
      "counter-name": {
        syntax: "<custom-ident>"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <counter-name>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "exp()": {
        syntax: "exp( <calc-sum> )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "hue-interpolation-method": {
        syntax: "[ shorter | longer | increasing | decreasing ] hue"
      },
      "hwb()": {
        syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
      },
      "hypot()": {
        syntax: "hypot( <calc-sum># )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length-percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage> | <timeline-range-name> <percentage>"
      },
      "lab()": {
        syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
      },
      "layer()": {
        syntax: "layer( <layer-name> )"
      },
      "layer-name": {
        syntax: "<ident> [ '.' <ident> ]*"
      },
      "lch()": {
        syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "light-dark()": {
        syntax: "light-dark( <color>, <color> )"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ [ <angle> | to <side-or-corner> ] || <color-interpolation-method> ]? , <color-stop-list> )"
      },
      "log()": {
        syntax: "log( <calc-sum>, <calc-sum>? )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "mod()": {
        syntax: "mod( <calc-sum>, <calc-sum> )"
      },
      "name-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> | auto-fill ], <line-names>+ )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "page-size": {
        syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( [ <length [0,\u221E]> | none ] )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      "polar-color-space": {
        syntax: "hsl | hwb | lch | oklch"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pow()": {
        syntax: "pow( <calc-sum>, <calc-sum> )"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      ratio: {
        syntax: "<number [0,\u221E]> [ / <number [0,\u221E]> ]?"
      },
      "ray()": {
        syntax: "ray( <angle> && <ray-size>? && contain? && [at <position>]? )"
      },
      "ray-size": {
        syntax: "closest-side | closest-corner | farthest-side | farthest-corner | sides"
      },
      "rectangular-color-space": {
        syntax: "srgb | srgb-linear | display-p3 | a98-rgb | prophoto-rgb | rec2020 | lab | oklab | xyz | xyz-d50 | xyz-d65"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "rem()": {
        syntax: "rem( <calc-sum>, <calc-sum> )"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-conic-gradient()": {
        syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "reversed-counter-name": {
        syntax: "reversed( <counter-name> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "round()": {
        syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
      },
      "rounding-strategy": {
        syntax: "nearest | up | down | to-zero"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
      },
      "scale3d()": {
        syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
      },
      "scaleX()": {
        syntax: "scaleX( [ <number> | <percentage> ] )"
      },
      "scaleY()": {
        syntax: "scaleY( [ <number> | <percentage> ] )"
      },
      "scaleZ()": {
        syntax: "scaleZ( [ <number> | <percentage> ] )"
      },
      "scroll()": {
        syntax: "scroll( [ <axis> || <scroller> ]? )"
      },
      scroller: {
        syntax: "root | nearest | self"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "sign()": {
        syntax: "sign( <calc-sum> )"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "sin()": {
        syntax: "sin( <calc-sum> )"
      },
      "single-animation": {
        syntax: "<'animation-duration'> || <easing-function> || <'animation-delay'> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ] || <single-animation-timeline>"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-animation-timeline": {
        syntax: "auto | none | <dashed-ident> | <scroll()> | <view()>"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time> || <transition-behavior-value>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "sqrt()": {
        syntax: "sqrt( <calc-sum> )"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      "system-color": {
        syntax: "AccentColor | AccentColorText | ActiveText | ButtonBorder | ButtonFace | ButtonText | Canvas | CanvasText | Field | FieldText | GrayText | Highlight | HighlightText | LinkText | Mark | MarkText | SelectedItem | SelectedItemText | VisitedText"
      },
      "tan()": {
        syntax: "tan( <calc-sum> )"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timeline-range-name": {
        syntax: "cover | contain | entry | exit | entry-crossing | exit-crossing"
      },
      "easing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "transition-behavior-value": {
        syntax: "normal | allow-discrete"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "view()": {
        syntax: "view([<axis> || <'view-timeline-inset'>]?)"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "visual-box": {
        syntax: "content-box | padding-box | border-box"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/css-tree/cjs/data.cjs
var require_data = __commonJS({
  "node_modules/css-tree/cjs/data.cjs"(exports2, module2) {
    "use strict";
    var dataPatch = require_data_patch();
    var mdnAtrules = require_at_rules();
    var mdnProperties = require_properties();
    var mdnSyntaxes = require_syntaxes();
    var hasOwn = Object.hasOwn || ((object, property) => Object.prototype.hasOwnProperty.call(object, property));
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const [atruleName, atrule] of Object.entries(dict)) {
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const [name, descriptor] of Object.entries(atrule.descriptors)) {
            descriptors[name] = descriptor.syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(dict)) {
        if (value) {
          result[key] = value.syntax || value;
        }
      }
      for (const key of Object.keys(patchDict)) {
        if (hasOwn(dict, key)) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function preprocessPatchAtrulesDescritors(declarations) {
      const result = {};
      for (const [key, value] of Object.entries(declarations || {})) {
        result[key] = typeof value === "string" ? { syntax: value } : value;
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        if (patchDict[key] === null) {
          continue;
        }
        const atrulePatch = patchDict[key] || {};
        result[key] = {
          prelude: key in patchDict && "prelude" in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
          descriptors: patchDictionary(
            dict[key].descriptors || {},
            preprocessPatchAtrulesDescritors(atrulePatch.descriptors)
          )
        };
      }
      for (const [key, atrulePatch] of Object.entries(patchDict)) {
        if (atrulePatch && !hasOwn(dict, key)) {
          result[key] = {
            prelude: atrulePatch.prelude || null,
            descriptors: atrulePatch.descriptors ? patchDictionary({}, preprocessPatchAtrulesDescritors(atrulePatch.descriptors)) : null
          };
        }
      }
      return result;
    }
    var definitions = {
      types: patchDictionary(mdnSyntaxes, dataPatch.types),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
      properties: patchDictionary(mdnProperties, dataPatch.properties)
    };
    module2.exports = definitions;
  }
});

// node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var charCodeDefinitions = require_char_code_definitions();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      let pos = this.tokenStart + offset;
      const code = this.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.tokenEnd; pos++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = "";
        switch (code) {
          case N:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.tokenStart + offset);
      }
    }
    function consumeB() {
      let offset = 0;
      let sign = 0;
      let type = this.tokenType;
      while (type === types.WhiteSpace || type === types.Comment) {
        type = this.lookupType(++offset);
      }
      if (type !== types.Number) {
        if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
          sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.lookupType(++offset);
          } while (type === types.WhiteSpace || type === types.Comment);
          if (type !== types.Number) {
            this.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.skip(offset);
      }
      if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
    }
    var name = "AnPlusB";
    var structure = {
      a: [String, null],
      b: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let a = null;
      let b = null;
      if (this.tokenType === types.Number) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(types.Number);
      } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
        a = "-1";
        expectCharCode.call(this, 1, N);
        switch (this.tokenEnd - this.tokenStart) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            this.next();
            b = consumeB.call(this);
            break;
          // -n- <signless-integer>
          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // <dashndashdigit-ident>
          default:
            expectCharCode.call(this, 2, HYPHENMINUS);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + 2);
        }
      } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
        let sign = 0;
        a = "1";
        if (this.isDelim(PLUSSIGN)) {
          sign = 1;
          this.next();
        }
        expectCharCode.call(this, 0, N);
        switch (this.tokenEnd - this.tokenStart) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            this.next();
            b = consumeB.call(this);
            break;
          // '+'? n- <signless-integer>
          case 2:
            expectCharCode.call(this, 1, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // '+'? <ndashdigit-ident>
          default:
            expectCharCode.call(this, 1, HYPHENMINUS);
            checkInteger.call(this, 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + sign + 1);
        }
      } else if (this.tokenType === types.Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN || code === HYPHENMINUS;
        let i = this.tokenStart + sign;
        for (; i < this.tokenEnd; i++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
            break;
          }
        }
        if (i === this.tokenStart + sign) {
          this.error("Integer is expected", this.tokenStart + sign);
        }
        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);
        if (i + 1 === this.tokenEnd) {
          this.next();
          b = consumeB.call(this);
        } else {
          expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
          if (i + 2 === this.tokenEnd) {
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
          } else {
            checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(i + 1);
          }
        }
      } else {
        this.error();
      }
      if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
        a = a.substr(1);
      }
      if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
        b = b.substr(1);
      }
      return {
        type: "AnPlusB",
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
      };
    }
    function generate(node) {
      if (node.a) {
        const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
        if (node.b) {
          const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
          this.tokenize(a + b);
        } else {
          this.tokenize(a);
        }
      } else {
        this.tokenize(node.b);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Atrule.cjs"(exports2) {
    "use strict";
    var types = require_types();
    function consumeRaw() {
      return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === types.RightCurlyBracket) {
          return true;
        }
        if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
          return false;
        }
      }
      return false;
    }
    var name = "Atrule";
    var walkContext = "atrule";
    var structure = {
      name: String,
      prelude: ["AtrulePrelude", "Raw", null],
      block: ["Block", null]
    };
    function parse(isDeclaration = false) {
      const start = this.tokenStart;
      let name2;
      let nameLowerCase;
      let prelude = null;
      let block = null;
      this.eat(types.AtKeyword);
      name2 = this.substrToCursor(start + 1);
      nameLowerCase = name2.toLowerCase();
      this.skipSC();
      if (this.eof === false && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        if (this.parseAtrulePrelude) {
          prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw);
        } else {
          prelude = consumeRaw.call(this, this.tokenIndex);
        }
        this.skipSC();
      }
      switch (this.tokenType) {
        case types.Semicolon:
          this.next();
          break;
        case types.LeftCurlyBracket:
          if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
            block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
          } else {
            block = this.Block(isDeclarationBlockAtrule.call(this));
          }
          break;
      }
      return {
        type: "Atrule",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        prelude,
        block
      };
    }
    function generate(node) {
      this.token(types.AtKeyword, "@" + node.name);
      if (node.prelude !== null) {
        this.node(node.prelude);
      }
      if (node.block) {
        this.node(node.block);
      } else {
        this.token(types.Semicolon, ";");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs
var require_AtrulePrelude = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "AtrulePrelude";
    var walkContext = "atrulePrelude";
    var structure = {
      children: [[]]
    };
    function parse(name2) {
      let children = null;
      if (name2 !== null) {
        name2 = name2.toLowerCase();
      }
      this.skipSC();
      if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
        children = this.atrule[name2].prelude.call(this);
      } else {
        children = this.readSequence(this.scope.AtrulePrelude);
      }
      this.skipSC();
      if (this.eof !== true && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        this.error("Semicolon or block is expected");
      }
      return {
        type: "AtrulePrelude",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs
var require_AttributeSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var DOLLARSIGN = 36;
    var ASTERISK = 42;
    var EQUALSSIGN = 61;
    var CIRCUMFLEXACCENT = 94;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getAttributeName() {
      if (this.eof) {
        this.error("Unexpected end of input");
      }
      const start = this.tokenStart;
      let expectIdent = false;
      if (this.isDelim(ASTERISK)) {
        expectIdent = true;
        this.next();
      } else if (!this.isDelim(VERTICALLINE)) {
        this.eat(types.Ident);
      }
      if (this.isDelim(VERTICALLINE)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
          this.next();
          this.eat(types.Ident);
        } else if (expectIdent) {
          this.error("Identifier is expected", this.tokenEnd);
        }
      } else if (expectIdent) {
        this.error("Vertical line is expected");
      }
      return {
        type: "Identifier",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function getOperator() {
      const start = this.tokenStart;
      const code = this.charCodeAt(start);
      if (code !== EQUALSSIGN && // =
      code !== TILDE && // ~=
      code !== CIRCUMFLEXACCENT && // ^=
      code !== DOLLARSIGN && // $=
      code !== ASTERISK && // *=
      code !== VERTICALLINE) {
        this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
      }
      this.next();
      if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
          this.error("Equal sign is expected");
        }
        this.next();
      }
      return this.substrToCursor(start);
    }
    var name = "AttributeSelector";
    var structure = {
      name: "Identifier",
      matcher: [String, null],
      value: ["String", "Identifier", null],
      flags: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let matcher = null;
      let value = null;
      let flags = null;
      this.eat(types.LeftSquareBracket);
      this.skipSC();
      name2 = getAttributeName.call(this);
      this.skipSC();
      if (this.tokenType !== types.RightSquareBracket) {
        if (this.tokenType !== types.Ident) {
          matcher = getOperator.call(this);
          this.skipSC();
          value = this.tokenType === types.String ? this.String() : this.Identifier();
          this.skipSC();
        }
        if (this.tokenType === types.Ident) {
          flags = this.consume(types.Ident);
          this.skipSC();
        }
      }
      this.eat(types.RightSquareBracket);
      return {
        type: "AttributeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        matcher,
        value,
        flags
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.node(node.name);
      if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
      }
      if (node.flags !== null) {
        this.token(types.Ident, node.flags);
      }
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Block.cjs
var require_Block = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Block.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var AMPERSAND = 38;
    function consumeRaw() {
      return this.Raw(null, true);
    }
    function consumeRule() {
      return this.parseWithFallback(this.Rule, consumeRaw);
    }
    function consumeRawDeclaration() {
      return this.Raw(this.consumeUntilSemicolonIncluded, true);
    }
    function consumeDeclaration() {
      if (this.tokenType === types.Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
      }
      const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
      if (this.tokenType === types.Semicolon) {
        this.next();
      }
      return node;
    }
    var name = "Block";
    var walkContext = "block";
    var structure = {
      children: [[
        "Atrule",
        "Rule",
        "Declaration"
      ]]
    };
    function parse(isStyleBlock) {
      const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
      const start = this.tokenStart;
      let children = this.createList();
      this.eat(types.LeftCurlyBracket);
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.RightCurlyBracket:
              break scan;
            case types.WhiteSpace:
            case types.Comment:
              this.next();
              break;
            case types.AtKeyword:
              children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));
              break;
            default:
              if (isStyleBlock && this.isDelim(AMPERSAND)) {
                children.push(consumeRule.call(this));
              } else {
                children.push(consumer.call(this));
              }
          }
        }
      if (!this.eof) {
        this.eat(types.RightCurlyBracket);
      }
      return {
        type: "Block",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftCurlyBracket, "{");
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
      this.token(types.RightCurlyBracket, "}");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Brackets.cjs
var require_Brackets = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Brackets.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Brackets";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftSquareBracket);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightSquareBracket);
      }
      return {
        type: "Brackets",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.children(node);
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/CDC.cjs
var require_CDC = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/CDC.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "CDC";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDC);
      return {
        type: "CDC",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDC, "-->");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/CDO.cjs
var require_CDO = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/CDO.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "CDO";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDO);
      return {
        type: "CDO",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDO, "<!--");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs
var require_ClassSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var FULLSTOP = 46;
    var name = "ClassSelector";
    var structure = {
      name: String
    };
    function parse() {
      this.eatDelim(FULLSTOP);
      return {
        type: "ClassSelector",
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Delim, ".");
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Combinator.cjs
var require_Combinator = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Combinator.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var GREATERTHANSIGN = 62;
    var TILDE = 126;
    var name = "Combinator";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      switch (this.tokenType) {
        case types.WhiteSpace:
          name2 = " ";
          break;
        case types.Delim:
          switch (this.charCodeAt(this.tokenStart)) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
              this.next();
              break;
            case SOLIDUS:
              this.next();
              this.eatIdent("deep");
              this.eatDelim(SOLIDUS);
              break;
            default:
              this.error("Combinator is expected");
          }
          name2 = this.substrToCursor(start);
          break;
      }
      return {
        type: "Combinator",
        loc: this.getLocation(start, this.tokenStart),
        name: name2
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Comment.cjs
var require_Comment = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Comment.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var ASTERISK = 42;
    var SOLIDUS = 47;
    var name = "Comment";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let end = this.tokenEnd;
      this.eat(types.Comment);
      if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK && this.charCodeAt(end - 1) === SOLIDUS) {
        end -= 2;
      }
      return {
        type: "Comment",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
      };
    }
    function generate(node) {
      this.token(types.Comment, "/*" + node.value + "*/");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Condition.cjs
var require_Condition = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Condition.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var likelyFeatureToken = /* @__PURE__ */ new Set([types.Colon, types.RightParenthesis, types.EOF]);
    var name = "Condition";
    var structure = {
      kind: String,
      children: [[
        "Identifier",
        "Feature",
        "FeatureFunction",
        "FeatureRange",
        "SupportsDeclaration"
      ]]
    };
    function featureOrRange(kind) {
      if (this.lookupTypeNonSC(1) === types.Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
        return this.Feature(kind);
      }
      return this.FeatureRange(kind);
    }
    var parentheses = {
      media: featureOrRange,
      container: featureOrRange,
      supports() {
        return this.SupportsDeclaration();
      }
    };
    function parse(kind = "media") {
      const children = this.createList();
      scan: while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Ident:
            children.push(this.Identifier());
            break;
          case types.LeftParenthesis: {
            let term = this.parseWithFallback(
              () => parentheses[kind].call(this, kind),
              () => null
            );
            if (!term) {
              term = this.parseWithFallback(
                () => {
                  this.eat(types.LeftParenthesis);
                  const res = this.Condition(kind);
                  this.eat(types.RightParenthesis);
                  return res;
                },
                () => {
                  return this.GeneralEnclosed(kind);
                }
              );
            }
            children.push(term);
            break;
          }
          case types.Function: {
            let term = this.parseWithFallback(
              () => this.FeatureFunction(kind),
              () => null
            );
            if (!term) {
              term = this.GeneralEnclosed(kind);
            }
            children.push(term);
            break;
          }
          default:
            break scan;
        }
      }
      if (children.isEmpty) {
        this.error("Condition is expected");
      }
      return {
        type: "Condition",
        loc: this.getLocationFromList(children),
        kind,
        children
      };
    }
    function generate(node) {
      node.children.forEach((child) => {
        if (child.type === "Condition") {
          this.token(types.LeftParenthesis, "(");
          this.node(child);
          this.token(types.RightParenthesis, ")");
        } else {
          this.node(child);
        }
      });
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Declaration.cjs
var require_Declaration = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Declaration.cjs"(exports2) {
    "use strict";
    var names = require_names2();
    var types = require_types();
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var DOLLARSIGN = 36;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    function consumeValueRaw() {
      return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw() {
      return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
      const startValueToken = this.tokenIndex;
      const value = this.Value();
      if (value.type !== "Raw" && this.eof === false && this.tokenType !== types.Semicolon && this.isDelim(EXCLAMATIONMARK) === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value;
    }
    var name = "Declaration";
    var walkContext = "declaration";
    var structure = {
      important: [Boolean, String],
      property: String,
      value: ["Value", "Raw"]
    };
    function parse() {
      const start = this.tokenStart;
      const startToken = this.tokenIndex;
      const property = readProperty.call(this);
      const customProperty = names.isCustomProperty(property);
      const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
      const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
      let important = false;
      let value;
      this.skipSC();
      this.eat(types.Colon);
      const valueStart = this.tokenIndex;
      if (!customProperty) {
        this.skipSC();
      }
      if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
      } else {
        value = consumeRaw.call(this, this.tokenIndex);
      }
      if (customProperty && value.type === "Value" && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === types.WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      if (this.isDelim(EXCLAMATIONMARK)) {
        important = getImportant.call(this);
        this.skipSC();
      }
      if (this.eof === false && this.tokenType !== types.Semicolon && this.isBalanceEdge(startToken) === false) {
        this.error();
      }
      return {
        type: "Declaration",
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
      };
    }
    function generate(node) {
      this.token(types.Ident, node.property);
      this.token(types.Colon, ":");
      this.node(node.value);
      if (node.important) {
        this.token(types.Delim, "!");
        this.token(types.Ident, node.important === true ? "important" : node.important);
      }
    }
    function readProperty() {
      const start = this.tokenStart;
      if (this.tokenType === types.Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
          case ASTERISK:
          case DOLLARSIGN:
          case PLUSSIGN:
          case NUMBERSIGN:
          case AMPERSAND:
            this.next();
            break;
          // TODO: not sure we should support this hack
          case SOLIDUS:
            this.next();
            if (this.isDelim(SOLIDUS)) {
              this.next();
            }
            break;
        }
      }
      if (this.tokenType === types.Hash) {
        this.eat(types.Hash);
      } else {
        this.eat(types.Ident);
      }
      return this.substrToCursor(start);
    }
    function getImportant() {
      this.eat(types.Delim);
      this.skipSC();
      const important = this.consume(types.Ident);
      return important === "important" ? true : important;
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs
var require_DeclarationList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var AMPERSAND = 38;
    function consumeRaw() {
      return this.Raw(this.consumeUntilSemicolonIncluded, true);
    }
    var name = "DeclarationList";
    var structure = {
      children: [[
        "Declaration",
        "Atrule",
        "Rule"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
          case types.Comment:
          case types.Semicolon:
            this.next();
            break;
          case types.AtKeyword:
            children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));
            break;
          default:
            if (this.isDelim(AMPERSAND)) {
              children.push(this.parseWithFallback(this.Rule, consumeRaw));
            } else {
              children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }
      }
      return {
        type: "DeclarationList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Dimension.cjs
var require_Dimension = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Dimension.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Dimension";
    var structure = {
      value: String,
      unit: String
    };
    function parse() {
      const start = this.tokenStart;
      const value = this.consumeNumber(types.Dimension);
      return {
        type: "Dimension",
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
      };
    }
    function generate(node) {
      this.token(types.Dimension, node.value + node.unit);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Feature.cjs
var require_Feature = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Feature.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var SOLIDUS = 47;
    var name = "Feature";
    var structure = {
      kind: String,
      name: String,
      value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
    };
    function parse(kind) {
      const start = this.tokenStart;
      let name2;
      let value = null;
      this.eat(types.LeftParenthesis);
      this.skipSC();
      name2 = this.consume(types.Ident);
      this.skipSC();
      if (this.tokenType !== types.RightParenthesis) {
        this.eat(types.Colon);
        this.skipSC();
        switch (this.tokenType) {
          case types.Number:
            if (this.lookupNonWSType(1) === types.Delim) {
              value = this.Ratio();
            } else {
              value = this.Number();
            }
            break;
          case types.Dimension:
            value = this.Dimension();
            break;
          case types.Ident:
            value = this.Identifier();
            break;
          case types.Function:
            value = this.parseWithFallback(
              () => {
                const res = this.Function(this.readSequence, this.scope.Value);
                this.skipSC();
                if (this.isDelim(SOLIDUS)) {
                  this.error();
                }
                return res;
              },
              () => {
                return this.Ratio();
              }
            );
            break;
          default:
            this.error("Number, dimension, ratio or identifier is expected");
        }
        this.skipSC();
      }
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Feature",
        loc: this.getLocation(start, this.tokenStart),
        kind,
        name: name2,
        value
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.token(types.Ident, node.name);
      if (node.value !== null) {
        this.token(types.Colon, ":");
        this.node(node.value);
      }
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/FeatureFunction.cjs
var require_FeatureFunction = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/FeatureFunction.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "FeatureFunction";
    var structure = {
      kind: String,
      feature: String,
      value: ["Declaration", "Selector"]
    };
    function getFeatureParser(kind, name2) {
      const featuresOfKind = this.features[kind] || {};
      const parser = featuresOfKind[name2];
      if (typeof parser !== "function") {
        this.error(`Unknown feature ${name2}()`);
      }
      return parser;
    }
    function parse(kind = "unknown") {
      const start = this.tokenStart;
      const functionName = this.consumeFunctionName();
      const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
      this.skipSC();
      const value = this.parseWithFallback(
        () => {
          const startValueToken = this.tokenIndex;
          const value2 = valueParser.call(this);
          if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
            this.error();
          }
          return value2;
        },
        () => this.Raw(null, false)
      );
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "FeatureFunction",
        loc: this.getLocation(start, this.tokenStart),
        kind,
        feature: functionName,
        value
      };
    }
    function generate(node) {
      this.token(types.Function, node.feature + "(");
      this.node(node.value);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/FeatureRange.cjs
var require_FeatureRange = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/FeatureRange.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var SOLIDUS = 47;
    var LESSTHANSIGN = 60;
    var EQUALSSIGN = 61;
    var GREATERTHANSIGN = 62;
    var name = "FeatureRange";
    var structure = {
      kind: String,
      left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
      leftComparison: String,
      middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
      rightComparison: [String, null],
      right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
    };
    function readTerm() {
      this.skipSC();
      switch (this.tokenType) {
        case types.Number:
          if (this.isDelim(SOLIDUS, this.lookupOffsetNonSC(1))) {
            return this.Ratio();
          } else {
            return this.Number();
          }
        case types.Dimension:
          return this.Dimension();
        case types.Ident:
          return this.Identifier();
        case types.Function:
          return this.parseWithFallback(
            () => {
              const res = this.Function(this.readSequence, this.scope.Value);
              this.skipSC();
              if (this.isDelim(SOLIDUS)) {
                this.error();
              }
              return res;
            },
            () => {
              return this.Ratio();
            }
          );
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
    }
    function readComparison(expectColon) {
      this.skipSC();
      if (this.isDelim(LESSTHANSIGN) || this.isDelim(GREATERTHANSIGN)) {
        const value = this.source[this.tokenStart];
        this.next();
        if (this.isDelim(EQUALSSIGN)) {
          this.next();
          return value + "=";
        }
        return value;
      }
      if (this.isDelim(EQUALSSIGN)) {
        return "=";
      }
      this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
    }
    function parse(kind = "unknown") {
      const start = this.tokenStart;
      this.skipSC();
      this.eat(types.LeftParenthesis);
      const left = readTerm.call(this);
      const leftComparison = readComparison.call(this, left.type === "Identifier");
      const middle = readTerm.call(this);
      let rightComparison = null;
      let right = null;
      if (this.lookupNonWSType(0) !== types.RightParenthesis) {
        rightComparison = readComparison.call(this);
        right = readTerm.call(this);
      }
      this.skipSC();
      this.eat(types.RightParenthesis);
      return {
        type: "FeatureRange",
        loc: this.getLocation(start, this.tokenStart),
        kind,
        left,
        leftComparison,
        middle,
        rightComparison,
        right
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.node(node.left);
      this.tokenize(node.leftComparison);
      this.node(node.middle);
      if (node.right) {
        this.tokenize(node.rightComparison);
        this.node(node.right);
      }
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Function.cjs
var require_Function = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Function.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Function";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      const name2 = this.consumeFunctionName();
      const nameLowerCase = name2.toLowerCase();
      let children;
      children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Function",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/GeneralEnclosed.cjs
var require_GeneralEnclosed = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/GeneralEnclosed.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "GeneralEnclosed";
    var structure = {
      kind: String,
      function: [String, null],
      children: [[]]
    };
    function parse(kind) {
      const start = this.tokenStart;
      let functionName = null;
      if (this.tokenType === types.Function) {
        functionName = this.consumeFunctionName();
      } else {
        this.eat(types.LeftParenthesis);
      }
      const children = this.parseWithFallback(
        () => {
          const startValueToken = this.tokenIndex;
          const children2 = this.readSequence(this.scope.Value);
          if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
            this.error();
          }
          return children2;
        },
        () => this.createSingleNodeList(
          this.Raw(null, false)
        )
      );
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "GeneralEnclosed",
        loc: this.getLocation(start, this.tokenStart),
        kind,
        function: functionName,
        children
      };
    }
    function generate(node) {
      if (node.function) {
        this.token(types.Function, node.function + "(");
      } else {
        this.token(types.LeftParenthesis, "(");
      }
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Hash.cjs
var require_Hash = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Hash.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var xxx = "XXX";
    var name = "Hash";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "Hash",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Hash, "#" + node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.xxx = xxx;
  }
});

// node_modules/css-tree/cjs/syntax/node/Identifier.cjs
var require_Identifier = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Identifier.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Identifier";
    var structure = {
      name: String
    };
    function parse() {
      return {
        type: "Identifier",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/IdSelector.cjs
var require_IdSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/IdSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "IdSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "IdSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Delim, "#" + node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Layer.cjs
var require_Layer = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Layer.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var FULLSTOP = 46;
    var name = "Layer";
    var structure = {
      name: String
    };
    function parse() {
      let tokenStart = this.tokenStart;
      let name2 = this.consume(types.Ident);
      while (this.isDelim(FULLSTOP)) {
        this.eat(types.Delim);
        name2 += "." + this.consume(types.Ident);
      }
      return {
        type: "Layer",
        loc: this.getLocation(tokenStart, this.tokenStart),
        name: name2
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/LayerList.cjs
var require_LayerList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/LayerList.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "LayerList";
    var structure = {
      children: [[
        "Layer"
      ]]
    };
    function parse() {
      const children = this.createList();
      this.skipSC();
      while (!this.eof) {
        children.push(this.Layer());
        if (this.lookupTypeNonSC(0) !== types.Comma) {
          break;
        }
        this.skipSC();
        this.next();
        this.skipSC();
      }
      return {
        type: "LayerList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs
var require_MediaQuery = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "MediaQuery";
    var structure = {
      modifier: [String, null],
      mediaType: [String, null],
      condition: ["Condition", null]
    };
    function parse() {
      const start = this.tokenStart;
      let modifier = null;
      let mediaType = null;
      let condition = null;
      this.skipSC();
      if (this.tokenType === types.Ident && this.lookupTypeNonSC(1) !== types.LeftParenthesis) {
        const ident = this.consume(types.Ident);
        const identLowerCase = ident.toLowerCase();
        if (identLowerCase === "not" || identLowerCase === "only") {
          this.skipSC();
          modifier = identLowerCase;
          mediaType = this.consume(types.Ident);
        } else {
          mediaType = ident;
        }
        switch (this.lookupTypeNonSC(0)) {
          case types.Ident: {
            this.skipSC();
            this.eatIdent("and");
            condition = this.Condition("media");
            break;
          }
          case types.LeftCurlyBracket:
          case types.Semicolon:
          case types.Comma:
          case types.EOF:
            break;
          default:
            this.error("Identifier or parenthesis is expected");
        }
      } else {
        switch (this.tokenType) {
          case types.Ident:
          case types.LeftParenthesis:
          case types.Function: {
            condition = this.Condition("media");
            break;
          }
          case types.LeftCurlyBracket:
          case types.Semicolon:
          case types.EOF:
            break;
          default:
            this.error("Identifier or parenthesis is expected");
        }
      }
      return {
        type: "MediaQuery",
        loc: this.getLocation(start, this.tokenStart),
        modifier,
        mediaType,
        condition
      };
    }
    function generate(node) {
      if (node.mediaType) {
        if (node.modifier) {
          this.token(types.Ident, node.modifier);
        }
        this.token(types.Ident, node.mediaType);
        if (node.condition) {
          this.token(types.Ident, "and");
          this.node(node.condition);
        }
      } else if (node.condition) {
        this.node(node.condition);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs
var require_MediaQueryList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "MediaQueryList";
    var structure = {
      children: [[
        "MediaQuery"
      ]]
    };
    function parse() {
      const children = this.createList();
      this.skipSC();
      while (!this.eof) {
        children.push(this.MediaQuery());
        if (this.tokenType !== types.Comma) {
          break;
        }
        this.next();
      }
      return {
        type: "MediaQueryList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs
var require_NestingSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var AMPERSAND = 38;
    var name = "NestingSelector";
    var structure = {};
    function parse() {
      const start = this.tokenStart;
      this.eatDelim(AMPERSAND);
      return {
        type: "NestingSelector",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.Delim, "&");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Nth.cjs
var require_Nth = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Nth.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Nth";
    var structure = {
      nth: ["AnPlusB", "Identifier"],
      selector: ["SelectorList", null]
    };
    function parse() {
      this.skipSC();
      const start = this.tokenStart;
      let end = start;
      let selector = null;
      let nth;
      if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
        nth = this.Identifier();
      } else {
        nth = this.AnPlusB();
      }
      end = this.tokenStart;
      this.skipSC();
      if (this.lookupValue(0, "of")) {
        this.next();
        selector = this.SelectorList();
        end = this.tokenStart;
      }
      return {
        type: "Nth",
        loc: this.getLocation(start, end),
        nth,
        selector
      };
    }
    function generate(node) {
      this.node(node.nth);
      if (node.selector !== null) {
        this.token(types.Ident, "of");
        this.node(node.selector);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Number.cjs
var require_Number = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Number.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Number";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Number",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(types.Number)
      };
    }
    function generate(node) {
      this.token(types.Number, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Operator.cjs
var require_Operator = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Operator.cjs"(exports2) {
    "use strict";
    var name = "Operator";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.next();
      return {
        type: "Operator",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Parentheses.cjs
var require_Parentheses = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Parentheses.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Parentheses";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftParenthesis);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Parentheses",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Percentage.cjs
var require_Percentage = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Percentage.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Percentage";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Percentage",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(types.Percentage)
      };
    }
    function generate(node) {
      this.token(types.Percentage, node.value + "%");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs
var require_PseudoClassSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "PseudoClassSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (this.lookupNonWSType(0) == types.RightParenthesis) {
          children = this.createList();
        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoClassSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs
var require_PseudoElementSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "PseudoElementSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (this.lookupNonWSType(0) == types.RightParenthesis) {
          children = this.createList();
        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoElementSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Ratio.cjs
var require_Ratio = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Ratio.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var SOLIDUS = 47;
    function consumeTerm() {
      this.skipSC();
      switch (this.tokenType) {
        case types.Number:
          return this.Number();
        case types.Function:
          return this.Function(this.readSequence, this.scope.Value);
        default:
          this.error("Number of function is expected");
      }
    }
    var name = "Ratio";
    var structure = {
      left: ["Number", "Function"],
      right: ["Number", "Function", null]
    };
    function parse() {
      const start = this.tokenStart;
      const left = consumeTerm.call(this);
      let right = null;
      this.skipSC();
      if (this.isDelim(SOLIDUS)) {
        this.eatDelim(SOLIDUS);
        right = consumeTerm.call(this);
      }
      return {
        type: "Ratio",
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
      };
    }
    function generate(node) {
      this.node(node.left);
      this.token(types.Delim, "/");
      if (node.right) {
        this.node(node.right);
      } else {
        this.node(types.Number, 1);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Raw.cjs
var require_Raw = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Raw.cjs"(exports2) {
    "use strict";
    var types = require_types();
    function getOffsetExcludeWS() {
      if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === types.WhiteSpace) {
          return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
        }
      }
      return this.tokenStart;
    }
    var name = "Raw";
    var structure = {
      value: String
    };
    function parse(consumeUntil, excludeWhiteSpace) {
      const startOffset = this.getTokenStart(this.tokenIndex);
      let endOffset;
      this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
      if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
      } else {
        endOffset = this.tokenStart;
      }
      return {
        type: "Raw",
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Rule.cjs
var require_Rule = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Rule.cjs"(exports2) {
    "use strict";
    var types = require_types();
    function consumeRaw() {
      return this.Raw(this.consumeUntilLeftCurlyBracket, true);
    }
    function consumePrelude() {
      const prelude = this.SelectorList();
      if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== types.LeftCurlyBracket) {
        this.error();
      }
      return prelude;
    }
    var name = "Rule";
    var walkContext = "rule";
    var structure = {
      prelude: ["SelectorList", "Raw"],
      block: ["Block"]
    };
    function parse() {
      const startToken = this.tokenIndex;
      const startOffset = this.tokenStart;
      let prelude;
      let block;
      if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw);
      } else {
        prelude = consumeRaw.call(this, startToken);
      }
      block = this.Block(true);
      return {
        type: "Rule",
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
      };
    }
    function generate(node) {
      this.node(node.prelude);
      this.node(node.block);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Scope.cjs
var require_Scope = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Scope.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "Scope";
    var structure = {
      root: ["SelectorList", "Raw", null],
      limit: ["SelectorList", "Raw", null]
    };
    function parse() {
      let root = null;
      let limit = null;
      this.skipSC();
      const startOffset = this.tokenStart;
      if (this.tokenType === types.LeftParenthesis) {
        this.next();
        this.skipSC();
        root = this.parseWithFallback(
          this.SelectorList,
          () => this.Raw(false, true)
        );
        this.skipSC();
        this.eat(types.RightParenthesis);
      }
      if (this.lookupNonWSType(0) === types.Ident) {
        this.skipSC();
        this.eatIdent("to");
        this.skipSC();
        this.eat(types.LeftParenthesis);
        this.skipSC();
        limit = this.parseWithFallback(
          this.SelectorList,
          () => this.Raw(false, true)
        );
        this.skipSC();
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Scope",
        loc: this.getLocation(startOffset, this.tokenStart),
        root,
        limit
      };
    }
    function generate(node) {
      if (node.root) {
        this.token(types.LeftParenthesis, "(");
        this.node(node.root);
        this.token(types.RightParenthesis, ")");
      }
      if (node.limit) {
        this.token(types.Ident, "to");
        this.token(types.LeftParenthesis, "(");
        this.node(node.limit);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Selector.cjs
var require_Selector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Selector.cjs"(exports2) {
    "use strict";
    var name = "Selector";
    var structure = {
      children: [[
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator"
      ]]
    };
    function parse() {
      const children = this.readSequence(this.scope.Selector);
      if (this.getFirstListNode(children) === null) {
        this.error("Selector is expected");
      }
      return {
        type: "Selector",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/SelectorList.cjs
var require_SelectorList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/SelectorList.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "SelectorList";
    var walkContext = "selector";
    var structure = {
      children: [[
        "Selector",
        "Raw"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        children.push(this.Selector());
        if (this.tokenType === types.Comma) {
          this.next();
          continue;
        }
        break;
      }
      return {
        type: "SelectorList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/utils/string.cjs
var require_string = __commonJS({
  "node_modules/css-tree/cjs/utils/string.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    function decode(str) {
      const len = str.length;
      const firstChar = str.charCodeAt(0);
      const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
      const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
      let decoded = "";
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str, apostrophe) {
      const quote = apostrophe ? "'" : '"';
      const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === quoteCode || code === REVERSE_SOLIDUS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return quote + encoded + quote;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/syntax/node/String.cjs
var require_String = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/String.cjs"(exports2) {
    "use strict";
    var string = require_string();
    var types = require_types();
    var name = "String";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "String",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: string.decode(this.consume(types.String))
      };
    }
    function generate(node) {
      this.token(types.String, string.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs
var require_StyleSheet = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var EXCLAMATIONMARK = 33;
    function consumeRaw() {
      return this.Raw(null, false);
    }
    var name = "StyleSheet";
    var walkContext = "stylesheet";
    var structure = {
      children: [[
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.createList();
      let child;
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Comment:
            if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
              this.next();
              continue;
            }
            child = this.Comment();
            break;
          case types.CDO:
            child = this.CDO();
            break;
          case types.CDC:
            child = this.CDC();
            break;
          // CSS Syntax Module Level 3
          // 2.2 Error handling
          // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
          case types.AtKeyword:
            child = this.parseWithFallback(this.Atrule, consumeRaw);
            break;
          // Anything else starts a qualified rule ...
          default:
            child = this.parseWithFallback(this.Rule, consumeRaw);
        }
        children.push(child);
      }
      return {
        type: "StyleSheet",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/SupportsDeclaration.cjs
var require_SupportsDeclaration = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/SupportsDeclaration.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var name = "SupportsDeclaration";
    var structure = {
      declaration: "Declaration"
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.LeftParenthesis);
      this.skipSC();
      const declaration = this.Declaration();
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "SupportsDeclaration",
        loc: this.getLocation(start, this.tokenStart),
        declaration
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.node(node.declaration);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs
var require_TypeSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var ASTERISK = 42;
    var VERTICALLINE = 124;
    function eatIdentifierOrAsterisk() {
      if (this.tokenType !== types.Ident && this.isDelim(ASTERISK) === false) {
        this.error("Identifier or asterisk is expected");
      }
      this.next();
    }
    var name = "TypeSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      if (this.isDelim(VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      } else {
        eatIdentifierOrAsterisk.call(this);
        if (this.isDelim(VERTICALLINE)) {
          this.next();
          eatIdentifierOrAsterisk.call(this);
        }
      }
      return {
        type: "TypeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs
var require_UnicodeRange = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var charCodeDefinitions = require_char_code_definitions();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    function eatHexSequence(offset, allowDash) {
      let len = 0;
      for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && len !== 0) {
          eatHexSequence.call(this, offset + len + 1, false);
          return -1;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          this.error(
            allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
            pos
          );
        }
        if (++len > 6) {
          this.error("Too many hex digits", pos);
        }
      }
      this.next();
      return len;
    }
    function eatQuestionMarkSequence(max) {
      let count = 0;
      while (this.isDelim(QUESTIONMARK)) {
        if (++count > max) {
          this.error("Too many question marks");
        }
        this.next();
      }
    }
    function startsWith(code) {
      if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected");
      }
    }
    function scanUnicodeRange() {
      let hexLength = 0;
      switch (this.tokenType) {
        case types.Number:
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            break;
          }
          if (this.tokenType === types.Dimension || this.tokenType === types.Number) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            break;
          }
          break;
        case types.Dimension:
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        default:
          this.eatDelim(PLUSSIGN);
          if (this.tokenType === types.Ident) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            break;
          }
          if (this.isDelim(QUESTIONMARK)) {
            this.next();
            eatQuestionMarkSequence.call(this, 5);
            break;
          }
          this.error("Hex digit or question mark is expected");
      }
    }
    var name = "UnicodeRange";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eatIdent("u");
      scanUnicodeRange.call(this);
      return {
        type: "UnicodeRange",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/utils/url.cjs
var require_url = __commonJS({
  "node_modules/css-tree/cjs/utils/url.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var SPACE = 32;
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function decode(str) {
      const len = str.length;
      let start = 4;
      let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
      let decoded = "";
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
        start++;
      }
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
        end--;
      }
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return "url(" + encoded + ")";
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/syntax/node/Url.cjs
var require_Url = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Url.cjs"(exports2) {
    "use strict";
    var url = require_url();
    var string = require_string();
    var types = require_types();
    var name = "Url";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let value;
      switch (this.tokenType) {
        case types.Url:
          value = url.decode(this.consume(types.Url));
          break;
        case types.Function:
          if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
            this.error("Function name must be `url`");
          }
          this.eat(types.Function);
          this.skipSC();
          value = string.decode(this.consume(types.String));
          this.skipSC();
          if (!this.eof) {
            this.eat(types.RightParenthesis);
          }
          break;
        default:
          this.error("Url or Function is expected");
      }
      return {
        type: "Url",
        loc: this.getLocation(start, this.tokenStart),
        value
      };
    }
    function generate(node) {
      this.token(types.Url, url.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Value.cjs
var require_Value = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Value.cjs"(exports2) {
    "use strict";
    var name = "Value";
    var structure = {
      children: [[]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.readSequence(this.scope.Value);
      return {
        type: "Value",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs
var require_WhiteSpace = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs"(exports2) {
    "use strict";
    var types = require_types();
    var SPACE = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    });
    var name = "WhiteSpace";
    var structure = {
      value: String
    };
    function parse() {
      this.eat(types.WhiteSpace);
      return SPACE;
    }
    function generate(node) {
      this.token(types.WhiteSpace, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/index.cjs
var require_node4 = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/index.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB();
    var Atrule = require_Atrule();
    var AtrulePrelude = require_AtrulePrelude();
    var AttributeSelector = require_AttributeSelector();
    var Block = require_Block();
    var Brackets = require_Brackets();
    var CDC = require_CDC();
    var CDO = require_CDO();
    var ClassSelector = require_ClassSelector();
    var Combinator = require_Combinator();
    var Comment = require_Comment();
    var Condition = require_Condition();
    var Declaration = require_Declaration();
    var DeclarationList = require_DeclarationList();
    var Dimension = require_Dimension();
    var Feature = require_Feature();
    var FeatureFunction = require_FeatureFunction();
    var FeatureRange = require_FeatureRange();
    var Function = require_Function();
    var GeneralEnclosed = require_GeneralEnclosed();
    var Hash = require_Hash();
    var Identifier = require_Identifier();
    var IdSelector = require_IdSelector();
    var Layer = require_Layer();
    var LayerList = require_LayerList();
    var MediaQuery = require_MediaQuery();
    var MediaQueryList = require_MediaQueryList();
    var NestingSelector = require_NestingSelector();
    var Nth = require_Nth();
    var Number$1 = require_Number();
    var Operator = require_Operator();
    var Parentheses = require_Parentheses();
    var Percentage = require_Percentage();
    var PseudoClassSelector = require_PseudoClassSelector();
    var PseudoElementSelector = require_PseudoElementSelector();
    var Ratio = require_Ratio();
    var Raw = require_Raw();
    var Rule = require_Rule();
    var Scope = require_Scope();
    var Selector = require_Selector();
    var SelectorList = require_SelectorList();
    var String$1 = require_String();
    var StyleSheet = require_StyleSheet();
    var SupportsDeclaration = require_SupportsDeclaration();
    var TypeSelector = require_TypeSelector();
    var UnicodeRange = require_UnicodeRange();
    var Url = require_Url();
    var Value = require_Value();
    var WhiteSpace = require_WhiteSpace();
    exports2.AnPlusB = AnPlusB;
    exports2.Atrule = Atrule;
    exports2.AtrulePrelude = AtrulePrelude;
    exports2.AttributeSelector = AttributeSelector;
    exports2.Block = Block;
    exports2.Brackets = Brackets;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.ClassSelector = ClassSelector;
    exports2.Combinator = Combinator;
    exports2.Comment = Comment;
    exports2.Condition = Condition;
    exports2.Declaration = Declaration;
    exports2.DeclarationList = DeclarationList;
    exports2.Dimension = Dimension;
    exports2.Feature = Feature;
    exports2.FeatureFunction = FeatureFunction;
    exports2.FeatureRange = FeatureRange;
    exports2.Function = Function;
    exports2.GeneralEnclosed = GeneralEnclosed;
    exports2.Hash = Hash;
    exports2.Identifier = Identifier;
    exports2.IdSelector = IdSelector;
    exports2.Layer = Layer;
    exports2.LayerList = LayerList;
    exports2.MediaQuery = MediaQuery;
    exports2.MediaQueryList = MediaQueryList;
    exports2.NestingSelector = NestingSelector;
    exports2.Nth = Nth;
    exports2.Number = Number$1;
    exports2.Operator = Operator;
    exports2.Parentheses = Parentheses;
    exports2.Percentage = Percentage;
    exports2.PseudoClassSelector = PseudoClassSelector;
    exports2.PseudoElementSelector = PseudoElementSelector;
    exports2.Ratio = Ratio;
    exports2.Raw = Raw;
    exports2.Rule = Rule;
    exports2.Scope = Scope;
    exports2.Selector = Selector;
    exports2.SelectorList = SelectorList;
    exports2.String = String$1;
    exports2.StyleSheet = StyleSheet;
    exports2.SupportsDeclaration = SupportsDeclaration;
    exports2.TypeSelector = TypeSelector;
    exports2.UnicodeRange = UnicodeRange;
    exports2.Url = Url;
    exports2.Value = Value;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/css-tree/cjs/syntax/config/lexer.cjs
var require_lexer = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/lexer.cjs"(exports2, module2) {
    "use strict";
    var genericConst = require_generic_const();
    var data = require_data();
    var index = require_node4();
    var lexerConfig = {
      generic: true,
      cssWideKeywords: genericConst.cssWideKeywords,
      ...data,
      node: index
    };
    module2.exports = lexerConfig;
  }
});

// node_modules/css-tree/cjs/syntax/scope/default.cjs
var require_default = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/default.cjs"(exports2, module2) {
    "use strict";
    var types = require_types();
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var SOLIDUS = 47;
    var U = 117;
    function defaultRecognizer(context) {
      switch (this.tokenType) {
        case types.Hash:
          return this.Hash();
        case types.Comma:
          return this.Operator();
        case types.LeftParenthesis:
          return this.Parentheses(this.readSequence, context.recognizer);
        case types.LeftSquareBracket:
          return this.Brackets(this.readSequence, context.recognizer);
        case types.String:
          return this.String();
        case types.Dimension:
          return this.Dimension();
        case types.Percentage:
          return this.Percentage();
        case types.Number:
          return this.Number();
        case types.Function:
          return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
        case types.Url:
          return this.Url();
        case types.Ident:
          if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {
            return this.UnicodeRange();
          } else {
            return this.Identifier();
          }
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
            return this.Operator();
          }
          if (code === NUMBERSIGN) {
            this.error("Hex or identifier is expected", this.tokenStart + 1);
          }
          break;
        }
      }
    }
    module2.exports = defaultRecognizer;
  }
});

// node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs
var require_atrulePrelude = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default();
    var atrulePrelude = {
      getNode: _default
    };
    module2.exports = atrulePrelude;
  }
});

// node_modules/css-tree/cjs/syntax/scope/selector.cjs
var require_selector = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/selector.cjs"(exports2, module2) {
    "use strict";
    var types = require_types();
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    var GREATERTHANSIGN = 62;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function onWhiteSpace(next, children) {
      if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
        children.push({
          // FIXME: this.Combinator() should be used instead
          type: "Combinator",
          loc: null,
          name: " "
        });
      }
    }
    function getNode() {
      switch (this.tokenType) {
        case types.LeftSquareBracket:
          return this.AttributeSelector();
        case types.Hash:
          return this.IdSelector();
        case types.Colon:
          if (this.lookupType(1) === types.Colon) {
            return this.PseudoElementSelector();
          } else {
            return this.PseudoClassSelector();
          }
        case types.Ident:
          return this.TypeSelector();
        case types.Number:
        case types.Percentage:
          return this.Percentage();
        case types.Dimension:
          if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
            this.error("Identifier is expected", this.tokenStart + 1);
          }
          break;
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
            case SOLIDUS:
              return this.Combinator();
            case FULLSTOP:
              return this.ClassSelector();
            case ASTERISK:
            case VERTICALLINE:
              return this.TypeSelector();
            case NUMBERSIGN:
              return this.IdSelector();
            case AMPERSAND:
              return this.NestingSelector();
          }
          break;
        }
      }
    }
    var Selector = {
      onWhiteSpace,
      getNode
    };
    module2.exports = Selector;
  }
});

// node_modules/css-tree/cjs/syntax/function/expression.cjs
var require_expression = __commonJS({
  "node_modules/css-tree/cjs/syntax/function/expression.cjs"(exports2, module2) {
    "use strict";
    function expressionFn() {
      return this.createSingleNodeList(
        this.Raw(null, false)
      );
    }
    module2.exports = expressionFn;
  }
});

// node_modules/css-tree/cjs/syntax/function/var.cjs
var require_var = __commonJS({
  "node_modules/css-tree/cjs/syntax/function/var.cjs"(exports2, module2) {
    "use strict";
    var types = require_types();
    function varFn() {
      const children = this.createList();
      this.skipSC();
      children.push(this.Identifier());
      this.skipSC();
      if (this.tokenType === types.Comma) {
        children.push(this.Operator());
        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
        if (value.type === "Value" && value.children.isEmpty) {
          for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === types.WhiteSpace) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        children.push(value);
      }
      return children;
    }
    module2.exports = varFn;
  }
});

// node_modules/css-tree/cjs/syntax/scope/value.cjs
var require_value = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/value.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default();
    var expression = require_expression();
    var _var = require_var();
    function isPlusMinusOperator(node) {
      return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
    }
    var value = {
      getNode: _default,
      onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
          next.value = " " + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
          children.last.value += " ";
        }
      },
      "expression": expression,
      "var": _var
    };
    module2.exports = value;
  }
});

// node_modules/css-tree/cjs/syntax/scope/index.cjs
var require_scope = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/index.cjs"(exports2) {
    "use strict";
    var atrulePrelude = require_atrulePrelude();
    var selector = require_selector();
    var value = require_value();
    exports2.AtrulePrelude = atrulePrelude;
    exports2.Selector = selector;
    exports2.Value = value;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/container.cjs
var require_container = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/container.cjs"(exports2, module2) {
    "use strict";
    var types = require_types();
    var nonContainerNameKeywords = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
    var container = {
      parse: {
        prelude() {
          const children = this.createList();
          if (this.tokenType === types.Ident) {
            const name = this.substring(this.tokenStart, this.tokenEnd);
            if (!nonContainerNameKeywords.has(name.toLowerCase())) {
              children.push(this.Identifier());
            }
          }
          children.push(this.Condition("container"));
          return children;
        },
        block(nested = false) {
          return this.Block(nested);
        }
      }
    };
    module2.exports = container;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/font-face.cjs
var require_font_face = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/font-face.cjs"(exports2, module2) {
    "use strict";
    var fontFace = {
      parse: {
        prelude: null,
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = fontFace;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/import.cjs
var require_import = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/import.cjs"(exports2, module2) {
    "use strict";
    var types = require_types();
    function parseWithFallback(parse, fallback) {
      return this.parseWithFallback(
        () => {
          try {
            return parse.call(this);
          } finally {
            this.skipSC();
            if (this.lookupNonWSType(0) !== types.RightParenthesis) {
              this.error();
            }
          }
        },
        fallback || (() => this.Raw(null, true))
      );
    }
    var parseFunctions = {
      layer() {
        this.skipSC();
        const children = this.createList();
        const node = parseWithFallback.call(this, this.Layer);
        if (node.type !== "Raw" || node.value !== "") {
          children.push(node);
        }
        return children;
      },
      supports() {
        this.skipSC();
        const children = this.createList();
        const node = parseWithFallback.call(
          this,
          this.Declaration,
          () => parseWithFallback.call(this, () => this.Condition("supports"))
        );
        if (node.type !== "Raw" || node.value !== "") {
          children.push(node);
        }
        return children;
      }
    };
    var importAtrule = {
      parse: {
        prelude() {
          const children = this.createList();
          switch (this.tokenType) {
            case types.String:
              children.push(this.String());
              break;
            case types.Url:
            case types.Function:
              children.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          this.skipSC();
          if (this.tokenType === types.Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
            children.push(this.Identifier());
          } else if (this.tokenType === types.Function && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
            children.push(this.Function(null, parseFunctions));
          }
          this.skipSC();
          if (this.tokenType === types.Function && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
            children.push(this.Function(null, parseFunctions));
          }
          if (this.lookupNonWSType(0) === types.Ident || this.lookupNonWSType(0) === types.LeftParenthesis) {
            children.push(this.MediaQueryList());
          }
          return children;
        },
        block: null
      }
    };
    module2.exports = importAtrule;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/layer.cjs
var require_layer = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/layer.cjs"(exports2, module2) {
    "use strict";
    var layer = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.LayerList()
          );
        },
        block() {
          return this.Block(false);
        }
      }
    };
    module2.exports = layer;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/media.cjs
var require_media = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/media.cjs"(exports2, module2) {
    "use strict";
    var media = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block(nested = false) {
          return this.Block(nested);
        }
      }
    };
    module2.exports = media;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/nest.cjs
var require_nest = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/nest.cjs"(exports2, module2) {
    "use strict";
    var nest = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = nest;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/page.cjs
var require_page = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/page.cjs"(exports2, module2) {
    "use strict";
    var page = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = page;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/scope.cjs
var require_scope2 = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/scope.cjs"(exports2, module2) {
    "use strict";
    var scope = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.Scope()
          );
        },
        block(nested = false) {
          return this.Block(nested);
        }
      }
    };
    module2.exports = scope;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/starting-style.cjs
var require_starting_style = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/starting-style.cjs"(exports2, module2) {
    "use strict";
    var startingStyle = {
      parse: {
        prelude: null,
        block(nested = false) {
          return this.Block(nested);
        }
      }
    };
    module2.exports = startingStyle;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/supports.cjs
var require_supports = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/supports.cjs"(exports2, module2) {
    "use strict";
    var supports = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.Condition("supports")
          );
        },
        block(nested = false) {
          return this.Block(nested);
        }
      }
    };
    module2.exports = supports;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/index.cjs
var require_atrule = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/index.cjs"(exports2, module2) {
    "use strict";
    var container = require_container();
    var fontFace = require_font_face();
    var _import = require_import();
    var layer = require_layer();
    var media = require_media();
    var nest = require_nest();
    var page = require_page();
    var scope = require_scope2();
    var startingStyle = require_starting_style();
    var supports = require_supports();
    var atrule = {
      container,
      "font-face": fontFace,
      import: _import,
      layer,
      media,
      nest,
      page,
      scope,
      "starting-style": startingStyle,
      supports
    };
    module2.exports = atrule;
  }
});

// node_modules/css-tree/cjs/syntax/pseudo/lang.cjs
var require_lang = __commonJS({
  "node_modules/css-tree/cjs/syntax/pseudo/lang.cjs"(exports2) {
    "use strict";
    var types = require_types();
    function parseLanguageRangeList() {
      const children = this.createList();
      this.skipSC();
      loop: while (!this.eof) {
        switch (this.tokenType) {
          case types.Ident:
            children.push(this.Identifier());
            break;
          case types.String:
            children.push(this.String());
            break;
          case types.Comma:
            children.push(this.Operator());
            break;
          case types.RightParenthesis:
            break loop;
          default:
            this.error("Identifier, string or comma is expected");
        }
        this.skipSC();
      }
      return children;
    }
    exports2.parseLanguageRangeList = parseLanguageRangeList;
  }
});

// node_modules/css-tree/cjs/syntax/pseudo/index.cjs
var require_pseudo = __commonJS({
  "node_modules/css-tree/cjs/syntax/pseudo/index.cjs"(exports2, module2) {
    "use strict";
    var lang = require_lang();
    var selectorList = {
      parse() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
    var selector = {
      parse() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    };
    var identList = {
      parse() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
    var langList = {
      parse: lang.parseLanguageRangeList
    };
    var nth = {
      parse() {
        return this.createSingleNodeList(
          this.Nth()
        );
      }
    };
    var pseudo = {
      "dir": identList,
      "has": selectorList,
      "lang": langList,
      "matches": selectorList,
      "is": selectorList,
      "-moz-any": selectorList,
      "-webkit-any": selectorList,
      "where": selectorList,
      "not": selectorList,
      "nth-child": nth,
      "nth-last-child": nth,
      "nth-last-of-type": nth,
      "nth-of-type": nth,
      "slotted": selector,
      "host": selector,
      "host-context": selector
    };
    module2.exports = pseudo;
  }
});

// node_modules/css-tree/cjs/syntax/node/index-parse.cjs
var require_index_parse = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/index-parse.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB();
    var Atrule = require_Atrule();
    var AtrulePrelude = require_AtrulePrelude();
    var AttributeSelector = require_AttributeSelector();
    var Block = require_Block();
    var Brackets = require_Brackets();
    var CDC = require_CDC();
    var CDO = require_CDO();
    var ClassSelector = require_ClassSelector();
    var Combinator = require_Combinator();
    var Comment = require_Comment();
    var Condition = require_Condition();
    var Declaration = require_Declaration();
    var DeclarationList = require_DeclarationList();
    var Dimension = require_Dimension();
    var Feature = require_Feature();
    var FeatureFunction = require_FeatureFunction();
    var FeatureRange = require_FeatureRange();
    var Function = require_Function();
    var GeneralEnclosed = require_GeneralEnclosed();
    var Hash = require_Hash();
    var Identifier = require_Identifier();
    var IdSelector = require_IdSelector();
    var Layer = require_Layer();
    var LayerList = require_LayerList();
    var MediaQuery = require_MediaQuery();
    var MediaQueryList = require_MediaQueryList();
    var NestingSelector = require_NestingSelector();
    var Nth = require_Nth();
    var Number2 = require_Number();
    var Operator = require_Operator();
    var Parentheses = require_Parentheses();
    var Percentage = require_Percentage();
    var PseudoClassSelector = require_PseudoClassSelector();
    var PseudoElementSelector = require_PseudoElementSelector();
    var Ratio = require_Ratio();
    var Raw = require_Raw();
    var Rule = require_Rule();
    var Scope = require_Scope();
    var Selector = require_Selector();
    var SelectorList = require_SelectorList();
    var String2 = require_String();
    var StyleSheet = require_StyleSheet();
    var SupportsDeclaration = require_SupportsDeclaration();
    var TypeSelector = require_TypeSelector();
    var UnicodeRange = require_UnicodeRange();
    var Url = require_Url();
    var Value = require_Value();
    var WhiteSpace = require_WhiteSpace();
    exports2.AnPlusB = AnPlusB.parse;
    exports2.Atrule = Atrule.parse;
    exports2.AtrulePrelude = AtrulePrelude.parse;
    exports2.AttributeSelector = AttributeSelector.parse;
    exports2.Block = Block.parse;
    exports2.Brackets = Brackets.parse;
    exports2.CDC = CDC.parse;
    exports2.CDO = CDO.parse;
    exports2.ClassSelector = ClassSelector.parse;
    exports2.Combinator = Combinator.parse;
    exports2.Comment = Comment.parse;
    exports2.Condition = Condition.parse;
    exports2.Declaration = Declaration.parse;
    exports2.DeclarationList = DeclarationList.parse;
    exports2.Dimension = Dimension.parse;
    exports2.Feature = Feature.parse;
    exports2.FeatureFunction = FeatureFunction.parse;
    exports2.FeatureRange = FeatureRange.parse;
    exports2.Function = Function.parse;
    exports2.GeneralEnclosed = GeneralEnclosed.parse;
    exports2.Hash = Hash.parse;
    exports2.Identifier = Identifier.parse;
    exports2.IdSelector = IdSelector.parse;
    exports2.Layer = Layer.parse;
    exports2.LayerList = LayerList.parse;
    exports2.MediaQuery = MediaQuery.parse;
    exports2.MediaQueryList = MediaQueryList.parse;
    exports2.NestingSelector = NestingSelector.parse;
    exports2.Nth = Nth.parse;
    exports2.Number = Number2.parse;
    exports2.Operator = Operator.parse;
    exports2.Parentheses = Parentheses.parse;
    exports2.Percentage = Percentage.parse;
    exports2.PseudoClassSelector = PseudoClassSelector.parse;
    exports2.PseudoElementSelector = PseudoElementSelector.parse;
    exports2.Ratio = Ratio.parse;
    exports2.Raw = Raw.parse;
    exports2.Rule = Rule.parse;
    exports2.Scope = Scope.parse;
    exports2.Selector = Selector.parse;
    exports2.SelectorList = SelectorList.parse;
    exports2.String = String2.parse;
    exports2.StyleSheet = StyleSheet.parse;
    exports2.SupportsDeclaration = SupportsDeclaration.parse;
    exports2.TypeSelector = TypeSelector.parse;
    exports2.UnicodeRange = UnicodeRange.parse;
    exports2.Url = Url.parse;
    exports2.Value = Value.parse;
    exports2.WhiteSpace = WhiteSpace.parse;
  }
});

// node_modules/css-tree/cjs/syntax/config/parser.cjs
var require_parser = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/parser.cjs"(exports2, module2) {
    "use strict";
    var index = require_scope();
    var index$1 = require_atrule();
    var index$2 = require_pseudo();
    var indexParse = require_index_parse();
    var config = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude(options) {
          return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        condition(options) {
          return this.Condition(options.kind);
        },
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      features: {
        supports: {
          selector() {
            return this.Selector();
          }
        },
        container: {
          style() {
            return this.Declaration();
          }
        }
      },
      scope: index,
      atrule: index$1,
      pseudo: index$2,
      node: indexParse
    };
    module2.exports = config;
  }
});

// node_modules/css-tree/cjs/syntax/config/walker.cjs
var require_walker2 = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/walker.cjs"(exports2, module2) {
    "use strict";
    var index = require_node4();
    var config = {
      node: index
    };
    module2.exports = config;
  }
});

// node_modules/css-tree/cjs/syntax/index.cjs
var require_syntax = __commonJS({
  "node_modules/css-tree/cjs/syntax/index.cjs"(exports2, module2) {
    "use strict";
    var create = require_create5();
    var lexer = require_lexer();
    var parser = require_parser();
    var walker = require_walker2();
    var syntax = create({
      ...lexer,
      ...parser,
      ...walker
    });
    module2.exports = syntax;
  }
});

// node_modules/css-tree/package.json
var require_package = __commonJS({
  "node_modules/css-tree/package.json"(exports2, module2) {
    module2.exports = {
      name: "css-tree",
      version: "3.1.0",
      description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
      author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
      license: "MIT",
      repository: "csstree/csstree",
      keywords: [
        "css",
        "ast",
        "tokenizer",
        "parser",
        "walker",
        "lexer",
        "generator",
        "utils",
        "syntax",
        "validation"
      ],
      type: "module",
      module: "./lib/index.js",
      main: "./cjs/index.cjs",
      exports: {
        ".": {
          import: "./lib/index.js",
          require: "./cjs/index.cjs"
        },
        "./dist/*": "./dist/*.js",
        "./package.json": "./package.json",
        "./tokenizer": {
          import: "./lib/tokenizer/index.js",
          require: "./cjs/tokenizer/index.cjs"
        },
        "./parser": {
          import: "./lib/parser/index.js",
          require: "./cjs/parser/index.cjs"
        },
        "./selector-parser": {
          import: "./lib/parser/parse-selector.js",
          require: "./cjs/parser/parse-selector.cjs"
        },
        "./generator": {
          import: "./lib/generator/index.js",
          require: "./cjs/generator/index.cjs"
        },
        "./walker": {
          import: "./lib/walker/index.js",
          require: "./cjs/walker/index.cjs"
        },
        "./convertor": {
          import: "./lib/convertor/index.js",
          require: "./cjs/convertor/index.cjs"
        },
        "./lexer": {
          import: "./lib/lexer/index.js",
          require: "./cjs/lexer/index.cjs"
        },
        "./definition-syntax": {
          import: "./lib/definition-syntax/index.js",
          require: "./cjs/definition-syntax/index.cjs"
        },
        "./definition-syntax-data": {
          import: "./lib/data.js",
          require: "./cjs/data.cjs"
        },
        "./definition-syntax-data-patch": {
          import: "./lib/data-patch.js",
          require: "./cjs/data-patch.cjs"
        },
        "./utils": {
          import: "./lib/utils/index.js",
          require: "./cjs/utils/index.cjs"
        }
      },
      browser: {
        "./cjs/data.cjs": "./dist/data.cjs",
        "./cjs/version.cjs": "./dist/version.cjs",
        "./lib/data.js": "./dist/data.js",
        "./lib/version.js": "./dist/version.js"
      },
      unpkg: "dist/csstree.esm.js",
      jsdelivr: "dist/csstree.esm.js",
      scripts: {
        watch: "npm run build -- --watch",
        build: "npm run bundle && npm run esm-to-cjs --",
        "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
        bundle: "node scripts/bundle",
        "bundle-and-test": "npm run bundle && npm run test:dist",
        "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
        "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
        lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
        "lint-and-test": "npm run lint && npm test",
        "update:docs": "node scripts/update-docs",
        "review:syntax-patch": "node scripts/review-syntax-patch",
        test: "mocha lib/__tests --require lib/__tests/helpers/setup.js --reporter progress",
        "test:cjs": "mocha cjs/__tests --require lib/__tests/helpers/setup.js --reporter progress",
        "test:dist": "mocha dist/__tests --reporter progress",
        coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
        prepublishOnly: "npm run lint-and-test && npm run build-and-test"
      },
      dependencies: {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      devDependencies: {
        c8: "^7.12.0",
        clap: "^2.0.1",
        esbuild: "^0.24.0",
        eslint: "^8.4.1",
        "json-to-ast": "^2.1.0",
        mocha: "^9.2.2",
        rollup: "^2.79.2"
      },
      engines: {
        node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      },
      files: [
        "data",
        "dist",
        "cjs",
        "!cjs/__tests",
        "lib",
        "!lib/__tests"
      ]
    };
  }
});

// node_modules/css-tree/cjs/version.cjs
var require_version = __commonJS({
  "node_modules/css-tree/cjs/version.cjs"(exports2) {
    "use strict";
    var { version } = require_package();
    exports2.version = version;
  }
});

// node_modules/css-tree/cjs/definition-syntax/index.cjs
var require_definition_syntax = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/index.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError2();
    var generate = require_generate();
    var parse = require_parse();
    var walk = require_walk();
    exports2.SyntaxError = SyntaxError2.SyntaxError;
    exports2.generate = generate.generate;
    exports2.parse = parse.parse;
    exports2.walk = walk.walk;
  }
});

// node_modules/css-tree/cjs/utils/clone.cjs
var require_clone = __commonJS({
  "node_modules/css-tree/cjs/utils/clone.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function clone(node) {
      const result = {};
      for (const key of Object.keys(node)) {
        let value = node[key];
        if (value) {
          if (Array.isArray(value) || value instanceof List.List) {
            value = value.map(clone);
          } else if (value.constructor === Object) {
            value = clone(value);
          }
        }
        result[key] = value;
      }
      return result;
    }
    exports2.clone = clone;
  }
});

// node_modules/css-tree/cjs/utils/ident.cjs
var require_ident = __commonJS({
  "node_modules/css-tree/cjs/utils/ident.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var REVERSE_SOLIDUS = 92;
    function decode(str) {
      const end = str.length - 1;
      let decoded = "";
      for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      if (str.length === 1 && str.charCodeAt(0) === 45) {
        return "\\-";
      }
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (
          // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
          // Note: Do not compare with 0x0001 since 0x0000 is precessed before
          code <= 31 || code === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
          code >= 48 && code <= 57 && // If the character is the first character ...
          (i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
          i === 1 && str.charCodeAt(0) === 45)
        ) {
          encoded += "\\" + code.toString(16) + " ";
          continue;
        }
        if (charCodeDefinitions.isName(code)) {
          encoded += str.charAt(i);
        } else {
          encoded += "\\" + str.charAt(i);
        }
      }
      return encoded;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/css-tree/cjs/index.cjs"(exports2) {
    "use strict";
    var index$1 = require_syntax();
    var version = require_version();
    var create = require_create5();
    var List = require_List();
    var Lexer = require_Lexer();
    var index = require_definition_syntax();
    var clone = require_clone();
    var names$1 = require_names2();
    var ident = require_ident();
    var string = require_string();
    var url = require_url();
    var types = require_types();
    var names = require_names();
    var TokenStream = require_TokenStream();
    var OffsetToLocation = require_OffsetToLocation();
    var {
      tokenize,
      parse,
      generate,
      lexer,
      createLexer,
      walk,
      find,
      findLast,
      findAll,
      toPlainObject,
      fromPlainObject,
      fork
    } = index$1;
    exports2.version = version.version;
    exports2.createSyntax = create;
    exports2.List = List.List;
    exports2.Lexer = Lexer.Lexer;
    exports2.definitionSyntax = index;
    exports2.clone = clone.clone;
    exports2.isCustomProperty = names$1.isCustomProperty;
    exports2.keyword = names$1.keyword;
    exports2.property = names$1.property;
    exports2.vendorPrefix = names$1.vendorPrefix;
    exports2.ident = ident;
    exports2.string = string;
    exports2.url = url;
    exports2.tokenTypes = types;
    exports2.tokenNames = names;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.OffsetToLocation = OffsetToLocation.OffsetToLocation;
    exports2.createLexer = createLexer;
    exports2.find = find;
    exports2.findAll = findAll;
    exports2.findLast = findLast;
    exports2.fork = fork;
    exports2.fromPlainObject = fromPlainObject;
    exports2.generate = generate;
    exports2.lexer = lexer;
    exports2.parse = parse;
    exports2.toPlainObject = toPlainObject;
    exports2.tokenize = tokenize;
    exports2.walk = walk;
  }
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports2, module2) {
    (function(root) {
      var freeExports = typeof exports2 == "object" && exports2;
      var freeModule = typeof module2 == "object" && module2 && module2.exports == freeExports && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", "_": "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", "$": "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", "\u212C": "Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", "\u212D": "Cfr", "\u{1D49E}": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", "\u2130": "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", "fj": "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\u{1D558}": "gopf", "\u{1D524}": "gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\u{1D525}": "hfr", "\u210E": "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\u{1D55A}": "iopf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Kopf", "\u{1D50E}": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", "\u2113": "ell", "\u{1D55D}": "lopf", "\u2112": "Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr", "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", "\u2133": "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", "\u2115": "Nopf", "\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", "\u2134": "oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "pscr", "\u{1D561}": "popf", "\u2119": "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\u{1D4CA}": "uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf", "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr", "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "zfr", "\u{1D56B}": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\u{1D4B5}": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "\xE1", "Aacute": "\xC1", "abreve": "\u0103", "Abreve": "\u0102", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "acy": "\u0430", "Acy": "\u0410", "aelig": "\xE6", "AElig": "\xC6", "af": "\u2061", "afr": "\u{1D51E}", "Afr": "\u{1D504}", "agrave": "\xE0", "Agrave": "\xC0", "alefsym": "\u2135", "aleph": "\u2135", "alpha": "\u03B1", "Alpha": "\u0391", "amacr": "\u0101", "Amacr": "\u0100", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "and": "\u2227", "And": "\u2A53", "andand": "\u2A55", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsd": "\u2221", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "aogon": "\u0105", "Aogon": "\u0104", "aopf": "\u{1D552}", "Aopf": "\u{1D538}", "ap": "\u2248", "apacir": "\u2A6F", "ape": "\u224A", "apE": "\u2A70", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "aring": "\xE5", "Aring": "\xC5", "ascr": "\u{1D4B6}", "Ascr": "\u{1D49C}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "bcy": "\u0431", "Bcy": "\u0411", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "beta": "\u03B2", "Beta": "\u0392", "beth": "\u2136", "between": "\u226C", "bfr": "\u{1D51F}", "Bfr": "\u{1D505}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bnot": "\u2310", "bNot": "\u2AED", "bopf": "\u{1D553}", "Bopf": "\u{1D539}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxhD": "\u2565", "boxHd": "\u2564", "boxHD": "\u2566", "boxhu": "\u2534", "boxhU": "\u2568", "boxHu": "\u2567", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsol": "\\", "bsolb": "\u29C5", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpe": "\u224F", "bumpE": "\u2AAE", "bumpeq": "\u224F", "Bumpeq": "\u224E", "cacute": "\u0107", "Cacute": "\u0106", "cap": "\u2229", "Cap": "\u22D2", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "ccaron": "\u010D", "Ccaron": "\u010C", "ccedil": "\xE7", "Ccedil": "\xC7", "ccirc": "\u0109", "Ccirc": "\u0108", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "cdot": "\u010B", "Cdot": "\u010A", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "chcy": "\u0447", "CHcy": "\u0427", "check": "\u2713", "checkmark": "\u2713", "chi": "\u03C7", "Chi": "\u03A7", "cir": "\u25CB", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cire": "\u2257", "cirE": "\u29C3", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "colone": "\u2254", "Colone": "\u2A74", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "cscr": "\u{1D4B8}", "Cscr": "\u{1D49E}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cup": "\u222A", "Cup": "\u22D3", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "dArr": "\u21D3", "Darr": "\u21A1", "dash": "\u2010", "dashv": "\u22A3", "Dashv": "\u2AE4", "dbkarow": "\u290F", "dblac": "\u02DD", "dcaron": "\u010F", "Dcaron": "\u010E", "dcy": "\u0434", "Dcy": "\u0414", "dd": "\u2146", "DD": "\u2145", "ddagger": "\u2021", "ddarr": "\u21CA", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "delta": "\u03B4", "Delta": "\u0394", "demptyv": "\u29B1", "dfisht": "\u297F", "dfr": "\u{1D521}", "Dfr": "\u{1D507}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "djcy": "\u0452", "DJcy": "\u0402", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "dopf": "\u{1D555}", "Dopf": "\u{1D53B}", "dot": "\u02D9", "Dot": "\xA8", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "downarrow": "\u2193", "Downarrow": "\u21D3", "DownArrow": "\u2193", "DownArrowBar": "\u2913", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVector": "\u21BD", "DownLeftVectorBar": "\u2956", "DownRightTeeVector": "\u295F", "DownRightVector": "\u21C1", "DownRightVectorBar": "\u2957", "DownTee": "\u22A4", "DownTeeArrow": "\u21A7", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "dscr": "\u{1D4B9}", "Dscr": "\u{1D49F}", "dscy": "\u0455", "DScy": "\u0405", "dsol": "\u29F6", "dstrok": "\u0111", "Dstrok": "\u0110", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "dzcy": "\u045F", "DZcy": "\u040F", "dzigrarr": "\u27FF", "eacute": "\xE9", "Eacute": "\xC9", "easter": "\u2A6E", "ecaron": "\u011B", "Ecaron": "\u011A", "ecir": "\u2256", "ecirc": "\xEA", "Ecirc": "\xCA", "ecolon": "\u2255", "ecy": "\u044D", "Ecy": "\u042D", "eDDot": "\u2A77", "edot": "\u0117", "eDot": "\u2251", "Edot": "\u0116", "ee": "\u2147", "efDot": "\u2252", "efr": "\u{1D522}", "Efr": "\u{1D508}", "eg": "\u2A9A", "egrave": "\xE8", "Egrave": "\xC8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "emacr": "\u0113", "Emacr": "\u0112", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp": "\u2003", "emsp13": "\u2004", "emsp14": "\u2005", "eng": "\u014B", "ENG": "\u014A", "ensp": "\u2002", "eogon": "\u0119", "Eogon": "\u0118", "eopf": "\u{1D556}", "Eopf": "\u{1D53C}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "epsilon": "\u03B5", "Epsilon": "\u0395", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "esim": "\u2242", "Esim": "\u2A73", "eta": "\u03B7", "Eta": "\u0397", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "fcy": "\u0444", "Fcy": "\u0424", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "ffr": "\u{1D523}", "Ffr": "\u{1D509}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "fopf": "\u{1D557}", "Fopf": "\u{1D53D}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "gamma": "\u03B3", "Gamma": "\u0393", "gammad": "\u03DD", "Gammad": "\u03DC", "gap": "\u2A86", "gbreve": "\u011F", "Gbreve": "\u011E", "Gcedil": "\u0122", "gcirc": "\u011D", "Gcirc": "\u011C", "gcy": "\u0433", "Gcy": "\u0413", "gdot": "\u0121", "Gdot": "\u0120", "ge": "\u2265", "gE": "\u2267", "gel": "\u22DB", "gEl": "\u2A8C", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "ges": "\u2A7E", "gescc": "\u2AA9", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "gfr": "\u{1D524}", "Gfr": "\u{1D50A}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "gjcy": "\u0453", "GJcy": "\u0403", "gl": "\u2277", "gla": "\u2AA5", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "gopf": "\u{1D558}", "Gopf": "\u{1D53E}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "gscr": "\u210A", "Gscr": "\u{1D4A2}", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gt": ">", "Gt": "\u226B", "GT": ">", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "hardcy": "\u044A", "HARDcy": "\u042A", "harr": "\u2194", "hArr": "\u21D4", "harrcir": "\u2948", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "hcirc": "\u0125", "Hcirc": "\u0124", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "hstrok": "\u0127", "Hstrok": "\u0126", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "iacute": "\xED", "Iacute": "\xCD", "ic": "\u2063", "icirc": "\xEE", "Icirc": "\xCE", "icy": "\u0438", "Icy": "\u0418", "Idot": "\u0130", "iecy": "\u0435", "IEcy": "\u0415", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "igrave": "\xEC", "Igrave": "\xCC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "ijlig": "\u0133", "IJlig": "\u0132", "Im": "\u2111", "imacr": "\u012B", "Imacr": "\u012A", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "in": "\u2208", "incare": "\u2105", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "int": "\u222B", "Int": "\u222C", "intcal": "\u22BA", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "iocy": "\u0451", "IOcy": "\u0401", "iogon": "\u012F", "Iogon": "\u012E", "iopf": "\u{1D55A}", "Iopf": "\u{1D540}", "iota": "\u03B9", "Iota": "\u0399", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "itilde": "\u0129", "Itilde": "\u0128", "iukcy": "\u0456", "Iukcy": "\u0406", "iuml": "\xEF", "Iuml": "\xCF", "jcirc": "\u0135", "Jcirc": "\u0134", "jcy": "\u0439", "Jcy": "\u0419", "jfr": "\u{1D527}", "Jfr": "\u{1D50D}", "jmath": "\u0237", "jopf": "\u{1D55B}", "Jopf": "\u{1D541}", "jscr": "\u{1D4BF}", "Jscr": "\u{1D4A5}", "jsercy": "\u0458", "Jsercy": "\u0408", "jukcy": "\u0454", "Jukcy": "\u0404", "kappa": "\u03BA", "Kappa": "\u039A", "kappav": "\u03F0", "kcedil": "\u0137", "Kcedil": "\u0136", "kcy": "\u043A", "Kcy": "\u041A", "kfr": "\u{1D528}", "Kfr": "\u{1D50E}", "kgreen": "\u0138", "khcy": "\u0445", "KHcy": "\u0425", "kjcy": "\u045C", "KJcy": "\u040C", "kopf": "\u{1D55C}", "Kopf": "\u{1D542}", "kscr": "\u{1D4C0}", "Kscr": "\u{1D4A6}", "lAarr": "\u21DA", "lacute": "\u013A", "Lacute": "\u0139", "laemptyv": "\u29B4", "lagran": "\u2112", "lambda": "\u03BB", "Lambda": "\u039B", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larr": "\u2190", "lArr": "\u21D0", "Larr": "\u219E", "larrb": "\u21E4", "larrbfs": "\u291F", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "lat": "\u2AAB", "latail": "\u2919", "lAtail": "\u291B", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "lcaron": "\u013E", "Lcaron": "\u013D", "lcedil": "\u013C", "Lcedil": "\u013B", "lceil": "\u2308", "lcub": "{", "lcy": "\u043B", "Lcy": "\u041B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "leftarrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrow": "\u2190", "LeftArrowBar": "\u21E4", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVector": "\u21C3", "LeftDownVectorBar": "\u2959", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "Leftrightarrow": "\u21D4", "LeftRightArrow": "\u2194", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTee": "\u22A3", "LeftTeeArrow": "\u21A4", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangle": "\u22B2", "LeftTriangleBar": "\u29CF", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVector": "\u21BF", "LeftUpVectorBar": "\u2958", "LeftVector": "\u21BC", "LeftVectorBar": "\u2952", "leg": "\u22DA", "lEg": "\u2A8B", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "les": "\u2A7D", "lescc": "\u2AA8", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "lfr": "\u{1D529}", "Lfr": "\u{1D50F}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "ljcy": "\u0459", "LJcy": "\u0409", "ll": "\u226A", "Ll": "\u22D8", "llarr": "\u21C7", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "lmidot": "\u0140", "Lmidot": "\u013F", "lmoust": "\u23B0", "lmoustache": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "Longleftarrow": "\u27F8", "LongLeftArrow": "\u27F5", "longleftrightarrow": "\u27F7", "Longleftrightarrow": "\u27FA", "LongLeftRightArrow": "\u27F7", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "Longrightarrow": "\u27F9", "LongRightArrow": "\u27F6", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "lopf": "\u{1D55D}", "Lopf": "\u{1D543}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "lstrok": "\u0142", "Lstrok": "\u0141", "lt": "<", "Lt": "\u226A", "LT": "<", "ltcc": "\u2AA6", "ltcir": "\u2A79", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "map": "\u21A6", "Map": "\u2905", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "mcy": "\u043C", "Mcy": "\u041C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "mfr": "\u{1D52A}", "Mfr": "\u{1D510}", "mho": "\u2127", "micro": "\xB5", "mid": "\u2223", "midast": "*", "midcir": "\u2AF0", "middot": "\xB7", "minus": "\u2212", "minusb": "\u229F", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "mopf": "\u{1D55E}", "Mopf": "\u{1D544}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "mu": "\u03BC", "Mu": "\u039C", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "nacute": "\u0144", "Nacute": "\u0143", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natur": "\u266E", "natural": "\u266E", "naturals": "\u2115", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "ncaron": "\u0148", "Ncaron": "\u0147", "ncedil": "\u0146", "Ncedil": "\u0145", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "ncy": "\u043D", "Ncy": "\u041D", "ndash": "\u2013", "ne": "\u2260", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "nfr": "\u{1D52B}", "Nfr": "\u{1D511}", "nge": "\u2271", "ngE": "\u2267\u0338", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "ngt": "\u226F", "nGt": "\u226B\u20D2", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "njcy": "\u045A", "NJcy": "\u040A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nle": "\u2270", "nlE": "\u2266\u0338", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nlt": "\u226E", "nLt": "\u226A\u20D2", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "not": "\xAC", "Not": "\u2AEC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangle": "\u22EA", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangle": "\u22EB", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "npar": "\u2226", "nparallel": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "npre": "\u2AAF\u0338", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrc": "\u2933\u0338", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "nscr": "\u{1D4C3}", "Nscr": "\u{1D4A9}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsube": "\u2288", "nsubE": "\u2AC5\u0338", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupe": "\u2289", "nsupE": "\u2AC6\u0338", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "ntilde": "\xF1", "Ntilde": "\xD1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "nu": "\u03BD", "Nu": "\u039D", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "oacute": "\xF3", "Oacute": "\xD3", "oast": "\u229B", "ocir": "\u229A", "ocirc": "\xF4", "Ocirc": "\xD4", "ocy": "\u043E", "Ocy": "\u041E", "odash": "\u229D", "odblac": "\u0151", "Odblac": "\u0150", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "oelig": "\u0153", "OElig": "\u0152", "ofcir": "\u29BF", "ofr": "\u{1D52C}", "Ofr": "\u{1D512}", "ogon": "\u02DB", "ograve": "\xF2", "Ograve": "\xD2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "omacr": "\u014D", "Omacr": "\u014C", "omega": "\u03C9", "Omega": "\u03A9", "omicron": "\u03BF", "Omicron": "\u039F", "omid": "\u29B6", "ominus": "\u2296", "oopf": "\u{1D560}", "Oopf": "\u{1D546}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "or": "\u2228", "Or": "\u2A54", "orarr": "\u21BB", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "oscr": "\u2134", "Oscr": "\u{1D4AA}", "oslash": "\xF8", "Oslash": "\xD8", "osol": "\u2298", "otilde": "\xF5", "Otilde": "\xD5", "otimes": "\u2297", "Otimes": "\u2A37", "otimesas": "\u2A36", "ouml": "\xF6", "Ouml": "\xD6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "par": "\u2225", "para": "\xB6", "parallel": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "pcy": "\u043F", "Pcy": "\u041F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "pfr": "\u{1D52D}", "Pfr": "\u{1D513}", "phi": "\u03C6", "Phi": "\u03A6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "pi": "\u03C0", "Pi": "\u03A0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plus": "+", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "pr": "\u227A", "Pr": "\u2ABB", "prap": "\u2AB7", "prcue": "\u227C", "pre": "\u2AAF", "prE": "\u2AB3", "prec": "\u227A", "precapprox": "\u2AB7", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportion": "\u2237", "Proportional": "\u221D", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "pscr": "\u{1D4C5}", "Pscr": "\u{1D4AB}", "psi": "\u03C8", "Psi": "\u03A8", "puncsp": "\u2008", "qfr": "\u{1D52E}", "Qfr": "\u{1D514}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "qscr": "\u{1D4C6}", "Qscr": "\u{1D4AC}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "racute": "\u0155", "Racute": "\u0154", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarr": "\u2192", "rArr": "\u21D2", "Rarr": "\u21A0", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "rarrtl": "\u21A3", "Rarrtl": "\u2916", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "rcaron": "\u0159", "Rcaron": "\u0158", "rcedil": "\u0157", "Rcedil": "\u0156", "rceil": "\u2309", "rcub": "}", "rcy": "\u0440", "Rcy": "\u0420", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "Re": "\u211C", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "rho": "\u03C1", "Rho": "\u03A1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "rightarrow": "\u2192", "Rightarrow": "\u21D2", "RightArrow": "\u2192", "RightArrowBar": "\u21E5", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVector": "\u21C2", "RightDownVectorBar": "\u2955", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTee": "\u22A2", "RightTeeArrow": "\u21A6", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangle": "\u22B3", "RightTriangleBar": "\u29D0", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVector": "\u21BE", "RightUpVectorBar": "\u2954", "RightVector": "\u21C0", "RightVectorBar": "\u2953", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoust": "\u23B1", "rmoustache": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "sacute": "\u015B", "Sacute": "\u015A", "sbquo": "\u201A", "sc": "\u227B", "Sc": "\u2ABC", "scap": "\u2AB8", "scaron": "\u0161", "Scaron": "\u0160", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "scedil": "\u015F", "Scedil": "\u015E", "scirc": "\u015D", "Scirc": "\u015C", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "scy": "\u0441", "Scy": "\u0421", "sdot": "\u22C5", "sdotb": "\u22A1", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "sfr": "\u{1D530}", "Sfr": "\u{1D516}", "sfrown": "\u2322", "sharp": "\u266F", "shchcy": "\u0449", "SHCHcy": "\u0429", "shcy": "\u0448", "SHcy": "\u0428", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "sigma": "\u03C3", "Sigma": "\u03A3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "softcy": "\u044C", "SOFTcy": "\u042C", "sol": "/", "solb": "\u29C4", "solbar": "\u233F", "sopf": "\u{1D564}", "Sopf": "\u{1D54A}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "squ": "\u25A1", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squf": "\u25AA", "srarr": "\u2192", "sscr": "\u{1D4C8}", "Sscr": "\u{1D4AE}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "star": "\u2606", "Star": "\u22C6", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "sube": "\u2286", "subE": "\u2AC5", "subedot": "\u2AC3", "submult": "\u2AC1", "subne": "\u228A", "subnE": "\u2ACB", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succ": "\u227B", "succapprox": "\u2AB8", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup": "\u2283", "Sup": "\u22D1", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supe": "\u2287", "supE": "\u2AC6", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supne": "\u228B", "supnE": "\u2ACC", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "tau": "\u03C4", "Tau": "\u03A4", "tbrk": "\u23B4", "tcaron": "\u0165", "Tcaron": "\u0164", "tcedil": "\u0163", "Tcedil": "\u0162", "tcy": "\u0442", "Tcy": "\u0422", "tdot": "\u20DB", "telrec": "\u2315", "tfr": "\u{1D531}", "Tfr": "\u{1D517}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "theta": "\u03B8", "Theta": "\u0398", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "thinsp": "\u2009", "ThinSpace": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "thorn": "\xFE", "THORN": "\xDE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "times": "\xD7", "timesb": "\u22A0", "timesbar": "\u2A31", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "top": "\u22A4", "topbot": "\u2336", "topcir": "\u2AF1", "topf": "\u{1D565}", "Topf": "\u{1D54B}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "tscr": "\u{1D4C9}", "Tscr": "\u{1D4AF}", "tscy": "\u0446", "TScy": "\u0426", "tshcy": "\u045B", "TSHcy": "\u040B", "tstrok": "\u0167", "Tstrok": "\u0166", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "uacute": "\xFA", "Uacute": "\xDA", "uarr": "\u2191", "uArr": "\u21D1", "Uarr": "\u219F", "Uarrocir": "\u2949", "ubrcy": "\u045E", "Ubrcy": "\u040E", "ubreve": "\u016D", "Ubreve": "\u016C", "ucirc": "\xFB", "Ucirc": "\xDB", "ucy": "\u0443", "Ucy": "\u0423", "udarr": "\u21C5", "udblac": "\u0171", "Udblac": "\u0170", "udhar": "\u296E", "ufisht": "\u297E", "ufr": "\u{1D532}", "Ufr": "\u{1D518}", "ugrave": "\xF9", "Ugrave": "\xD9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "umacr": "\u016B", "Umacr": "\u016A", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "uogon": "\u0173", "Uogon": "\u0172", "uopf": "\u{1D566}", "Uopf": "\u{1D54C}", "uparrow": "\u2191", "Uparrow": "\u21D1", "UpArrow": "\u2191", "UpArrowBar": "\u2912", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "Updownarrow": "\u21D5", "UpDownArrow": "\u2195", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "upsilon": "\u03C5", "Upsilon": "\u03A5", "UpTee": "\u22A5", "UpTeeArrow": "\u21A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "uring": "\u016F", "Uring": "\u016E", "urtri": "\u25F9", "uscr": "\u{1D4CA}", "Uscr": "\u{1D4B0}", "utdot": "\u22F0", "utilde": "\u0169", "Utilde": "\u0168", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "uuml": "\xFC", "Uuml": "\xDC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "vcy": "\u0432", "Vcy": "\u0412", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "vee": "\u2228", "Vee": "\u22C1", "veebar": "\u22BB", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "vfr": "\u{1D533}", "Vfr": "\u{1D519}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "vopf": "\u{1D567}", "Vopf": "\u{1D54D}", "vprop": "\u221D", "vrtri": "\u22B3", "vscr": "\u{1D4CB}", "Vscr": "\u{1D4B1}", "vsubne": "\u228A\uFE00", "vsubnE": "\u2ACB\uFE00", "vsupne": "\u228B\uFE00", "vsupnE": "\u2ACC\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "wcirc": "\u0175", "Wcirc": "\u0174", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "wfr": "\u{1D534}", "Wfr": "\u{1D51A}", "wopf": "\u{1D568}", "Wopf": "\u{1D54E}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "wscr": "\u{1D4CC}", "Wscr": "\u{1D4B2}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "xfr": "\u{1D535}", "Xfr": "\u{1D51B}", "xharr": "\u27F7", "xhArr": "\u27FA", "xi": "\u03BE", "Xi": "\u039E", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "xopf": "\u{1D569}", "Xopf": "\u{1D54F}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "xscr": "\u{1D4CD}", "Xscr": "\u{1D4B3}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "yacute": "\xFD", "Yacute": "\xDD", "yacy": "\u044F", "YAcy": "\u042F", "ycirc": "\u0177", "Ycirc": "\u0176", "ycy": "\u044B", "Ycy": "\u042B", "yen": "\xA5", "yfr": "\u{1D536}", "Yfr": "\u{1D51C}", "yicy": "\u0457", "YIcy": "\u0407", "yopf": "\u{1D56A}", "Yopf": "\u{1D550}", "yscr": "\u{1D4CE}", "Yscr": "\u{1D4B4}", "yucy": "\u044E", "YUcy": "\u042E", "yuml": "\xFF", "Yuml": "\u0178", "zacute": "\u017A", "Zacute": "\u0179", "zcaron": "\u017E", "Zcaron": "\u017D", "zcy": "\u0437", "Zcy": "\u0417", "zdot": "\u017C", "Zdot": "\u017B", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "zeta": "\u03B6", "Zeta": "\u0396", "zfr": "\u{1D537}", "Zfr": "\u2128", "zhcy": "\u0436", "ZHcy": "\u0416", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "zscr": "\u{1D4CF}", "Zscr": "\u{1D4B5}", "zwj": "\u200D", "zwnj": "\u200C" };
      var decodeMapLegacy = { "aacute": "\xE1", "Aacute": "\xC1", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "aelig": "\xE6", "AElig": "\xC6", "agrave": "\xE0", "Agrave": "\xC0", "amp": "&", "AMP": "&", "aring": "\xE5", "Aring": "\xC5", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "brvbar": "\xA6", "ccedil": "\xE7", "Ccedil": "\xC7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "eacute": "\xE9", "Eacute": "\xC9", "ecirc": "\xEA", "Ecirc": "\xCA", "egrave": "\xE8", "Egrave": "\xC8", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "iacute": "\xED", "Iacute": "\xCD", "icirc": "\xEE", "Icirc": "\xCE", "iexcl": "\xA1", "igrave": "\xEC", "Igrave": "\xCC", "iquest": "\xBF", "iuml": "\xEF", "Iuml": "\xCF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "ntilde": "\xF1", "Ntilde": "\xD1", "oacute": "\xF3", "Oacute": "\xD3", "ocirc": "\xF4", "Ocirc": "\xD4", "ograve": "\xF2", "Ograve": "\xD2", "ordf": "\xAA", "ordm": "\xBA", "oslash": "\xF8", "Oslash": "\xD8", "otilde": "\xF5", "Otilde": "\xD5", "ouml": "\xF6", "Ouml": "\xD6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "thorn": "\xFE", "THORN": "\xDE", "times": "\xD7", "uacute": "\xFA", "Uacute": "\xDA", "ucirc": "\xFB", "Ucirc": "\xDB", "ugrave": "\xF9", "Ugrave": "\xD9", "uml": "\xA8", "uuml": "\xFC", "Uuml": "\xDC", "yacute": "\xFD", "Yacute": "\xDD", "yen": "\xA5", "yuml": "\xFF" };
      var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty2 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty2.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "\uFFFD";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        root.he = he;
      }
    })(exports2);
  }
});

// node_modules/node-html-parser/dist/nodes/node.js
var require_node5 = __commonJS({
  "node_modules/node-html-parser/dist/nodes/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var he_1 = require_he();
    var Node = class {
      constructor(parentNode = null, range) {
        this.parentNode = parentNode;
        this.childNodes = [];
        Object.defineProperty(this, "range", {
          enumerable: false,
          writable: true,
          configurable: true,
          value: range !== null && range !== void 0 ? range : [-1, -1]
        });
      }
      /**
       * Remove current node
       */
      remove() {
        if (this.parentNode) {
          const children = this.parentNode.childNodes;
          this.parentNode.childNodes = children.filter((child) => {
            return this !== child;
          });
          this.parentNode = null;
        }
        return this;
      }
      get innerText() {
        return this.rawText;
      }
      get textContent() {
        return (0, he_1.decode)(this.rawText);
      }
      set textContent(val) {
        this.rawText = (0, he_1.encode)(val);
      }
    };
    exports2.default = Node;
  }
});

// node_modules/node-html-parser/dist/nodes/type.js
var require_type = __commonJS({
  "node_modules/node-html-parser/dist/nodes/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
      NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
      NodeType2[NodeType2["COMMENT_NODE"] = 8] = "COMMENT_NODE";
    })(NodeType || (NodeType = {}));
    exports2.default = NodeType;
  }
});

// node_modules/node-html-parser/dist/nodes/comment.js
var require_comment = __commonJS({
  "node_modules/node-html-parser/dist/nodes/comment.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var node_12 = __importDefault(require_node5());
    var type_1 = __importDefault(require_type());
    var CommentNode = class _CommentNode extends node_12.default {
      clone() {
        return new _CommentNode(this.rawText, null, void 0, this.rawTagName);
      }
      constructor(rawText, parentNode = null, range, rawTagName = "!--") {
        super(parentNode, range);
        this.rawText = rawText;
        this.rawTagName = rawTagName;
        this.nodeType = type_1.default.COMMENT_NODE;
      }
      /**
       * Get unescaped text value of current node and its children.
       * @return {string} text content
       */
      get text() {
        return this.rawText;
      }
      toString() {
        return `<!--${this.rawText}-->`;
      }
    };
    exports2.default = CommentNode;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node6 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node = (
      /** @class */
      (function() {
        function Node2() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      })()
    );
    exports2.Node = Node;
    var DataNode = (
      /** @class */
      (function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      })(Node)
    );
    exports2.DataNode = DataNode;
    var Text = (
      /** @class */
      (function(_super) {
        __extends(Text2, _super);
        function Text2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text2;
      })(DataNode)
    );
    exports2.Text = Text;
    var Comment = (
      /** @class */
      (function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      })(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      (function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      })(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      (function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      })(Node)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      (function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      })(NodeWithChildren)
    );
    exports2.CDATA = CDATA;
    var Document = (
      /** @class */
      (function(_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      })(NodeWithChildren)
    );
    exports2.Document = Document;
    var Element = (
      /** @class */
      (function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      })(NodeWithChildren)
    );
    exports2.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node6();
    __exportStar(require_node6(), exports2);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      (function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      })()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports2.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports2.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports2.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports2.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports2.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      (function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      })()
    );
    exports2.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports2.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports2.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports2.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports2.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports2.decodeXML = decodeXML;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
      }
      return arr;
    }
    exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// node_modules/entities/lib/escape.js
var require_escape2 = __commonJS({
  "node_modules/entities/lib/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
    exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c, index) {
        return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
      }
    );
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports2.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i) + next;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
          lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports2.encodeXML = encodeXML;
    exports2.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape2();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports2.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i + 1 < str.length) {
            var nextChar = str.charCodeAt(i + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape2();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports2.encode = encode;
    var escape_js_2 = require_escape2();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports2.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
      }
      return output;
    }
    exports2.render = render;
    exports2.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOuterHTML = getOuterHTML;
    exports2.getInnerHTML = getInnerHTML;
    exports2.getText = getText;
    exports2.textContent = textContent;
    exports2.innerText = innerText;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChildren = getChildren;
    exports2.getParent = getParent;
    exports2.getSiblings = getSiblings;
    exports2.getAttributeValue = getAttributeValue;
    exports2.hasAttrib = hasAttrib;
    exports2.getName = getName;
    exports2.nextElementSibling = nextElementSibling;
    exports2.prevElementSibling = prevElementSibling;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    function getParent(elem) {
      return elem.parent || null;
    }
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    function getName(elem) {
      return elem.name;
    }
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeElement = removeElement;
    exports2.replaceElement = replaceElement;
    exports2.appendChild = appendChild;
    exports2.append = append;
    exports2.prependChild = prependChild;
    exports2.prepend = prepend;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filter = filter;
    exports2.find = find;
    exports2.findOneChild = findOneChild;
    exports2.findOne = findOne;
    exports2.existsOne = existsOne;
    exports2.findAll = findAll;
    var domhandler_1 = require_lib2();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
      for (var i = 0; i < searchedNodes.length; i++) {
        var node = searchedNodes[i];
        if ((0, domhandler_1.isTag)(node) && test(node)) {
          return node;
        }
        if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {
          var found = findOne(test, node.children, true);
          if (found)
            return found;
        }
      }
      return null;
    }
    function existsOne(test, nodes) {
      return (Array.isArray(nodes) ? nodes : [nodes]).some(function(node) {
        return (0, domhandler_1.isTag)(node) && test(node) || (0, domhandler_1.hasChildren)(node) && existsOne(test, node.children);
      });
    }
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if ((0, domhandler_1.isTag)(elem) && test(elem))
          result.push(elem);
        if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testElement = testElement;
    exports2.getElements = getElements;
    exports2.getElementById = getElementById;
    exports2.getElementsByTagName = getElementsByTagName;
    exports2.getElementsByClassName = getElementsByClassName;
    exports2.getElementsByTagType = getElementsByTagType;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    function getElementsByClassName(className, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(getAttribCheck("class", className), nodes, recurse, limit);
    }
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentPosition = void 0;
    exports2.removeSubsets = removeSubsets;
    exports2.compareDocumentPosition = compareDocumentPosition;
    exports2.uniqueSort = uniqueSort;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition || (exports2.DocumentPosition = DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = getFeed;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar(require_stringify(), exports2);
    __exportStar(require_traversal(), exports2);
    __exportStar(require_manipulation(), exports2);
    __exportStar(require_querying(), exports2);
    __exportStar(require_legacy(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_feeds(), exports2);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports2, module2) {
    module2.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/commonjs/types.js
var require_types2 = __commonJS({
  "node_modules/css-what/lib/commonjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeAction = exports2.IgnoreCaseMode = exports2.SelectorType = void 0;
    var SelectorType;
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType = exports2.SelectorType || (exports2.SelectorType = {}));
    exports2.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction;
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction = exports2.AttributeAction || (exports2.AttributeAction = {}));
  }
});

// node_modules/css-what/lib/commonjs/parse.js
var require_parse2 = __commonJS({
  "node_modules/css-what/lib/commonjs/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.isTraversal = void 0;
    var types_1 = require_types2();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports2.isTraversal = isTraversal;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
      return c === 39 || c === 34;
    }
    function isWhitespace(c) {
      return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
    }
    function parse(selector) {
      var subselects = [];
      var endIndex = parseSelector(subselects, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects;
    }
    exports2.parse = parse;
    function parseSelector(subselects, selector, selectorIndex) {
      var tokens = [];
      function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          // Whitespace
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          // Traversals
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          // Special attribute selectors: .class, #id
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = void 0;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName(2);
            } else {
              name_1 = getName(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = void 0;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// node_modules/css-what/lib/commonjs/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/css-what/lib/commonjs/stringify.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = void 0;
    var types_1 = require_types2();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c) {
      return c.charCodeAt(0);
    }));
    function stringify(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports2.stringify = stringify;
    function stringifyToken(token, index, arr) {
      switch (token.type) {
        // Simple types
        case types_1.SelectorType.Child:
          return index === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
          ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
          lastIdx = i + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// node_modules/css-what/lib/commonjs/index.js
var require_commonjs8 = __commonJS({
  "node_modules/css-what/lib/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = exports2.parse = exports2.isTraversal = void 0;
    __exportStar(require_types2(), exports2);
    var parse_1 = require_parse2();
    Object.defineProperty(exports2, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify2();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTraversal = void 0;
    var css_what_1 = require_commonjs8();
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal(token) {
      return !procedure.has(token.type);
    }
    exports2.isTraversal = isTraversal;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports2.default = sortByProcedure;
    function getProcedure(token) {
      var _a, _b;
      var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d) {
            return Math.min.apply(Math, d.map(getProcedure));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports2.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports2.parse = parse;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = exports2.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return boolbase_1.default.falseFunc;
      if (a === -1)
        return function(index) {
          return index <= b;
        };
      if (a === 0)
        return function(index) {
          return index === b;
        };
      if (a === 1)
        return b < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b;
        };
      var absA = Math.abs(a);
      var bMod = (b % absA + absA) % absA;
      return a > 1 ? function(index) {
        return index >= b && index % absA === bMod;
      } : function(index) {
        return index <= b && index % absA === bMod;
      };
    }
    exports2.compile = compile;
    function generate(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      var n = 0;
      if (a < 0) {
        var aPos_1 = -a;
        var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n++;
          return val > b ? null : val;
        };
      }
      if (a === 0)
        return b < 0 ? (
          // There are no result  always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n++ === 0 ? b : null;
          }
        );
      if (b < 0) {
        b += a * Math.ceil(-b / a);
      }
      return function() {
        return a * n++ + b;
      };
    }
    exports2.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequence = exports2.generate = exports2.compile = exports2.parse = void 0;
    var parse_js_1 = require_parse3();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports2, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports2.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports2.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filters = void 0;
    var nth_check_1 = __importDefault(require_lib6());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports2.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports2.filters["root"](next, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyPseudoArgs = exports2.pseudos = void 0;
    exports2.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (equals(elem, siblings[i]))
            return true;
          if (adapter.isTag(siblings[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports2.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = void 0;
    exports2.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports2.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports2.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports2.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is = function(next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports2.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function(next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context = subselect.some(function(s) {
          return s.some(sort_js_1.isTraversal);
        }) ? (
          // Used as a placeholder. Will be replaced with the actual element.
          [exports2.PLACEHOLDER_ELEMENT]
        ) : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context && compiled !== boolbase_1.default.trueFunc) {
          var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
          return function(elem) {
            if (!next(elem))
              return false;
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
    var css_what_1 = require_commonjs8();
    var filters_js_1 = require_filters();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context, compileToken) {
      var _a;
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
        }
        return subselects_js_1.subselects[name](next, data, options, context, compileToken);
      }
      var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
        return function(elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next, data, options, context);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
        return function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports2.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = require_commonjs8();
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(next, selector, options, context, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        // Tags
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        // Traversal
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent(current, adapter)) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current))
                return true;
            } while (current = getElementParent(current, adapter));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports2.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileToken = exports2.compileUnsafe = exports2.compile = void 0;
    var css_what_1 = require_commonjs8();
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports2.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context);
    }
    exports2.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t) {
      return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context) {
      var adapter = _a.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t.some(includesScopePseudo)) {
          t.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a;
      token.forEach(sort_js_1.default);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (token.some(function(t) {
        return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports2.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
    }
    function reduceRules(a, b) {
      if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
        return a;
      }
      if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function(a, b) {
      return a === b;
    };
    var defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports2.compile = wrapCompile(compile_js_1.compile);
    exports2._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports2._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports2.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports2.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports2.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports2.is = is;
    exports2.default = exports2.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/node-html-parser/dist/back.js
var require_back = __commonJS({
  "node_modules/node-html-parser/dist/back.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function arr_back(arr) {
      return arr[arr.length - 1];
    }
    exports2.default = arr_back;
  }
});

// node_modules/node-html-parser/dist/matcher.js
var require_matcher = __commonJS({
  "node_modules/node-html-parser/dist/matcher.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var type_1 = __importDefault(require_type());
    function isTag(node) {
      return node && node.nodeType === type_1.default.ELEMENT_NODE;
    }
    function getAttributeValue(elem, name) {
      return isTag(elem) ? elem.getAttribute(name) : void 0;
    }
    function getName(elem) {
      return (elem && elem.rawTagName || "").toLowerCase();
    }
    function getChildren(node) {
      return node && node.childNodes;
    }
    function getParent(node) {
      return node ? node.parentNode : null;
    }
    function getText(node) {
      return node.text;
    }
    function removeSubsets(nodes) {
      let idx = nodes.length;
      let node;
      let ancestor;
      let replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    }
    function existsOne(test, elems) {
      return elems.some((elem) => {
        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
      });
    }
    function getSiblings(node) {
      const parent = getParent(node);
      return parent ? getChildren(parent) : [];
    }
    function hasAttrib(elem, name) {
      return getAttributeValue(elem, name) !== void 0;
    }
    function findOne(test, elems) {
      let elem = null;
      for (let i = 0, l = elems === null || elems === void 0 ? void 0 : elems.length; i < l && !elem; i++) {
        const el = elems[i];
        if (test(el)) {
          elem = el;
        } else {
          const childs = getChildren(el);
          if (childs && childs.length > 0) {
            elem = findOne(test, childs);
          }
        }
      }
      return elem;
    }
    function findAll(test, nodes) {
      let result = [];
      for (let i = 0, j = nodes.length; i < j; i++) {
        if (!isTag(nodes[i]))
          continue;
        if (test(nodes[i]))
          result.push(nodes[i]);
        const childs = getChildren(nodes[i]);
        if (childs)
          result = result.concat(findAll(test, childs));
      }
      return result;
    }
    exports2.default = {
      isTag,
      getAttributeValue,
      getName,
      getChildren,
      getParent,
      getText,
      removeSubsets,
      existsOne,
      getSiblings,
      hasAttrib,
      findOne,
      findAll
    };
  }
});

// node_modules/node-html-parser/dist/void-tag.js
var require_void_tag = __commonJS({
  "node_modules/node-html-parser/dist/void-tag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var VoidTag = class {
      constructor(addClosingSlash = false, tags) {
        this.addClosingSlash = addClosingSlash;
        if (Array.isArray(tags)) {
          this.voidTags = tags.reduce((set, tag) => {
            return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
          }, /* @__PURE__ */ new Set());
        } else {
          this.voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].reduce((set, tag) => {
            return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
          }, /* @__PURE__ */ new Set());
        }
      }
      formatNode(tag, attrs, innerHTML) {
        const addClosingSlash = this.addClosingSlash;
        const closingSpace = addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
        const closingSlash = addClosingSlash ? `${closingSpace}/` : "";
        return this.isVoidElement(tag.toLowerCase()) ? `<${tag}${attrs}${closingSlash}>` : `<${tag}${attrs}>${innerHTML}</${tag}>`;
      }
      isVoidElement(tag) {
        return this.voidTags.has(tag);
      }
    };
    exports2.default = VoidTag;
  }
});

// node_modules/node-html-parser/dist/nodes/text.js
var require_text = __commonJS({
  "node_modules/node-html-parser/dist/nodes/text.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var he_1 = require_he();
    var node_12 = __importDefault(require_node5());
    var type_1 = __importDefault(require_type());
    var TextNode = class _TextNode extends node_12.default {
      clone() {
        return new _TextNode(this._rawText, null);
      }
      constructor(rawText, parentNode = null, range) {
        super(parentNode, range);
        this.nodeType = type_1.default.TEXT_NODE;
        this.rawTagName = "";
        this._rawText = rawText;
      }
      get rawText() {
        return this._rawText;
      }
      /**
       * Set rawText and invalidate trimmed caches
       */
      set rawText(text) {
        this._rawText = text;
        this._trimmedRawText = void 0;
        this._trimmedText = void 0;
      }
      /**
       * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space
       */
      get trimmedRawText() {
        if (this._trimmedRawText !== void 0)
          return this._trimmedRawText;
        this._trimmedRawText = trimText(this.rawText);
        return this._trimmedRawText;
      }
      /**
       * Returns text with all whitespace trimmed except single leading/trailing non-breaking space
       */
      get trimmedText() {
        if (this._trimmedText !== void 0)
          return this._trimmedText;
        this._trimmedText = trimText(this.text);
        return this._trimmedText;
      }
      /**
       * Get unescaped text value of current node and its children.
       * @return {string} text content
       */
      get text() {
        return (0, he_1.decode)(this.rawText);
      }
      /**
       * Detect if the node contains only white space.
       * @return {boolean}
       */
      get isWhitespace() {
        return /^(\s|&nbsp;)*$/.test(this.rawText);
      }
      toString() {
        return this.rawText;
      }
    };
    exports2.default = TextNode;
    function trimText(text) {
      let i = 0;
      let startPos;
      let endPos;
      while (i >= 0 && i < text.length) {
        if (/\S/.test(text[i])) {
          if (startPos === void 0) {
            startPos = i;
            i = text.length;
          } else {
            endPos = i;
            i = void 0;
          }
        }
        if (startPos === void 0)
          i++;
        else
          i--;
      }
      if (startPos === void 0)
        startPos = 0;
      if (endPos === void 0)
        endPos = text.length - 1;
      const hasLeadingSpace = startPos > 0 && /[^\S\r\n]/.test(text[startPos - 1]);
      const hasTrailingSpace = endPos < text.length - 1 && /[^\S\r\n]/.test(text[endPos + 1]);
      return (hasLeadingSpace ? " " : "") + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? " " : "");
    }
  }
});

// node_modules/node-html-parser/dist/nodes/html.js
var require_html = __commonJS({
  "node_modules/node-html-parser/dist/nodes/html.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.base_parse = void 0;
    var css_select_1 = require_lib7();
    var he_1 = __importDefault(require_he());
    var back_1 = __importDefault(require_back());
    var matcher_1 = __importDefault(require_matcher());
    var void_tag_1 = __importDefault(require_void_tag());
    var comment_1 = __importDefault(require_comment());
    var node_12 = __importDefault(require_node5());
    var text_1 = __importDefault(require_text());
    var type_1 = __importDefault(require_type());
    function decode(val) {
      return JSON.parse(JSON.stringify(he_1.default.decode(val)));
    }
    var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
    var Dtags = ["details", "dialog", "dd", "div", "dt"];
    var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
    var tableTags = ["table", "td", "tr"];
    var htmlTags = ["address", "article", "aside", "blockquote", "br", "hr", "li", "main", "nav", "ol", "p", "pre", "section", "ul"];
    var kBlockElements = /* @__PURE__ */ new Set();
    function addToKBlockElement(...args) {
      const addToSet = (array) => {
        for (let index = 0; index < array.length; index++) {
          const element = array[index];
          kBlockElements.add(element);
          kBlockElements.add(element.toUpperCase());
        }
      };
      for (const arg of args)
        addToSet(arg);
    }
    addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
    var DOMTokenList = class {
      _validate(c) {
        if (/\s/.test(c)) {
          throw new Error(`DOMException in DOMTokenList.add: The token '${c}' contains HTML space characters, which are not valid in tokens.`);
        }
      }
      constructor(valuesInit = [], afterUpdate = () => null) {
        this._set = new Set(valuesInit);
        this._afterUpdate = afterUpdate;
      }
      add(c) {
        this._validate(c);
        this._set.add(c);
        this._afterUpdate(this);
      }
      replace(c1, c2) {
        this._validate(c2);
        this._set.delete(c1);
        this._set.add(c2);
        this._afterUpdate(this);
      }
      remove(c) {
        this._set.delete(c) && this._afterUpdate(this);
      }
      toggle(c) {
        this._validate(c);
        if (this._set.has(c))
          this._set.delete(c);
        else
          this._set.add(c);
        this._afterUpdate(this);
      }
      contains(c) {
        return this._set.has(c);
      }
      get length() {
        return this._set.size;
      }
      values() {
        return this._set.values();
      }
      get value() {
        return Array.from(this._set.values());
      }
      toString() {
        return Array.from(this._set.values()).join(" ");
      }
    };
    var HTMLElement = class _HTMLElement extends node_12.default {
      /**
       * Quote attribute values
       * @param attr attribute value
       * @returns {string} quoted value
       */
      quoteAttribute(attr) {
        if (attr == null) {
          return "null";
        }
        return JSON.stringify(attr.replace(/"/g, "&quot;")).replace(/\\t/g, "	").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\/g, "");
      }
      /**
       * Creates an instance of HTMLElement.
       * @param keyAttrs	id and class attribute
       * @param [rawAttrs]	attributes in string
       *
       * @memberof HTMLElement
       */
      constructor(tagName, keyAttrs, rawAttrs = "", parentNode = null, range, voidTag = new void_tag_1.default(), _parseOptions = {}) {
        super(parentNode, range);
        this.rawAttrs = rawAttrs;
        this.voidTag = voidTag;
        this.nodeType = type_1.default.ELEMENT_NODE;
        this.rawTagName = tagName;
        this.rawAttrs = rawAttrs || "";
        this._id = keyAttrs.id || "";
        this.childNodes = [];
        this._parseOptions = _parseOptions;
        this.classList = new DOMTokenList(
          keyAttrs.class ? keyAttrs.class.split(/\s+/) : [],
          (classList) => this.setAttribute("class", classList.toString())
          // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
        );
        if (keyAttrs.id) {
          if (!rawAttrs) {
            this.rawAttrs = `id="${keyAttrs.id}"`;
          }
        }
        if (keyAttrs.class) {
          if (!rawAttrs) {
            const cls = `class="${this.classList.toString()}"`;
            if (this.rawAttrs) {
              this.rawAttrs += ` ${cls}`;
            } else {
              this.rawAttrs = cls;
            }
          }
        }
      }
      /**
       * Remove Child element from childNodes array
       * @param {HTMLElement} node     node to remove
       */
      removeChild(node) {
        this.childNodes = this.childNodes.filter((child) => {
          return child !== node;
        });
        return this;
      }
      /**
       * Exchanges given child with new child
       * @param {HTMLElement} oldNode     node to exchange
       * @param {HTMLElement} newNode     new node
       */
      exchangeChild(oldNode, newNode) {
        const children = this.childNodes;
        this.childNodes = children.map((child) => {
          if (child === oldNode) {
            return newNode;
          }
          return child;
        });
        return this;
      }
      get tagName() {
        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
      }
      set tagName(newname) {
        this.rawTagName = newname.toLowerCase();
      }
      get localName() {
        return this.rawTagName.toLowerCase();
      }
      get isVoidElement() {
        return this.voidTag.isVoidElement(this.localName);
      }
      get id() {
        return this._id;
      }
      set id(newid) {
        this.setAttribute("id", newid);
      }
      /**
       * Get escpaed (as-it) text value of current node and its children.
       * @return {string} text content
       */
      get rawText() {
        if (/^br$/i.test(this.rawTagName)) {
          return "\n";
        }
        return this.childNodes.reduce((pre, cur) => {
          return pre += cur.rawText;
        }, "");
      }
      get textContent() {
        return decode(this.rawText);
      }
      set textContent(val) {
        const content = [new text_1.default(val, this)];
        this.childNodes = content;
      }
      /**
       * Get unescaped text value of current node and its children.
       * @return {string} text content
       */
      get text() {
        return decode(this.rawText);
      }
      /**
       * Get structured Text (with '\n' etc.)
       * @return {string} structured text
       */
      get structuredText() {
        let currentBlock = [];
        const blocks = [currentBlock];
        function dfs(node) {
          if (node.nodeType === type_1.default.ELEMENT_NODE) {
            if (kBlockElements.has(node.rawTagName)) {
              if (currentBlock.length > 0) {
                blocks.push(currentBlock = []);
              }
              node.childNodes.forEach(dfs);
              if (currentBlock.length > 0) {
                blocks.push(currentBlock = []);
              }
            } else {
              node.childNodes.forEach(dfs);
            }
          } else if (node.nodeType === type_1.default.TEXT_NODE) {
            if (node.isWhitespace) {
              currentBlock.prependWhitespace = true;
            } else {
              let text = node.trimmedText;
              if (currentBlock.prependWhitespace) {
                text = ` ${text}`;
                currentBlock.prependWhitespace = false;
              }
              currentBlock.push(text);
            }
          }
        }
        dfs(this);
        return blocks.map((block) => {
          return block.join("").replace(/\s{2,}/g, " ");
        }).join("\n").replace(/\s+$/, "");
      }
      toString() {
        const tag = this.rawTagName;
        if (tag) {
          const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : "";
          return this.voidTag.formatNode(tag, attrs, this.innerHTML);
        }
        return this.innerHTML;
      }
      get innerHTML() {
        return this.childNodes.map((child) => {
          return child.toString();
        }).join("");
      }
      set innerHTML(content) {
        const r = parse(content, this._parseOptions);
        const nodes = r.childNodes.length ? r.childNodes : [new text_1.default(content, this)];
        resetParent(nodes, this);
        resetParent(this.childNodes, null);
        this.childNodes = nodes;
      }
      set_content(content, options = {}) {
        if (content instanceof node_12.default) {
          content = [content];
        } else if (typeof content == "string") {
          options = Object.assign(Object.assign({}, this._parseOptions), options);
          const r = parse(content, options);
          content = r.childNodes.length ? r.childNodes : [new text_1.default(r.innerHTML, this)];
        }
        resetParent(this.childNodes, null);
        resetParent(content, this);
        this.childNodes = content;
        return this;
      }
      replaceWith(...nodes) {
        const parent = this.parentNode;
        const content = nodes.map((node) => {
          if (node instanceof node_12.default) {
            return [node];
          } else if (typeof node == "string") {
            const r = parse(node, this._parseOptions);
            return r.childNodes.length ? r.childNodes : [new text_1.default(node, this)];
          }
          return [];
        }).flat();
        const idx = parent.childNodes.findIndex((child) => {
          return child === this;
        });
        resetParent([this], null);
        parent.childNodes = [...parent.childNodes.slice(0, idx), ...resetParent(content, parent), ...parent.childNodes.slice(idx + 1)];
        return this;
      }
      get outerHTML() {
        return this.toString();
      }
      /**
       * Trim element from right (in block) after seeing pattern in a TextNode.
       * @param  {RegExp} pattern pattern to find
       * @return {HTMLElement}    reference to current node
       */
      trimRight(pattern) {
        for (let i = 0; i < this.childNodes.length; i++) {
          const childNode = this.childNodes[i];
          if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
            childNode.trimRight(pattern);
          } else {
            const index = childNode.rawText.search(pattern);
            if (index > -1) {
              childNode.rawText = childNode.rawText.substr(0, index);
              this.childNodes.length = i + 1;
            }
          }
        }
        return this;
      }
      /**
       * Get DOM structure
       * @return {string} structure
       */
      get structure() {
        const res = [];
        let indention = 0;
        function write(str) {
          res.push("  ".repeat(indention) + str);
        }
        function dfs(node) {
          const idStr = node._id ? `#${node._id}` : "";
          const classStr = node.classList.length ? `.${node.classList.value.join(".")}` : "";
          write(`${node.rawTagName}${idStr}${classStr}`);
          indention++;
          node.childNodes.forEach((childNode) => {
            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
              dfs(childNode);
            } else if (childNode.nodeType === type_1.default.TEXT_NODE) {
              if (!childNode.isWhitespace) {
                write("#text");
              }
            }
          });
          indention--;
        }
        dfs(this);
        return res.join("\n");
      }
      /**
       * Remove whitespaces in this sub tree.
       * @return {HTMLElement} pointer to this
       */
      removeWhitespace() {
        let o = 0;
        this.childNodes.forEach((node) => {
          if (node.nodeType === type_1.default.TEXT_NODE) {
            if (node.isWhitespace) {
              return;
            }
            node.rawText = node.trimmedRawText;
          } else if (node.nodeType === type_1.default.ELEMENT_NODE) {
            node.removeWhitespace();
          }
          this.childNodes[o++] = node;
        });
        this.childNodes.length = o;
        const attrs = Object.keys(this.rawAttributes).map((key) => {
          const val = this.rawAttributes[key];
          return `${key}=${JSON.stringify(val)}`;
        }).join(" ");
        this.rawAttrs = attrs;
        delete this._rawAttrs;
        return this;
      }
      /**
       * Query CSS selector to find matching nodes.
       * @param  {string}         selector Simplified CSS selector
       * @return {HTMLElement[]}  matching elements
       */
      querySelectorAll(selector) {
        return (0, css_select_1.selectAll)(selector, this, {
          xmlMode: true,
          adapter: matcher_1.default
        });
      }
      /**
       * Query CSS Selector to find matching node.
       * @param  {string}         selector Simplified CSS selector
       * @return {(HTMLElement|null)}    matching node
       */
      querySelector(selector) {
        return (0, css_select_1.selectOne)(selector, this, {
          xmlMode: true,
          adapter: matcher_1.default
        });
      }
      /**
       * find elements by their tagName
       * @param {string} tagName the tagName of the elements to select
       */
      getElementsByTagName(tagName) {
        const upperCasedTagName = tagName.toUpperCase();
        const re = [];
        const stack = [];
        let currentNodeReference = this;
        let index = 0;
        while (index !== void 0) {
          let child;
          do {
            child = currentNodeReference.childNodes[index++];
          } while (index < currentNodeReference.childNodes.length && child === void 0);
          if (child === void 0) {
            currentNodeReference = currentNodeReference.parentNode;
            index = stack.pop();
            continue;
          }
          if (child.nodeType === type_1.default.ELEMENT_NODE) {
            if (tagName === "*" || child.tagName === upperCasedTagName)
              re.push(child);
            if (child.childNodes.length > 0) {
              stack.push(index);
              currentNodeReference = child;
              index = 0;
            }
          }
        }
        return re;
      }
      /**
       * find element by it's id
       * @param {string} id the id of the element to select
       * @returns {HTMLElement | null} the element with the given id or null if not found
       */
      getElementById(id) {
        const stack = [];
        let currentNodeReference = this;
        let index = 0;
        while (index !== void 0) {
          let child;
          do {
            child = currentNodeReference.childNodes[index++];
          } while (index < currentNodeReference.childNodes.length && child === void 0);
          if (child === void 0) {
            currentNodeReference = currentNodeReference.parentNode;
            index = stack.pop();
            continue;
          }
          if (child.nodeType === type_1.default.ELEMENT_NODE) {
            if (child._id === id) {
              return child;
            }
            if (child.childNodes.length > 0) {
              stack.push(index);
              currentNodeReference = child;
              index = 0;
            }
          }
        }
        return null;
      }
      /**
       * traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.
       * @param selector a DOMString containing a selector list
       * @returns {HTMLElement | null} the element with the given id or null if not found
       */
      closest(selector) {
        const mapChild = /* @__PURE__ */ new Map();
        let el = this;
        let old = null;
        function findOne(test, elems) {
          let elem = null;
          for (let i = 0, l = elems.length; i < l && !elem; i++) {
            const el2 = elems[i];
            if (test(el2)) {
              elem = el2;
            } else {
              const child = mapChild.get(el2);
              if (child) {
                elem = findOne(test, [child]);
              }
            }
          }
          return elem;
        }
        while (el) {
          mapChild.set(el, old);
          old = el;
          el = el.parentNode;
        }
        el = this;
        while (el) {
          const e = (0, css_select_1.selectOne)(selector, el, {
            xmlMode: true,
            adapter: Object.assign(Object.assign({}, matcher_1.default), {
              getChildren(node) {
                const child = mapChild.get(node);
                return child && [child];
              },
              getSiblings(node) {
                return [node];
              },
              findOne,
              findAll() {
                return [];
              }
            })
          });
          if (e) {
            return e;
          }
          el = el.parentNode;
        }
        return null;
      }
      /**
       * Append a child node to childNodes
       * @param  {Node} node node to append
       * @return {Node}      node appended
       */
      appendChild(node) {
        this.append(node);
        return node;
      }
      /**
       * Get attributes
       * @access private
       * @return {Object} parsed and unescaped attributes
       */
      get attrs() {
        if (this._attrs) {
          return this._attrs;
        }
        this._attrs = {};
        const attrs = this.rawAttributes;
        for (const key in attrs) {
          const val = attrs[key] || "";
          this._attrs[key.toLowerCase()] = decode(val);
        }
        return this._attrs;
      }
      get attributes() {
        const ret_attrs = {};
        const attrs = this.rawAttributes;
        for (const key in attrs) {
          const val = attrs[key] || "";
          ret_attrs[key] = decode(val);
        }
        return ret_attrs;
      }
      /**
       * Get escaped (as-is) attributes
       * @return {Object} parsed attributes
       */
      get rawAttributes() {
        if (this._rawAttrs) {
          return this._rawAttrs;
        }
        const attrs = {};
        if (this.rawAttrs) {
          const re = /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-._:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
          let match;
          while (match = re.exec(this.rawAttrs)) {
            const key = match[1];
            let val = match[2] || null;
            if (val && (val[0] === `'` || val[0] === `"`))
              val = val.slice(1, val.length - 1);
            attrs[key] = attrs[key] || val;
          }
        }
        this._rawAttrs = attrs;
        return attrs;
      }
      removeAttribute(key) {
        const attrs = this.rawAttributes;
        delete attrs[key];
        if (this._attrs) {
          delete this._attrs[key];
        }
        this.rawAttrs = Object.keys(attrs).map((name) => {
          const val = this.quoteAttribute(attrs[name]);
          if (val === "null" || val === '""')
            return name;
          return `${name}=${val}`;
        }).join(" ");
        if (key === "id") {
          this._id = "";
        }
        return this;
      }
      hasAttribute(key) {
        return key.toLowerCase() in this.attrs;
      }
      /**
       * Get an attribute
       * @return {string | undefined} value of the attribute; or undefined if not exist
       */
      getAttribute(key) {
        return this.attrs[key.toLowerCase()];
      }
      /**
       * Set an attribute value to the HTMLElement
       * @param {string} key The attribute name
       * @param {string} value The value to set, or null / undefined to remove an attribute
       */
      setAttribute(key, value) {
        if (arguments.length < 2) {
          throw new Error("Failed to execute 'setAttribute' on 'Element'");
        }
        const k2 = key.toLowerCase();
        const attrs = this.rawAttributes;
        for (const k in attrs) {
          if (k.toLowerCase() === k2) {
            key = k;
            break;
          }
        }
        attrs[key] = String(value);
        if (this._attrs) {
          this._attrs[k2] = decode(attrs[key]);
        }
        this.rawAttrs = Object.keys(attrs).map((name) => {
          const val = this.quoteAttribute(attrs[name]);
          if (val === "null" || val === '""')
            return name;
          return `${name}=${val}`;
        }).join(" ");
        if (key === "id") {
          this._id = value;
        }
        return this;
      }
      /**
       * Replace all the attributes of the HTMLElement by the provided attributes
       * @param {Attributes} attributes the new attribute set
       */
      setAttributes(attributes) {
        if (this._attrs) {
          delete this._attrs;
        }
        if (this._rawAttrs) {
          delete this._rawAttrs;
        }
        this.rawAttrs = Object.keys(attributes).map((name) => {
          const val = attributes[name];
          if (val === "null" || val === '""')
            return name;
          return `${name}=${this.quoteAttribute(String(val))}`;
        }).join(" ");
        if ("id" in attributes) {
          this._id = attributes["id"];
        }
        return this;
      }
      insertAdjacentHTML(where, html) {
        if (arguments.length < 2) {
          throw new Error("2 arguments required");
        }
        const p = parse(html, this._parseOptions);
        if (where === "afterend") {
          this.after(...p.childNodes);
        } else if (where === "afterbegin") {
          this.prepend(...p.childNodes);
        } else if (where === "beforeend") {
          this.append(...p.childNodes);
        } else if (where === "beforebegin") {
          this.before(...p.childNodes);
        } else {
          throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);
        }
        return this;
      }
      /** Prepend nodes or strings to this node's children. */
      prepend(...insertable) {
        const nodes = resolveInsertable(insertable);
        resetParent(nodes, this);
        this.childNodes.unshift(...nodes);
      }
      /** Append nodes or strings to this node's children. */
      append(...insertable) {
        const nodes = resolveInsertable(insertable);
        resetParent(nodes, this);
        this.childNodes.push(...nodes);
      }
      /** Insert nodes or strings before this node. */
      before(...insertable) {
        const nodes = resolveInsertable(insertable);
        const siblings = this.parentNode.childNodes;
        resetParent(nodes, this.parentNode);
        siblings.splice(siblings.indexOf(this), 0, ...nodes);
      }
      /** Insert nodes or strings after this node. */
      after(...insertable) {
        const nodes = resolveInsertable(insertable);
        const siblings = this.parentNode.childNodes;
        resetParent(nodes, this.parentNode);
        siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);
      }
      get nextSibling() {
        if (this.parentNode) {
          const children = this.parentNode.childNodes;
          let i = 0;
          while (i < children.length) {
            const child = children[i++];
            if (this === child)
              return children[i] || null;
          }
          return null;
        }
      }
      get nextElementSibling() {
        if (this.parentNode) {
          const children = this.parentNode.childNodes;
          let i = 0;
          let find = false;
          while (i < children.length) {
            const child = children[i++];
            if (find) {
              if (child instanceof _HTMLElement) {
                return child || null;
              }
            } else if (this === child) {
              find = true;
            }
          }
          return null;
        }
      }
      get previousSibling() {
        if (this.parentNode) {
          const children = this.parentNode.childNodes;
          let i = children.length;
          while (i > 0) {
            const child = children[--i];
            if (this === child)
              return children[i - 1] || null;
          }
          return null;
        }
      }
      get previousElementSibling() {
        if (this.parentNode) {
          const children = this.parentNode.childNodes;
          let i = children.length;
          let find = false;
          while (i > 0) {
            const child = children[--i];
            if (find) {
              if (child instanceof _HTMLElement) {
                return child || null;
              }
            } else if (this === child) {
              find = true;
            }
          }
          return null;
        }
      }
      /** Get all childNodes of type {@link HTMLElement}. */
      get children() {
        const children = [];
        for (const childNode of this.childNodes) {
          if (childNode instanceof _HTMLElement) {
            children.push(childNode);
          }
        }
        return children;
      }
      /**
       * Get the first child node.
       * @return The first child or undefined if none exists.
       */
      get firstChild() {
        return this.childNodes[0];
      }
      /**
       * Get the first child node of type {@link HTMLElement}.
       * @return The first child element or undefined if none exists.
       */
      get firstElementChild() {
        return this.children[0];
      }
      /**
       * Get the last child node.
       * @return The last child or undefined if none exists.
       */
      get lastChild() {
        return (0, back_1.default)(this.childNodes);
      }
      /**
       * Get the last child node of type {@link HTMLElement}.
       * @return The last child element or undefined if none exists.
       */
      get lastElementChild() {
        return this.children[this.children.length - 1];
      }
      get childElementCount() {
        return this.children.length;
      }
      get classNames() {
        return this.classList.toString();
      }
      /** Clone this Node */
      clone() {
        return parse(this.toString(), this._parseOptions).firstChild;
      }
    };
    exports2.default = HTMLElement;
    var kMarkupPattern = /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z@\xB7\xC0-\xD6\xD8-\xF6\u00F8-\u03A1\u03A3-\u03D9\u03DB-\u03EF\u03F7-\u03FF\u0400-\u04FF\u0500-\u052F\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E00-\u1E9B\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A-\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA78E\uA790-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64-\uAB65\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\x37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/gu;
    var kAttributePattern = /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
    var kElementsClosedByOpening = {
      li: { li: true, LI: true },
      LI: { li: true, LI: true },
      p: { p: true, div: true, P: true, DIV: true },
      P: { p: true, div: true, P: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      td: { td: true, th: true, TD: true, TH: true },
      TD: { td: true, th: true, TD: true, TH: true },
      th: { td: true, th: true, TD: true, TH: true },
      TH: { td: true, th: true, TD: true, TH: true },
      h1: { h1: true, H1: true },
      H1: { h1: true, H1: true },
      h2: { h2: true, H2: true },
      H2: { h2: true, H2: true },
      h3: { h3: true, H3: true },
      H3: { h3: true, H3: true },
      h4: { h4: true, H4: true },
      H4: { h4: true, H4: true },
      h5: { h5: true, H5: true },
      H5: { h5: true, H5: true },
      h6: { h6: true, H6: true },
      H6: { h6: true, H6: true }
    };
    var kElementsClosedByClosing = {
      li: { ul: true, ol: true, UL: true, OL: true },
      LI: { ul: true, ol: true, UL: true, OL: true },
      a: { div: true, DIV: true },
      A: { div: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      i: { div: true, DIV: true },
      I: { div: true, DIV: true },
      p: { div: true, DIV: true },
      P: { div: true, DIV: true },
      td: { tr: true, table: true, TR: true, TABLE: true },
      TD: { tr: true, table: true, TR: true, TABLE: true },
      th: { tr: true, table: true, TR: true, TABLE: true },
      TH: { tr: true, table: true, TR: true, TABLE: true }
    };
    var kElementsClosedByClosingExcept = {
      p: { a: true, audio: true, del: true, ins: true, map: true, noscript: true, video: true }
    };
    var frameflag = "documentfragmentcontainer";
    function base_parse(data, options = {}) {
      var _a, _b;
      const voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);
      const elements = options.blockTextElements || {
        script: true,
        noscript: true,
        style: true,
        pre: true
      };
      const element_names = Object.keys(elements);
      const kBlockTextElements = element_names.map((it) => new RegExp(`^${it}$`, "i"));
      const kIgnoreElements = element_names.filter((it) => Boolean(elements[it])).map((it) => new RegExp(`^${it}$`, "i"));
      function element_should_be_ignore(tag) {
        return kIgnoreElements.some((it) => it.test(tag));
      }
      function is_block_text_element(tag) {
        return kBlockTextElements.some((it) => it.test(tag));
      }
      const createRange = (startPos, endPos) => [startPos - frameFlagOffset, endPos - frameFlagOffset];
      const root = new HTMLElement(null, {}, "", null, [0, data.length], voidTag, options);
      let currentParent = root;
      const stack = [root];
      let lastTextPos = -1;
      let noNestedTagIndex = void 0;
      let match;
      data = `<${frameflag}>${data}</${frameflag}>`;
      const { lowerCaseTagName, fixNestedATags } = options;
      const dataEndPos = data.length - (frameflag.length + 2);
      const frameFlagOffset = frameflag.length + 2;
      while (match = kMarkupPattern.exec(data)) {
        let { 0: matchText, 1: leadingSlash, 2: tagName, 3: attributes, 4: closingSlash } = match;
        const matchLength = matchText.length;
        const tagStartPos = kMarkupPattern.lastIndex - matchLength;
        const tagEndPos = kMarkupPattern.lastIndex;
        if (lastTextPos > -1) {
          if (lastTextPos + matchLength < tagEndPos) {
            const text = data.substring(lastTextPos, tagStartPos);
            currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));
          }
        }
        lastTextPos = kMarkupPattern.lastIndex;
        if (tagName === frameflag)
          continue;
        if (matchText[1] === "!") {
          if (options.comment) {
            const text = data.substring(tagStartPos + 4, tagEndPos - 3);
            currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));
          }
          continue;
        }
        if (lowerCaseTagName)
          tagName = tagName.toLowerCase();
        if (!leadingSlash) {
          const attrs = {};
          for (let attMatch; attMatch = kAttributePattern.exec(attributes); ) {
            const { 1: key, 2: val } = attMatch;
            const isQuoted = val[0] === `'` || val[0] === `"`;
            attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;
          }
          const parentTagName = currentParent.rawTagName;
          if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
            if (kElementsClosedByOpening[parentTagName][tagName]) {
              stack.pop();
              currentParent = (0, back_1.default)(stack);
            }
          }
          if (fixNestedATags && (tagName === "a" || tagName === "A")) {
            if (noNestedTagIndex !== void 0) {
              stack.splice(noNestedTagIndex);
              currentParent = (0, back_1.default)(stack);
            }
            noNestedTagIndex = stack.length;
          }
          const tagEndPos2 = kMarkupPattern.lastIndex;
          const tagStartPos2 = tagEndPos2 - matchLength;
          currentParent = currentParent.appendChild(
            // Initialize range (end position updated later for closed tags)
            new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos2, tagEndPos2), voidTag, options)
          );
          stack.push(currentParent);
          if (is_block_text_element(tagName)) {
            const closeMarkup = `</${tagName}>`;
            const closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);
            const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
            if (element_should_be_ignore(tagName)) {
              const text = data.substring(tagEndPos2, textEndPos);
              if (text.length > 0 && /\S/.test(text)) {
                currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos2, textEndPos)));
              }
            }
            if (closeIndex === -1) {
              lastTextPos = kMarkupPattern.lastIndex = data.length + 1;
            } else {
              lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;
              leadingSlash = "/";
            }
          }
        }
        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
          while (true) {
            if (noNestedTagIndex != null && (tagName === "a" || tagName === "A"))
              noNestedTagIndex = void 0;
            if (currentParent.rawTagName === tagName) {
              currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
              stack.pop();
              currentParent = (0, back_1.default)(stack);
              break;
            } else {
              const parentTagName = currentParent.tagName;
              if (kElementsClosedByClosing[parentTagName]) {
                if (kElementsClosedByClosing[parentTagName][tagName]) {
                  stack.pop();
                  currentParent = (0, back_1.default)(stack);
                  continue;
                }
              }
              const openTag = currentParent.rawTagName ? currentParent.rawTagName.toLowerCase() : "";
              if (kElementsClosedByClosingExcept[openTag]) {
                const closingTag = tagName.toLowerCase();
                if (stack.length > 1) {
                  const possibleContainer = stack[stack.length - 2];
                  if (possibleContainer && possibleContainer.rawTagName && possibleContainer.rawTagName.toLowerCase() === closingTag && !kElementsClosedByClosingExcept[openTag][closingTag]) {
                    currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
                    stack.pop();
                    currentParent = (0, back_1.default)(stack);
                    continue;
                  }
                }
              }
              break;
            }
          }
        }
      }
      return stack;
    }
    exports2.base_parse = base_parse;
    function parse(data, options = {}) {
      const stack = base_parse(data, options);
      const [root] = stack;
      while (stack.length > 1) {
        const last = stack.pop();
        const oneBefore = (0, back_1.default)(stack);
        if (last.parentNode && last.parentNode.parentNode) {
          if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach((child) => {
                oneBefore.parentNode.appendChild(child);
              });
              stack.pop();
            }
          } else {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach((child) => {
                oneBefore.appendChild(child);
              });
            }
          }
        } else {
        }
      }
      return root;
    }
    exports2.parse = parse;
    function resolveInsertable(insertable) {
      return insertable.map((val) => {
        if (typeof val === "string") {
          return new text_1.default(val);
        }
        val.remove();
        return val;
      });
    }
    function resetParent(nodes, parent) {
      return nodes.map((node) => {
        node.parentNode = parent;
        return node;
      });
    }
  }
});

// node_modules/node-html-parser/dist/parse.js
var require_parse4 = __commonJS({
  "node_modules/node-html-parser/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = void 0;
    var html_1 = require_html();
    Object.defineProperty(exports2, "default", { enumerable: true, get: function() {
      return html_1.parse;
    } });
  }
});

// node_modules/node-html-parser/dist/valid.js
var require_valid = __commonJS({
  "node_modules/node-html-parser/dist/valid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var html_1 = require_html();
    function valid(data, options = {}) {
      const stack = (0, html_1.base_parse)(data, options);
      return Boolean(stack.length === 1);
    }
    exports2.default = valid;
  }
});

// node_modules/node-html-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-html-parser/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeType = exports2.TextNode = exports2.Node = exports2.valid = exports2.CommentNode = exports2.HTMLElement = exports2.parse = void 0;
    var comment_1 = __importDefault(require_comment());
    exports2.CommentNode = comment_1.default;
    var html_1 = __importDefault(require_html());
    exports2.HTMLElement = html_1.default;
    var node_12 = __importDefault(require_node5());
    exports2.Node = node_12.default;
    var text_1 = __importDefault(require_text());
    exports2.TextNode = text_1.default;
    var type_1 = __importDefault(require_type());
    exports2.NodeType = type_1.default;
    var parse_1 = __importDefault(require_parse4());
    var valid_1 = __importDefault(require_valid());
    exports2.valid = valid_1.default;
    function parse(data, options = {}) {
      return (0, parse_1.default)(data, options);
    }
    exports2.default = parse;
    exports2.parse = parse;
    parse.parse = parse_1.default;
    parse.HTMLElement = html_1.default;
    parse.CommentNode = comment_1.default;
    parse.valid = valid_1.default;
    parse.Node = node_12.default;
    parse.TextNode = text_1.default;
    parse.NodeType = type_1.default;
  }
});

// node_modules/css-variable-lsp/out/domTree.js
var require_domTree = __commonJS({
  "node_modules/css-variable-lsp/out/domTree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DOMTree = void 0;
    var node_html_parser_1 = require_dist();
    var DOMTree = class {
      root;
      htmlText;
      constructor(htmlText) {
        this.htmlText = htmlText;
        this.root = (0, node_html_parser_1.parse)(htmlText, {
          lowerCaseTagName: true,
          comment: false,
          blockTextElements: {
            script: true,
            noscript: true,
            style: false
            // We want to parse style content
          }
        });
      }
      /**
       * Find the DOM node at a specific character position in the HTML
       */
      findNodeAtPosition(position) {
        return this.findNodeAtPositionRecursive(this.root, position);
      }
      findNodeAtPositionRecursive(node, position) {
        if (!(node instanceof node_html_parser_1.HTMLElement)) {
          return void 0;
        }
        const range = node.range;
        if (!range || position < range[0] || position > range[1]) {
          return void 0;
        }
        for (const child of node.childNodes) {
          const found = this.findNodeAtPositionRecursive(child, position);
          if (found) {
            return found;
          }
        }
        return {
          tagName: node.tagName,
          id: node.id,
          element: node
        };
      }
      /**
       * Check if a CSS selector matches a given DOM node
       */
      matchesSelector(nodeInfo, selector) {
        try {
          const parent = nodeInfo.element.parentNode;
          if (!parent || !(parent instanceof node_html_parser_1.HTMLElement)) {
            const matches2 = this.root.querySelectorAll(selector);
            return matches2.includes(nodeInfo.element);
          }
          const matches = parent.querySelectorAll(selector);
          return matches.includes(nodeInfo.element);
        } catch (e) {
          return false;
        }
      }
      /**
       * Find all nodes that match a CSS selector
       */
      querySelectorAll(selector) {
        try {
          const elements = this.root.querySelectorAll(selector);
          return elements.map((el) => {
            return {
              tagName: el.tagName,
              id: el.id,
              element: el
            };
          });
        } catch (e) {
          return [];
        }
      }
      /**
       * Get the root element
       */
      getRoot() {
        return this.root;
      }
    };
    exports2.DOMTree = DOMTree;
  }
});

// node_modules/css-variable-lsp/out/colorService.js
var require_colorService = __commonJS({
  "node_modules/css-variable-lsp/out/colorService.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseColor = parseColor;
    exports2.formatColor = formatColor;
    exports2.formatColorAsHex = formatColorAsHex;
    exports2.formatColorAsRgb = formatColorAsRgb;
    exports2.formatColorAsHsl = formatColorAsHsl;
    function parseColor(value, options = {}) {
      value = value.trim().toLowerCase();
      if (value.startsWith("#")) {
        return parseHex(value);
      }
      if (value.startsWith("rgb")) {
        return parseRgb(value);
      }
      if (value.startsWith("hsl")) {
        return parseHsl(value);
      }
      if (options.allowNamedColors) {
        return parseNamedColor(value);
      }
      return null;
    }
    function formatColor(color) {
      const r = Math.round(color.red * 255);
      const g = Math.round(color.green * 255);
      const b = Math.round(color.blue * 255);
      const a = color.alpha;
      if (a >= 1) {
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      } else {
        return `rgba(${r}, ${g}, ${b}, ${Number(a.toFixed(2))})`;
      }
    }
    function formatColorAsHex(color) {
      const r = Math.round(color.red * 255);
      const g = Math.round(color.green * 255);
      const b = Math.round(color.blue * 255);
      const a = Math.round(color.alpha * 255);
      if (a >= 255) {
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      } else {
        return `#${toHex(r)}${toHex(g)}${toHex(b)}${toHex(a)}`;
      }
    }
    function formatColorAsRgb(color) {
      const r = Math.round(color.red * 255);
      const g = Math.round(color.green * 255);
      const b = Math.round(color.blue * 255);
      const a = color.alpha;
      if (a >= 1) {
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        return `rgba(${r}, ${g}, ${b}, ${Number(a.toFixed(2))})`;
      }
    }
    function formatColorAsHsl(color) {
      const { h, s, l } = rgbToHsl(color.red, color.green, color.blue);
      const a = color.alpha;
      const hDeg = Math.round(h * 360);
      const sPercent = Math.round(s * 100);
      const lPercent = Math.round(l * 100);
      if (a >= 1) {
        return `hsl(${hDeg}, ${sPercent}%, ${lPercent}%)`;
      } else {
        return `hsla(${hDeg}, ${sPercent}%, ${lPercent}%, ${Number(a.toFixed(2))})`;
      }
    }
    function rgbToHsl(r, g, b) {
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;
      if (max === min) {
        return { h: 0, s: 0, l };
      }
      const d = max - min;
      const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      let h;
      if (max === r) {
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
      } else if (max === g) {
        h = ((b - r) / d + 2) / 6;
      } else {
        h = ((r - g) / d + 4) / 6;
      }
      return { h, s, l };
    }
    function toHex(n) {
      const hex = n.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }
    function parseHex(hex) {
      hex = hex.substring(1);
      if (hex.length === 3) {
        hex = hex.split("").map((c) => c + c).join("");
      }
      if (hex.length === 4) {
        hex = hex.split("").map((c) => c + c).join("");
      }
      if (hex.length !== 6 && hex.length !== 8) {
        return null;
      }
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      let a = 1;
      if (hex.length === 8) {
        a = parseInt(hex.substring(6, 8), 16) / 255;
      }
      return { red: r, green: g, blue: b, alpha: a };
    }
    function parseRgb(value) {
      const match = value.match(/rgba?\(([\d\s\.]+),?\s*([\d\s\.]+),?\s*([\d\s\.]+)(?:,?\s*\/?,?\s*([\d\s\.]+))?\)/);
      if (!match)
        return null;
      const r = parseFloat(match[1]) / 255;
      const g = parseFloat(match[2]) / 255;
      const b = parseFloat(match[3]) / 255;
      let a = 1;
      if (match[4]) {
        a = parseFloat(match[4]);
      }
      return { red: r, green: g, blue: b, alpha: a };
    }
    function parseHsl(value) {
      const match = value.match(/hsla?\(([\d\s\.]+)(?:deg)?,?\s*([\d\s\.]+)%?,?\s*([\d\s\.]+)%?(?:,?\s*\/?,?\s*([\d\s\.]+))?\)/);
      if (!match)
        return null;
      const h = parseFloat(match[1]) / 360;
      const s = parseFloat(match[2]) / 100;
      const l = parseFloat(match[3]) / 100;
      let a = 1;
      if (match[4]) {
        a = parseFloat(match[4]);
      }
      return hslToRgb(h, s, l, a);
    }
    function hslToRgb(h, s, l, a) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p2, q2, t) => {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { red: r, green: g, blue: b, alpha: a };
    }
    function parseNamedColor(name) {
      const colors = {
        black: "#000000",
        white: "#ffffff",
        red: "#ff0000",
        green: "#008000",
        blue: "#0000ff",
        yellow: "#ffff00",
        cyan: "#00ffff",
        magenta: "#ff00ff",
        gray: "#808080",
        grey: "#808080",
        silver: "#c0c0c0",
        maroon: "#800000",
        olive: "#808000",
        purple: "#800080",
        teal: "#008080",
        navy: "#000080",
        orange: "#ffa500",
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        blanchedalmond: "#ffebcd",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        greenyellow: "#adff2f",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        oldlace: "#fdf5e6",
        olivedrab: "#6b8e23",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        transparent: "#00000000",
        // Special case
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        whitesmoke: "#f5f5f5",
        yellowgreen: "#9acd32",
        rebeccapurple: "#663399"
      };
      if (colors[name]) {
        return parseHex(colors[name]);
      }
      return null;
    }
  }
});

// node_modules/css-variable-lsp/out/specificity.js
var require_specificity = __commonJS({
  "node_modules/css-variable-lsp/out/specificity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateSpecificity = calculateSpecificity;
    exports2.compareSpecificity = compareSpecificity;
    exports2.formatSpecificity = formatSpecificity;
    exports2.matchesContext = matchesContext;
    function calculateSpecificity(selector) {
      selector = selector.trim();
      if (!selector || selector === "*") {
        return { ids: 0, classes: 0, elements: 0 };
      }
      const specificity = {
        ids: 0,
        classes: 0,
        elements: 0
      };
      const selectors = selector.split(",");
      if (selectors.length > 1) {
        const specificities = selectors.map((s) => calculateSpecificity(s.trim()));
        return specificities.reduce((max, curr) => compareSpecificity(curr, max) > 0 ? curr : max);
      }
      const pseudoElementRegex = /::[a-z-]+/gi;
      const pseudoElements = selector.match(pseudoElementRegex) || [];
      specificity.elements += pseudoElements.length;
      selector = selector.replace(pseudoElementRegex, "");
      const idRegex = /#[a-z0-9_-]+/gi;
      const ids = selector.match(idRegex) || [];
      specificity.ids += ids.length;
      selector = selector.replace(idRegex, "");
      const classRegex = /\.[a-z0-9_-]+/gi;
      const classes = selector.match(classRegex) || [];
      specificity.classes += classes.length;
      selector = selector.replace(classRegex, "");
      const attrRegex = /\[(?:[^\]"']|"[^"]*"|'[^']*')*\]/g;
      const attrs = selector.match(attrRegex) || [];
      specificity.classes += attrs.length;
      selector = selector.replace(attrRegex, "");
      const pseudoClassRegex = /:[a-z-]+(\([^)]*\))?/gi;
      const pseudoClasses = selector.match(pseudoClassRegex) || [];
      specificity.classes += pseudoClasses.length;
      selector = selector.replace(pseudoClassRegex, "");
      selector = selector.replace(/[>+~\s]/g, " ");
      const elements = selector.split(/\s+/).filter((s) => s && s !== "*");
      specificity.elements += elements.length;
      return specificity;
    }
    function compareSpecificity(a, b) {
      if (a.ids !== b.ids) {
        return a.ids > b.ids ? 1 : -1;
      }
      if (a.classes !== b.classes) {
        return a.classes > b.classes ? 1 : -1;
      }
      if (a.elements !== b.elements) {
        return a.elements > b.elements ? 1 : -1;
      }
      return 0;
    }
    function formatSpecificity(spec) {
      return `(${spec.ids},${spec.classes},${spec.elements})`;
    }
    function matchesContext(definitionSelector, usageContext, domTree, domNode) {
      if (domTree && domNode) {
        try {
          return domTree.matchesSelector(domNode, definitionSelector);
        } catch (e) {
        }
      }
      if (definitionSelector.trim() === ":root") {
        return true;
      }
      if (definitionSelector.trim() === usageContext.trim()) {
        return true;
      }
      const defParts = definitionSelector.split(/[\s>+~]/);
      const usageParts = usageContext.split(/[\s>+~]/);
      return defParts.some((defPart) => usageParts.some((usagePart) => usagePart.includes(defPart) || defPart.includes(usagePart)));
    }
  }
});

// node_modules/css-variable-lsp/out/cssVariableManager.js
var require_cssVariableManager = __commonJS({
  "node_modules/css-variable-lsp/out/cssVariableManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CssVariableManager = void 0;
    var node_12 = require_node3();
    var vscode_languageserver_textdocument_12 = (init_main(), __toCommonJS(main_exports));
    var vscode_uri_12 = require_umd();
    var glob_1 = require_commonjs7();
    var fs = require("fs");
    var csstree = require_cjs();
    var domTree_1 = require_domTree();
    var node_html_parser_1 = require_dist();
    var colorService_1 = require_colorService();
    var specificity_12 = require_specificity();
    var path2 = require("path");
    var DEFAULT_LOOKUP_FILES = [
      "**/*.css",
      "**/*.scss",
      "**/*.sass",
      "**/*.less",
      "**/*.html",
      "**/*.vue",
      "**/*.svelte",
      "**/*.astro",
      "**/*.ripple"
    ];
    var DEFAULT_IGNORE_GLOBS = [
      "**/node_modules/**",
      "**/dist/**",
      "**/out/**",
      "**/.git/**"
    ];
    var EXTENSION_LANGUAGE_MAP = /* @__PURE__ */ new Map([
      [".css", "css"],
      [".scss", "scss"],
      [".sass", "sass"],
      [".less", "less"],
      [".html", "html"],
      [".vue", "html"],
      [".svelte", "html"],
      [".astro", "html"],
      [".ripple", "html"]
    ]);
    var HTML_LIKE_LANGUAGE_IDS = /* @__PURE__ */ new Set([
      "html",
      "vue",
      "svelte",
      "astro",
      "ripple"
    ]);
    var CSS_LANGUAGE_IDS = /* @__PURE__ */ new Set(["css", "scss", "sass", "less"]);
    function normalizeGlobPattern(pattern) {
      return pattern.replace(/\\/g, "/").trim();
    }
    function normalizeGlobList(globs) {
      if (!globs) {
        return void 0;
      }
      return globs.map((glob) => normalizeGlobPattern(glob)).filter((glob) => glob.length > 0);
    }
    function extractExtensions(pattern) {
      const braceMatch = pattern.match(/\{([^}]+)\}/);
      if (braceMatch) {
        return braceMatch[1].split(",").map((ext2) => ext2.trim()).filter(Boolean).map((ext2) => ext2.startsWith(".") ? ext2 : `.${ext2}`);
      }
      const ext = path2.extname(pattern);
      return ext ? [ext] : [];
    }
    function normalizeUri(uri) {
      try {
        return vscode_uri_12.URI.parse(uri).toString().toLowerCase();
      } catch (e) {
        return uri.toLowerCase();
      }
    }
    var CssVariableManager = class {
      variables = /* @__PURE__ */ new Map();
      usages = /* @__PURE__ */ new Map();
      domTrees = /* @__PURE__ */ new Map();
      // URI -> DOM tree
      logger;
      lookupFiles;
      ignoreGlobs;
      lookupExtensions;
      constructor(logger, lookupFiles, ignoreGlobs) {
        this.logger = logger || {
          log: (message) => {
            if (process.env.CSS_LSP_DEBUG) {
              console.log(message);
            }
          },
          error: (message) => {
            console.error(message);
          }
        };
        const normalizedLookupFiles = normalizeGlobList(lookupFiles);
        const normalizedIgnoreGlobs = normalizeGlobList(ignoreGlobs);
        this.lookupFiles = normalizedLookupFiles && normalizedLookupFiles.length > 0 ? normalizedLookupFiles : DEFAULT_LOOKUP_FILES;
        this.ignoreGlobs = normalizedIgnoreGlobs && normalizedIgnoreGlobs.length > 0 ? normalizedIgnoreGlobs : DEFAULT_IGNORE_GLOBS;
        this.lookupExtensions = this.buildLookupExtensions(this.lookupFiles);
      }
      buildLookupExtensions(lookupFiles) {
        const extensions = /* @__PURE__ */ new Map();
        for (const pattern of lookupFiles) {
          for (const ext of extractExtensions(pattern)) {
            const languageId = EXTENSION_LANGUAGE_MAP.get(ext) ?? "css";
            extensions.set(ext, languageId);
          }
        }
        return extensions;
      }
      resolveLanguageId(filePath) {
        const ext = path2.extname(filePath);
        if (!ext) {
          return null;
        }
        return this.lookupExtensions.get(ext) ?? null;
      }
      resolveDocumentLanguageId(languageId, uri) {
        if (HTML_LIKE_LANGUAGE_IDS.has(languageId)) {
          return "html";
        }
        if (CSS_LANGUAGE_IDS.has(languageId)) {
          return languageId;
        }
        const filePath = vscode_uri_12.URI.parse(uri).fsPath;
        return this.resolveLanguageId(filePath) ?? languageId;
      }
      /**
       * Scan all CSS and HTML files in the workspace
       * @param workspaceFolders Array of workspace folder URIs
       * @param onProgress Optional callback for progress updates (current, total)
       */
      async scanWorkspace(workspaceFolders, onProgress) {
        const allFiles = [];
        for (const folder of workspaceFolders) {
          const folderUri = vscode_uri_12.URI.parse(folder);
          const folderPath = folderUri.fsPath;
          const files = await (0, glob_1.glob)(this.lookupFiles, {
            cwd: folderPath,
            ignore: this.ignoreGlobs,
            absolute: true
          });
          this.logger.log(`[css-lsp] Scanned ${folder}: found ${files.length} files`);
          allFiles.push(...files);
        }
        const totalFiles = allFiles.length;
        let processedFiles = 0;
        for (const filePath of allFiles) {
          try {
            const content = fs.readFileSync(filePath, "utf-8");
            const fileUri = vscode_uri_12.URI.file(filePath).toString();
            const languageId = this.resolveLanguageId(filePath);
            if (!languageId) {
              continue;
            }
            this.parseContent(content, fileUri, languageId);
          } catch (error) {
            this.logger.error(`[css-lsp] Error scanning file ${filePath}: ${error}`);
          }
          processedFiles++;
          if (onProgress && (processedFiles % 10 === 0 || processedFiles === totalFiles)) {
            onProgress(processedFiles, totalFiles);
          }
        }
        this.logger.log(`[css-lsp] Workspace scan complete. Processed ${totalFiles} files.`);
      }
      parseDocument(document) {
        this.parseContent(document.getText(), document.uri, document.languageId);
      }
      parseContent(text, uri, languageId) {
        const normalizedUri = normalizeUri(uri);
        this.removeFile(normalizedUri);
        const resolvedLanguageId = this.resolveDocumentLanguageId(languageId, normalizedUri);
        if (resolvedLanguageId === "html") {
          try {
            const domTree = new domTree_1.DOMTree(text);
            this.domTrees.set(uri, domTree);
          } catch (error) {
            this.logger.error(`Error parsing HTML for ${uri}: ${error}`);
          }
          try {
            const root = (0, node_html_parser_1.parse)(text, {
              lowerCaseTagName: true,
              comment: false,
              // Automatically ignores comments
              blockTextElements: {
                script: true,
                noscript: true,
                style: true
                // Keep style as block text so we can extract content
              }
            });
            const document = vscode_languageserver_textdocument_12.TextDocument.create(uri, resolvedLanguageId, 1, text);
            const styleElements = root.querySelectorAll("style");
            for (const styleEl of styleElements) {
              const styleContent = styleEl.textContent;
              if (styleContent && styleEl.range) {
                const elementText = text.substring(styleEl.range[0], styleEl.range[1]);
                const openingTagEnd = elementText.indexOf(">") + 1;
                const styleStartOffset = styleEl.range[0] + openingTagEnd;
                this.parseCssText(styleContent, uri, document, styleStartOffset);
              }
            }
            const elementsWithStyle = root.querySelectorAll("[style]");
            for (const el of elementsWithStyle) {
              const styleAttr = el.getAttribute("style");
              if (styleAttr && el.range) {
                const elementText = text.substring(el.range[0], el.range[1]);
                const styleAttrStart = elementText.indexOf("style");
                if (styleAttrStart !== -1) {
                  const valueStart = elementText.indexOf(styleAttr, styleAttrStart);
                  if (valueStart !== -1) {
                    const styleStartOffset = el.range[0] + valueStart;
                    const attributeOffset = el.range[0] + styleAttrStart;
                    this.parseInlineStyle(styleAttr, uri, document, styleStartOffset, attributeOffset);
                  }
                }
              }
            }
          } catch (error) {
            this.logger.error(`Error parsing HTML content for ${uri}: ${error}`);
          }
        } else {
          const document = vscode_languageserver_textdocument_12.TextDocument.create(uri, resolvedLanguageId, 1, text);
          this.parseCssText(text, uri, document, 0);
        }
      }
      parseCssText(text, uri, document, offset) {
        try {
          const ast = csstree.parse(text, {
            positions: true,
            onParseError: (error) => {
              this.logger.log(`[css-lsp] CSS Parse Error in ${uri}: ${error.message}`);
            }
          });
          const selectorStack = [];
          csstree.walk(ast, {
            enter: (node) => {
              if (node.type === "Rule") {
                let selector = "";
                if (node.prelude && node.prelude.type === "Raw") {
                  selector = node.prelude.value;
                } else if (node.prelude) {
                  selector = csstree.generate(node.prelude);
                }
                selectorStack.push(selector);
              }
              if (node.type === "Declaration" && node.property.startsWith("--")) {
                const name = node.property;
                const value = csstree.generate(node.value).trim();
                const important = node.important === true || node.important === "important";
                const selector = selectorStack.length > 0 ? selectorStack[selectorStack.length - 1] : ":root";
                if (node.loc) {
                  const startPos = document.positionAt(offset + node.loc.start.offset);
                  const endPos = document.positionAt(offset + node.loc.end.offset);
                  const declarationText = text.substring(node.loc.start.offset, node.loc.end.offset);
                  const colonIndex = declarationText.indexOf(":");
                  const declarationHeader = colonIndex >= 0 ? declarationText.slice(0, colonIndex) : declarationText;
                  const nameMatch = declarationHeader.match(/--[\w-]+/);
                  let nameRange;
                  if (nameMatch && nameMatch.index !== void 0) {
                    const nameStartOffset = offset + node.loc.start.offset + nameMatch.index;
                    const nameEndOffset = nameStartOffset + nameMatch[0].length;
                    nameRange = node_12.Range.create(document.positionAt(nameStartOffset), document.positionAt(nameEndOffset));
                  }
                  let valueRange;
                  if (node.value && node.value.loc) {
                    const valueStartOffset = offset + node.value.loc.start.offset;
                    const valueEndOffset = offset + node.value.loc.end.offset;
                    const rawValueText = text.substring(valueStartOffset, valueEndOffset);
                    const leadingWhitespace = rawValueText.length - rawValueText.trimStart().length;
                    const trailingWhitespace = rawValueText.length - rawValueText.trimEnd().length;
                    const valueStartPos = document.positionAt(valueStartOffset + leadingWhitespace);
                    const valueEndPos = document.positionAt(valueEndOffset - trailingWhitespace);
                    valueRange = node_12.Range.create(valueStartPos, valueEndPos);
                  }
                  const variable = {
                    name,
                    value,
                    uri,
                    range: node_12.Range.create(startPos, endPos),
                    nameRange,
                    valueRange,
                    selector,
                    important,
                    inline: false,
                    sourcePosition: offset + node.loc.start.offset
                  };
                  if (!this.variables.has(name)) {
                    this.variables.set(name, []);
                  }
                  this.variables.get(name)?.push(variable);
                }
              }
              if (node.type === "Function" && node.name === "var") {
                const children = node.children;
                if (children && children.first) {
                  const firstChild = children.first;
                  if (firstChild.type === "Identifier" && firstChild.name.startsWith("--")) {
                    const name = firstChild.name;
                    const usageContext = selectorStack.length > 0 ? selectorStack[selectorStack.length - 1] : "";
                    if (node.loc) {
                      const startPos = document.positionAt(offset + node.loc.start.offset);
                      const endPos = document.positionAt(offset + node.loc.end.offset);
                      let nameRange;
                      if (firstChild.loc) {
                        const nameStartOffset = offset + firstChild.loc.start.offset;
                        const nameEndOffset = offset + firstChild.loc.end.offset;
                        nameRange = node_12.Range.create(document.positionAt(nameStartOffset), document.positionAt(nameEndOffset));
                      }
                      const usage = {
                        name,
                        uri,
                        range: node_12.Range.create(startPos, endPos),
                        nameRange,
                        usageContext
                      };
                      if (!this.usages.has(name)) {
                        this.usages.set(name, []);
                      }
                      this.usages.get(name)?.push(usage);
                    }
                  }
                }
              }
            },
            leave: (node) => {
              if (node.type === "Rule") {
                selectorStack.pop();
              }
            }
          });
        } catch (e) {
          this.logger.error(`Error parsing CSS in ${uri}: ${e}`);
        }
      }
      /**
       * Parse inline style attributes for variable usages.
       * Inline styles don't have selectors, they apply directly to elements (highest specificity).
       */
      parseInlineStyle(text, uri, document, offset, attributeOffset) {
        try {
          const ast = csstree.parse(text, {
            context: "declarationList",
            positions: true,
            onParseError: (error) => {
              this.logger.log(`[css-lsp] Inline Style Parse Error in ${uri}: ${error.message}`);
            }
          });
          csstree.walk(ast, {
            enter: (node) => {
              if (node.type === "Declaration" && node.property.startsWith("--")) {
                const name = node.property;
                const value = csstree.generate(node.value).trim();
                const important = node.important === true || node.important === "important";
                if (node.loc) {
                  const startPos = document.positionAt(offset + node.loc.start.offset);
                  const endPos = document.positionAt(offset + node.loc.end.offset);
                  const declarationText = text.substring(node.loc.start.offset, node.loc.end.offset);
                  const colonIndex = declarationText.indexOf(":");
                  const declarationHeader = colonIndex >= 0 ? declarationText.slice(0, colonIndex) : declarationText;
                  const nameMatch = declarationHeader.match(/--[\w-]+/);
                  let nameRange;
                  if (nameMatch && nameMatch.index !== void 0) {
                    const nameStartOffset = offset + node.loc.start.offset + nameMatch.index;
                    const nameEndOffset = nameStartOffset + nameMatch[0].length;
                    nameRange = node_12.Range.create(document.positionAt(nameStartOffset), document.positionAt(nameEndOffset));
                  }
                  let valueRange;
                  if (node.value && node.value.loc) {
                    const valueStartOffset = offset + node.value.loc.start.offset;
                    const valueEndOffset = offset + node.value.loc.end.offset;
                    const rawValueText = text.substring(node.value.loc.start.offset, node.value.loc.end.offset);
                    const leadingWhitespace = rawValueText.length - rawValueText.trimStart().length;
                    const trailingWhitespace = rawValueText.length - rawValueText.trimEnd().length;
                    const valueStartPos = document.positionAt(valueStartOffset + leadingWhitespace);
                    const valueEndPos = document.positionAt(valueEndOffset - trailingWhitespace);
                    valueRange = node_12.Range.create(valueStartPos, valueEndPos);
                  }
                  const variable = {
                    name,
                    value,
                    uri,
                    range: node_12.Range.create(startPos, endPos),
                    nameRange,
                    valueRange,
                    selector: "inline-style",
                    important,
                    inline: true,
                    sourcePosition: offset + node.loc.start.offset
                  };
                  if (!this.variables.has(name)) {
                    this.variables.set(name, []);
                  }
                  this.variables.get(name)?.push(variable);
                }
              }
              if (node.type === "Function" && node.name === "var") {
                const children = node.children;
                if (children && children.first) {
                  const firstChild = children.first;
                  if (firstChild.type === "Identifier" && firstChild.name.startsWith("--")) {
                    const name = firstChild.name;
                    if (node.loc) {
                      const startPos = document.positionAt(offset + node.loc.start.offset);
                      const endPos = document.positionAt(offset + node.loc.end.offset);
                      let nameRange;
                      if (firstChild.loc) {
                        const nameStartOffset = offset + firstChild.loc.start.offset;
                        const nameEndOffset = offset + firstChild.loc.end.offset;
                        nameRange = node_12.Range.create(document.positionAt(nameStartOffset), document.positionAt(nameEndOffset));
                      }
                      const domTree = this.domTrees.get(uri);
                      const domNode = domTree?.findNodeAtPosition(attributeOffset);
                      const usage = {
                        name,
                        uri,
                        range: node_12.Range.create(startPos, endPos),
                        nameRange,
                        usageContext: "inline-style",
                        domNode
                      };
                      if (!this.usages.has(name)) {
                        this.usages.set(name, []);
                      }
                      this.usages.get(name)?.push(usage);
                    }
                  }
                }
              }
            }
          });
        } catch (e) {
          this.logger.error(`Error parsing inline style in ${uri}: ${e}`);
        }
      }
      async updateFile(uri) {
        try {
          const filePath = vscode_uri_12.URI.parse(uri).fsPath;
          if (!fs.existsSync(filePath)) {
            this.logger.log(`[css-lsp] File ${uri} does not exist on disk, removing from manager.`);
            this.removeFile(uri);
            return;
          }
          const stat = fs.statSync(filePath);
          if (!stat.isFile()) {
            return;
          }
          const content = fs.readFileSync(filePath, "utf-8");
          const languageId = this.resolveLanguageId(filePath);
          if (!languageId) {
            return;
          }
          this.parseContent(content, uri, languageId);
          this.logger.log(`[css-lsp] Updated file ${uri} from disk.`);
        } catch (error) {
          this.logger.error(`[css-lsp] Error updating file ${uri}: ${error}`);
        }
      }
      removeFile(uri) {
        const normalizedUri = normalizeUri(uri);
        this.clearDocumentVariables(normalizedUri);
        this.clearDocumentUsages(normalizedUri);
        this.clearDocumentDOMTree(normalizedUri);
      }
      clearDocumentVariables(uri) {
        const normalizedUri = normalizeUri(uri);
        for (const [name, vars] of this.variables.entries()) {
          const filtered = vars.filter((v) => normalizeUri(v.uri) !== normalizedUri);
          if (filtered.length === 0) {
            this.variables.delete(name);
          } else if (filtered.length !== vars.length) {
            this.variables.set(name, filtered);
          }
        }
      }
      clearDocumentUsages(uri) {
        const normalizedUri = normalizeUri(uri);
        for (const [name, usgs] of this.usages.entries()) {
          const filtered = usgs.filter((u) => normalizeUri(u.uri) !== normalizedUri);
          if (filtered.length === 0) {
            this.usages.delete(name);
          } else if (filtered.length !== usgs.length) {
            this.usages.set(name, filtered);
          }
        }
      }
      clearDocumentDOMTree(uri) {
        this.domTrees.delete(uri);
      }
      getAllVariables() {
        const allVars = [];
        for (const vars of this.variables.values()) {
          allVars.push(...vars);
        }
        return allVars;
      }
      getVariables(name) {
        return this.variables.get(name) || [];
      }
      getVariableUsages(name) {
        return this.usages.get(name) || [];
      }
      /**
       * Get all references (definitions + usages) for a variable
       */
      getReferences(name) {
        const definitions = this.getVariables(name);
        const usages = this.getVariableUsages(name);
        return [...definitions, ...usages];
      }
      /**
       * Get all variable definitions across the workspace (for workspace symbols)
       */
      getAllDefinitions() {
        return this.getAllVariables();
      }
      /**
       * Get all variable definitions in a specific document (for document symbols)
       */
      getDocumentDefinitions(uri) {
        const normalizedUri = normalizeUri(uri);
        const allVars = this.getAllVariables();
        return allVars.filter((v) => normalizeUri(v.uri) === normalizedUri);
      }
      /**
       * Get the DOM tree for a document (if it's HTML)
       */
      getDOMTree(uri) {
        return this.domTrees.get(uri);
      }
      /**
       * Resolve a variable name to a Color if possible.
       * Handles recursive variable references: var(--a) -> var(--b) -> #fff
       * Uses CSS cascade rules: !important > specificity > source order
       */
      resolveVariableColor(name, context, seen = /* @__PURE__ */ new Set()) {
        if (seen.has(name)) {
          return null;
        }
        seen.add(name);
        const variables = this.getVariables(name);
        if (variables.length === 0) {
          return null;
        }
        const sortedVars = [...variables].sort((a, b) => {
          if (a.important !== b.important) {
            return a.important ? -1 : 1;
          }
          const aInline = a.inline ?? false;
          const bInline = b.inline ?? false;
          if (aInline !== bInline) {
            return aInline ? -1 : 1;
          }
          const specA = (0, specificity_12.calculateSpecificity)(a.selector);
          const specB = (0, specificity_12.calculateSpecificity)(b.selector);
          const specCompare = (0, specificity_12.compareSpecificity)(specA, specB);
          if (specCompare !== 0) {
            return -specCompare;
          }
          return b.sourcePosition - a.sourcePosition;
        });
        const variable = sortedVars[0];
        let value = variable.value;
        const recursiveMatch = value.match(/var\(\s*(--[\w-]+)\s*(?:,\s*[^)]+)?\s*\)/);
        if (recursiveMatch) {
          return this.resolveVariableColor(recursiveMatch[1], context, seen);
        }
        return (0, colorService_1.parseColor)(value, { allowNamedColors: true });
      }
    };
    exports2.CssVariableManager = CssVariableManager;
  }
});

// node_modules/css-variable-lsp/out/colorProvider.js
var require_colorProvider = __commonJS({
  "node_modules/css-variable-lsp/out/colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectDocumentColors = collectDocumentColors;
    exports2.collectColorPresentations = collectColorPresentations;
    var node_12 = require_node3();
    var colorService_1 = require_colorService();
    function collectDocumentColors(document, cssVariableManager2, options) {
      if (!options.enabled) {
        return [];
      }
      const colors = [];
      const text = document.getText();
      if (!options.onlyVariables) {
        const definitions = cssVariableManager2.getDocumentDefinitions(document.uri);
        for (const def of definitions) {
          const color = (0, colorService_1.parseColor)(def.value, { allowNamedColors: true });
          if (color) {
            if (def.valueRange) {
              colors.push({
                range: def.valueRange,
                color
              });
            } else {
              const defText = text.substring(document.offsetAt(def.range.start), document.offsetAt(def.range.end));
              const colonIndex = defText.indexOf(":");
              if (colonIndex !== -1) {
                const afterColon = defText.substring(colonIndex + 1);
                const valueIndex = afterColon.indexOf(def.value.trim());
                if (valueIndex !== -1) {
                  const absoluteValueStart = document.offsetAt(def.range.start) + colonIndex + 1 + valueIndex;
                  const start = document.positionAt(absoluteValueStart);
                  const end = document.positionAt(absoluteValueStart + def.value.trim().length);
                  colors.push({
                    range: { start, end },
                    color
                  });
                }
              }
            }
          }
        }
      }
      const regex = /var\(\s*(--[\w-]+)\s*(?:,\s*[^)]+)?\s*\)/g;
      let match;
      while ((match = regex.exec(text)) !== null) {
        const varName = match[1];
        const color = cssVariableManager2.resolveVariableColor(varName);
        if (color) {
          const start = document.positionAt(match.index);
          const end = document.positionAt(match.index + match[0].length);
          colors.push({
            range: { start, end },
            color
          });
        }
      }
      const uniqueColors = [];
      const uniqueOffsets = [];
      for (const colorInfo of colors) {
        const start = document.offsetAt(colorInfo.range.start);
        const end = document.offsetAt(colorInfo.range.end);
        let isDuplicate = false;
        for (let i = 0; i < uniqueOffsets.length; i++) {
          const existing = uniqueOffsets[i];
          if (colorsEqual(existing.color, colorInfo.color) && rangesOverlap(existing.start, existing.end, start, end)) {
            const existingLen = existing.end - existing.start;
            const currentLen = end - start;
            if (currentLen < existingLen) {
              uniqueOffsets[i] = { start, end, color: colorInfo.color };
              uniqueColors[i] = colorInfo;
            }
            isDuplicate = true;
            break;
          }
        }
        if (!isDuplicate) {
          uniqueOffsets.push({ start, end, color: colorInfo.color });
          uniqueColors.push(colorInfo);
        }
      }
      return uniqueColors;
    }
    function colorsEqual(a, b) {
      return a.red === b.red && a.green === b.green && a.blue === b.blue && a.alpha === b.alpha;
    }
    function rangesOverlap(aStart, aEnd, bStart, bEnd) {
      return aStart < bEnd && bStart < aEnd;
    }
    function collectColorPresentations(range, color, enabled) {
      if (!enabled) {
        return [];
      }
      const presentations = [];
      const hexStr = (0, colorService_1.formatColorAsHex)(color);
      presentations.push(node_12.ColorPresentation.create(hexStr, node_12.TextEdit.replace(range, hexStr)));
      const rgbStr = (0, colorService_1.formatColorAsRgb)(color);
      presentations.push(node_12.ColorPresentation.create(rgbStr, node_12.TextEdit.replace(range, rgbStr)));
      const hslStr = (0, colorService_1.formatColorAsHsl)(color);
      presentations.push(node_12.ColorPresentation.create(hslStr, node_12.TextEdit.replace(range, hslStr)));
      return presentations;
    }
  }
});

// node_modules/css-variable-lsp/out/initialize.js
var require_initialize = __commonJS({
  "node_modules/css-variable-lsp/out/initialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInitializeResult = buildInitializeResult;
    var node_12 = require_node3();
    function buildInitializeResult(enableColorProvider, supportsWorkspaceFolders) {
      const result = {
        capabilities: {
          textDocumentSync: node_12.TextDocumentSyncKind.Incremental,
          completionProvider: {
            resolveProvider: true,
            triggerCharacters: ["-"]
          },
          definitionProvider: true,
          hoverProvider: true,
          referencesProvider: true,
          renameProvider: true,
          documentSymbolProvider: true,
          workspaceSymbolProvider: true,
          colorProvider: enableColorProvider
        }
      };
      if (supportsWorkspaceFolders) {
        result.capabilities.workspace = {
          workspaceFolders: {
            supported: true
          }
        };
      }
      return result;
    }
  }
});

// node_modules/css-variable-lsp/out/pathDisplay.js
var require_pathDisplay = __commonJS({
  "node_modules/css-variable-lsp/out/pathDisplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toNormalizedFsPath = toNormalizedFsPath;
    exports2.formatUriForDisplay = formatUriForDisplay;
    var path2 = require("path");
    var vscode_uri_12 = require_umd();
    function toNormalizedFsPath(uri) {
      try {
        const fsPath = vscode_uri_12.URI.parse(uri).fsPath;
        return fsPath ? path2.normalize(fsPath) : null;
      } catch {
        return null;
      }
    }
    function findBestRelativePath(fsPath, roots) {
      let bestRelative = null;
      for (const root of roots) {
        const relativePath = path2.relative(root, fsPath);
        if (!relativePath || relativePath.startsWith("..") || path2.isAbsolute(relativePath)) {
          continue;
        }
        if (!bestRelative || relativePath.length < bestRelative.length) {
          bestRelative = relativePath;
        }
      }
      return bestRelative;
    }
    function abbreviatePath(pathValue, abbrevLength) {
      if (abbrevLength <= 0) {
        return pathValue;
      }
      const parts = pathValue.split(path2.sep);
      const shortened = parts.map((part, index) => {
        if (index === parts.length - 1) {
          return part;
        }
        if (!part || part.length <= abbrevLength) {
          return part;
        }
        return part.slice(0, abbrevLength);
      });
      return shortened.join(path2.sep);
    }
    function formatUriForDisplay(uri, options) {
      const fsPath = toNormalizedFsPath(uri);
      if (!fsPath) {
        return uri;
      }
      const roots = options.workspaceFolderPaths.length ? options.workspaceFolderPaths : options.rootFolderPath ? [options.rootFolderPath] : [];
      const relative = findBestRelativePath(fsPath, roots);
      switch (options.mode) {
        case "absolute":
          return fsPath;
        case "abbreviated": {
          const base = relative ?? fsPath;
          return abbreviatePath(base, options.abbrevLength);
        }
        case "relative":
        default:
          return relative ?? fsPath;
      }
    }
  }
});

// node_modules/css-variable-lsp/out/runtimeConfig.js
var require_runtimeConfig = __commonJS({
  "node_modules/css-variable-lsp/out/runtimeConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildRuntimeConfig = buildRuntimeConfig;
    function getArgValue(argv, name) {
      const flag = `--${name}`;
      const directIndex = argv.indexOf(flag);
      if (directIndex !== -1) {
        const candidate = argv[directIndex + 1];
        if (candidate && !candidate.startsWith("-")) {
          return candidate;
        }
        return null;
      }
      const prefix = `${flag}=`;
      const withEquals = argv.find((arg) => arg.startsWith(prefix));
      if (withEquals) {
        return withEquals.slice(prefix.length);
      }
      return null;
    }
    function parseOptionalInt(value) {
      if (!value) {
        return null;
      }
      const parsed = Number.parseInt(value, 10);
      if (Number.isNaN(parsed)) {
        return null;
      }
      return parsed;
    }
    function normalizePathDisplayMode(value) {
      if (!value) {
        return null;
      }
      switch (value.toLowerCase()) {
        case "relative":
          return "relative";
        case "absolute":
          return "absolute";
        case "abbreviated":
        case "abbr":
        case "fish":
          return "abbreviated";
        default:
          return null;
      }
    }
    function parsePathDisplay(value) {
      if (!value) {
        return { mode: null, abbrevLength: null };
      }
      const [modePart, lengthPart] = value.split(":", 2);
      const mode = normalizePathDisplayMode(modePart);
      const abbrevLength = parseOptionalInt(lengthPart);
      return { mode, abbrevLength };
    }
    function splitLookupList(value) {
      return value.split(",").map((entry) => entry.trim()).filter(Boolean);
    }
    function resolveLookupFiles(argv, env) {
      const cliFiles = [];
      for (let i = 0; i < argv.length; i++) {
        const arg = argv[i];
        if (arg === "--lookup-files" && argv[i + 1] && !argv[i + 1].startsWith("-")) {
          cliFiles.push(...splitLookupList(argv[i + 1]));
          i++;
          continue;
        }
        if (arg.startsWith("--lookup-files=")) {
          cliFiles.push(...splitLookupList(arg.slice("--lookup-files=".length)));
          continue;
        }
        if (arg === "--lookup-file" && argv[i + 1] && !argv[i + 1].startsWith("-")) {
          cliFiles.push(argv[i + 1]);
          i++;
          continue;
        }
        if (arg.startsWith("--lookup-file=")) {
          cliFiles.push(arg.slice("--lookup-file=".length));
        }
      }
      if (cliFiles.length > 0) {
        return cliFiles;
      }
      const envValue = env.CSS_LSP_LOOKUP_FILES;
      if (envValue) {
        const envFiles = splitLookupList(envValue);
        if (envFiles.length > 0) {
          return envFiles;
        }
      }
      return void 0;
    }
    function resolveIgnoreGlobs(argv, env) {
      const cliGlobs = [];
      for (let i = 0; i < argv.length; i++) {
        const arg = argv[i];
        if (arg === "--ignore-globs" && argv[i + 1] && !argv[i + 1].startsWith("-")) {
          cliGlobs.push(...splitLookupList(argv[i + 1]));
          i++;
          continue;
        }
        if (arg.startsWith("--ignore-globs=")) {
          cliGlobs.push(...splitLookupList(arg.slice("--ignore-globs=".length)));
          continue;
        }
        if (arg === "--ignore-glob" && argv[i + 1] && !argv[i + 1].startsWith("-")) {
          cliGlobs.push(argv[i + 1]);
          i++;
          continue;
        }
        if (arg.startsWith("--ignore-glob=")) {
          cliGlobs.push(arg.slice("--ignore-glob=".length));
        }
      }
      if (cliGlobs.length > 0) {
        return cliGlobs;
      }
      const envValue = env.CSS_LSP_IGNORE_GLOBS;
      if (envValue) {
        const envGlobs = splitLookupList(envValue);
        if (envGlobs.length > 0) {
          return envGlobs;
        }
      }
      return void 0;
    }
    function buildRuntimeConfig(argv, env) {
      const enableColorProvider = !argv.includes("--no-color-preview");
      const colorOnlyOnVariables = argv.includes("--color-only-variables") || env.CSS_LSP_COLOR_ONLY_VARIABLES === "1";
      const lookupFiles = resolveLookupFiles(argv, env);
      const ignoreGlobs = resolveIgnoreGlobs(argv, env);
      const pathDisplayArg = getArgValue(argv, "path-display");
      const pathDisplayEnv = env.CSS_LSP_PATH_DISPLAY;
      const parsedPathDisplay = parsePathDisplay(pathDisplayArg ?? pathDisplayEnv);
      const pathDisplayMode = parsedPathDisplay.mode ?? "relative";
      const pathDisplayLengthArg = getArgValue(argv, "path-display-length");
      const pathDisplayLengthEnv = env.CSS_LSP_PATH_DISPLAY_LENGTH;
      const abbrevLengthRaw = parseOptionalInt(pathDisplayLengthArg ?? pathDisplayLengthEnv) ?? parsedPathDisplay.abbrevLength;
      const pathDisplayAbbrevLength = Math.max(0, abbrevLengthRaw ?? 1);
      return {
        enableColorProvider,
        colorOnlyOnVariables,
        lookupFiles,
        ignoreGlobs,
        pathDisplayMode,
        pathDisplayAbbrevLength
      };
    }
  }
});

// node_modules/css-variable-lsp/out/server.js
Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = require_node3();
var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
var path = require("path");
var vscode_uri_1 = require_umd();
var cssVariableManager_1 = require_cssVariableManager();
var colorProvider_1 = require_colorProvider();
var initialize_1 = require_initialize();
var pathDisplay_1 = require_pathDisplay();
var runtimeConfig_1 = require_runtimeConfig();
var specificity_1 = require_specificity();
var runtimeConfig = (0, runtimeConfig_1.buildRuntimeConfig)(process.argv.slice(2), process.env);
var connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
function logDebug(label, payload) {
  if (process.env.CSS_LSP_DEBUG) {
    const message = `[css-lsp] ${label} ${JSON.stringify(payload)}`;
    connection.console.log(message);
  }
}
function updateWorkspaceFolderPaths(folders) {
  if (!folders) {
    workspaceFolderPaths = [];
    return;
  }
  const paths = folders.map((folder) => (0, pathDisplay_1.toNormalizedFsPath)(folder.uri)).filter((folderPath) => Boolean(folderPath));
  workspaceFolderPaths = paths.toSorted((a, b) => b.length - a.length);
}
var documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
var cssVariableManager = new cssVariableManager_1.CssVariableManager(connection.console, runtimeConfig.lookupFiles, runtimeConfig.ignoreGlobs);
var hasWorkspaceFolderCapability = false;
var hasDiagnosticRelatedInformationCapability = false;
var workspaceFolderPaths = [];
var rootFolderPath = null;
connection.onInitialize((params) => {
  logDebug("initialize", {
    rootUri: params.rootUri,
    // rootPath is deprecated and optional in InitializeParams
    rootPath: params.rootPath,
    workspaceFolders: params.workspaceFolders,
    capabilities: params.capabilities
  });
  const capabilities = params.capabilities;
  hasWorkspaceFolderCapability = !!(capabilities.workspace && !!capabilities.workspace.workspaceFolders);
  hasDiagnosticRelatedInformationCapability = !!(capabilities.textDocument && capabilities.textDocument.publishDiagnostics && capabilities.textDocument.publishDiagnostics.relatedInformation);
  if (params.rootUri) {
    try {
      rootFolderPath = path.normalize(vscode_uri_1.URI.parse(params.rootUri).fsPath);
    } catch {
      rootFolderPath = null;
    }
  } else if (params.rootPath) {
    rootFolderPath = path.normalize(params.rootPath);
  }
  updateWorkspaceFolderPaths(params.workspaceFolders || void 0);
  return (0, initialize_1.buildInitializeResult)(runtimeConfig.enableColorProvider, hasWorkspaceFolderCapability);
});
connection.onInitialized(async () => {
  if (hasWorkspaceFolderCapability) {
    connection.workspace.onDidChangeWorkspaceFolders((_event) => {
      connection.console.log("Workspace folder change event received.");
      void connection.workspace.getWorkspaceFolders().then((folders) => {
        updateWorkspaceFolderPaths(folders || void 0);
      });
    });
  }
  const workspaceFolders = await connection.workspace.getWorkspaceFolders();
  if (workspaceFolders) {
    updateWorkspaceFolderPaths(workspaceFolders || void 0);
    connection.console.log("Scanning workspace for CSS variables...");
    const folderUris = workspaceFolders.map((f) => f.uri);
    let lastLoggedPercentage = 0;
    await cssVariableManager.scanWorkspace(folderUris, (current, total) => {
      const percentage = Math.round(current / total * 100);
      if (percentage - lastLoggedPercentage >= 20 || current === total) {
        connection.console.log(`Scanning CSS files: ${current}/${total} (${percentage}%)`);
        lastLoggedPercentage = percentage;
      }
    });
    const totalVars = cssVariableManager.getAllVariables().length;
    connection.console.log(`Workspace scan complete. Found ${totalVars} CSS variables.`);
    documents.all().forEach(validateTextDocument);
  }
});
documents.onDidClose(async (e) => {
  connection.console.log(`[css-lsp] Document closed: ${e.document.uri}`);
  await cssVariableManager.updateFile(e.document.uri);
});
var validationTimeouts = /* @__PURE__ */ new Map();
documents.onDidChangeContent((change) => {
  cssVariableManager.parseDocument(change.document);
  const uri = change.document.uri;
  const existingTimeout = validationTimeouts.get(uri);
  if (existingTimeout) {
    clearTimeout(existingTimeout);
  }
  const timeout = setTimeout(() => {
    validateTextDocument(change.document);
    validationTimeouts.delete(uri);
  }, 300);
  validationTimeouts.set(uri, timeout);
});
async function validateTextDocument(textDocument) {
  const text = textDocument.getText();
  const diagnostics = [];
  const usageRegex = /var\((--[\w-]+)(?:\s*,\s*[^)]+)?\)/g;
  let match;
  while ((match = usageRegex.exec(text)) !== null) {
    const variableName = match[1];
    const definitions = cssVariableManager.getVariables(variableName);
    if (definitions.length === 0) {
      const startPos = textDocument.positionAt(match.index);
      const endPos = textDocument.positionAt(match.index + match[0].length);
      const diagnostic = {
        severity: node_1.DiagnosticSeverity.Warning,
        range: {
          start: startPos,
          end: endPos
        },
        message: `CSS variable '${variableName}' is not defined in the workspace`,
        source: "css-variable-lsp"
      };
      if (hasDiagnosticRelatedInformationCapability) {
        diagnostic.relatedInformation = [];
      }
      diagnostics.push(diagnostic);
    }
  }
  connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}
connection.onDidChangeWatchedFiles(async (change) => {
  connection.console.log("Received file change event");
  logDebug("didChangeWatchedFiles", change);
  for (const fileEvent of change.changes) {
    if (fileEvent.type === node_1.FileChangeType.Deleted) {
      cssVariableManager.removeFile(fileEvent.uri);
    } else {
      if (!documents.get(fileEvent.uri)) {
        await cssVariableManager.updateFile(fileEvent.uri);
      }
    }
  }
  documents.all().forEach(validateTextDocument);
});
function getPropertyNameFromContext(beforeCursor) {
  let inBraces = 0;
  let inParens = 0;
  let lastColonPos = -1;
  let lastSemicolonPos = -1;
  let lastBracePos = -1;
  for (let i = beforeCursor.length - 1; i >= 0; i--) {
    const char = beforeCursor[i];
    if (char === ")")
      inParens++;
    else if (char === "(") {
      inParens--;
      if (inParens < 0)
        break;
    } else if (char === "}")
      inBraces++;
    else if (char === "{") {
      inBraces--;
      if (inBraces < 0) {
        lastBracePos = i;
        break;
      }
    } else if (char === ":" && inParens === 0 && inBraces === 0 && lastColonPos === -1) {
      lastColonPos = i;
    } else if (char === ";" && inParens === 0 && inBraces === 0 && lastSemicolonPos === -1) {
      lastSemicolonPos = i;
    }
  }
  if (lastColonPos > lastSemicolonPos && lastColonPos > lastBracePos) {
    const beforeColon = beforeCursor.slice(0, lastColonPos).trim();
    const propertyMatch = beforeColon.match(/([\w-]+)$/);
    if (propertyMatch) {
      return propertyMatch[1].toLowerCase();
    }
  }
  return null;
}
function scoreVariableRelevance(varName, propertyName) {
  if (!propertyName) {
    return -1;
  }
  const lowerVarName = varName.toLowerCase();
  const colorProperties = [
    "color",
    "background-color",
    "background",
    "border-color",
    "outline-color",
    "text-decoration-color",
    "fill",
    "stroke"
  ];
  if (colorProperties.includes(propertyName)) {
    if (lowerVarName.includes("color") || lowerVarName.includes("bg") || lowerVarName.includes("background") || lowerVarName.includes("primary") || lowerVarName.includes("secondary") || lowerVarName.includes("accent") || lowerVarName.includes("text") || lowerVarName.includes("border") || lowerVarName.includes("link")) {
      return 10;
    }
    if (lowerVarName.includes("spacing") || lowerVarName.includes("margin") || lowerVarName.includes("padding") || lowerVarName.includes("size") || lowerVarName.includes("width") || lowerVarName.includes("height") || lowerVarName.includes("font") || lowerVarName.includes("weight") || lowerVarName.includes("radius")) {
      return 0;
    }
    return 5;
  }
  const spacingProperties = [
    "margin",
    "margin-top",
    "margin-right",
    "margin-bottom",
    "margin-left",
    "padding",
    "padding-top",
    "padding-right",
    "padding-bottom",
    "padding-left",
    "gap",
    "row-gap",
    "column-gap"
  ];
  if (spacingProperties.includes(propertyName)) {
    if (lowerVarName.includes("spacing") || lowerVarName.includes("margin") || lowerVarName.includes("padding") || lowerVarName.includes("gap")) {
      return 10;
    }
    if (lowerVarName.includes("color") || lowerVarName.includes("bg") || lowerVarName.includes("background")) {
      return 0;
    }
    return 5;
  }
  const sizeProperties = [
    "width",
    "height",
    "max-width",
    "max-height",
    "min-width",
    "min-height",
    "font-size"
  ];
  if (sizeProperties.includes(propertyName)) {
    if (lowerVarName.includes("width") || lowerVarName.includes("height") || lowerVarName.includes("size")) {
      return 10;
    }
    if (lowerVarName.includes("color") || lowerVarName.includes("bg") || lowerVarName.includes("background")) {
      return 0;
    }
    return 5;
  }
  if (propertyName.includes("radius")) {
    if (lowerVarName.includes("radius") || lowerVarName.includes("rounded")) {
      return 10;
    }
    if (lowerVarName.includes("color") || lowerVarName.includes("bg") || lowerVarName.includes("background")) {
      return 0;
    }
    return 5;
  }
  const fontProperties = ["font-family", "font-weight", "font-style"];
  if (fontProperties.includes(propertyName)) {
    if (lowerVarName.includes("font")) {
      return 10;
    }
    if (lowerVarName.includes("color") || lowerVarName.includes("spacing")) {
      return 0;
    }
    return 5;
  }
  return -1;
}
function isInCssValueContext(document, position) {
  const text = document.getText();
  const offset = document.offsetAt(position);
  const beforeCursor = text.slice(Math.max(0, offset - 200), offset);
  const varMatch = beforeCursor.match(/var\(\s*(--[\w-]*)$/);
  if (varMatch) {
    return true;
  }
  let inBraces = 0;
  let inParens = 0;
  let lastColonPos = -1;
  let lastSemicolonPos = -1;
  let lastBracePos = -1;
  for (let i = beforeCursor.length - 1; i >= 0; i--) {
    const char = beforeCursor[i];
    if (char === ")")
      inParens++;
    else if (char === "(") {
      inParens--;
      if (inParens < 0)
        break;
    } else if (char === "}")
      inBraces++;
    else if (char === "{") {
      inBraces--;
      if (inBraces < 0) {
        lastBracePos = i;
        break;
      }
    } else if (char === ":" && inParens === 0 && inBraces === 0 && lastColonPos === -1) {
      lastColonPos = i;
    } else if (char === ";" && inParens === 0 && inBraces === 0 && lastSemicolonPos === -1) {
      lastSemicolonPos = i;
    }
  }
  if (lastColonPos > lastSemicolonPos && lastColonPos > lastBracePos) {
    const beforeColon = beforeCursor.slice(0, lastColonPos).trim();
    const propertyMatch = beforeColon.match(/[\w-]+$/);
    if (propertyMatch) {
      return true;
    }
  }
  const styleAttrMatch = beforeCursor.match(/style\s*=\s*["'][^"']*:\s*[^"';]*$/i);
  if (styleAttrMatch) {
    return true;
  }
  return false;
}
connection.onCompletion((textDocumentPosition) => {
  const document = documents.get(textDocumentPosition.textDocument.uri);
  if (!document) {
    return [];
  }
  if (!isInCssValueContext(document, textDocumentPosition.position)) {
    return [];
  }
  const text = document.getText();
  const offset = document.offsetAt(textDocumentPosition.position);
  const beforeCursor = text.slice(Math.max(0, offset - 200), offset);
  const propertyName = getPropertyNameFromContext(beforeCursor);
  const variables = cssVariableManager.getAllVariables();
  const uniqueVars = /* @__PURE__ */ new Map();
  variables.forEach((v) => {
    if (!uniqueVars.has(v.name)) {
      uniqueVars.set(v.name, v);
    }
  });
  const scoredVars = Array.from(uniqueVars.values()).map((v) => ({
    variable: v,
    score: scoreVariableRelevance(v.name, propertyName)
  }));
  const filteredAndSorted = scoredVars.filter((sv) => sv.score !== 0).sort((a, b) => {
    if (a.score !== b.score) {
      return b.score - a.score;
    }
    return a.variable.name.localeCompare(b.variable.name);
  });
  return filteredAndSorted.map((sv) => ({
    label: sv.variable.name,
    kind: node_1.CompletionItemKind.Variable,
    detail: sv.variable.value,
    documentation: `Defined in ${(0, pathDisplay_1.formatUriForDisplay)(sv.variable.uri, {
      mode: runtimeConfig.pathDisplayMode,
      abbrevLength: runtimeConfig.pathDisplayAbbrevLength,
      workspaceFolderPaths,
      rootFolderPath
    })}`
  }));
});
connection.onCompletionResolve((item) => {
  return item;
});
connection.onHover((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return void 0;
  }
  const text = document.getText();
  const offset = document.offsetAt(params.position);
  const left = text.slice(0, offset).match(/[\w-]*$/);
  const right = text.slice(offset).match(/^[\w-]*/);
  if (!left || !right) {
    return void 0;
  }
  const word = left[0] + right[0];
  if (word.startsWith("--")) {
    const variables = cssVariableManager.getVariables(word);
    if (variables.length === 0) {
      return void 0;
    }
    const usages = cssVariableManager.getVariableUsages(word);
    const hoverUsage = usages.find((u) => document.positionAt(document.offsetAt(u.range.start)) === params.position || offset >= document.offsetAt(u.range.start) && offset <= document.offsetAt(u.range.end));
    const usageContext = hoverUsage?.usageContext || "";
    const isInlineStyle = usageContext === "inline-style";
    const domTree = cssVariableManager.getDOMTree(document.uri);
    const domNode = hoverUsage?.domNode;
    const sortedVars = [...variables].sort((a, b) => {
      if (a.important !== b.important) {
        return a.important ? -1 : 1;
      }
      const aInline = a.inline ?? false;
      const bInline = b.inline ?? false;
      if (aInline !== bInline) {
        return aInline ? -1 : 1;
      }
      const specA = (0, specificity_1.calculateSpecificity)(a.selector);
      const specB = (0, specificity_1.calculateSpecificity)(b.selector);
      const specCompare = (0, specificity_1.compareSpecificity)(specA, specB);
      if (specCompare !== 0) {
        return -specCompare;
      }
      return b.sourcePosition - a.sourcePosition;
    });
    let hoverText = `### CSS Variable: \`${word}\`

`;
    if (sortedVars.length === 1) {
      const v = sortedVars[0];
      hoverText += `**Value:** \`${v.value}\``;
      if (v.important) {
        hoverText += ` **!important**`;
      }
      hoverText += `

`;
      if (v.selector) {
        hoverText += `**Defined in:** \`${v.selector}\`
`;
        hoverText += `**Specificity:** ${(0, specificity_1.formatSpecificity)((0, specificity_1.calculateSpecificity)(v.selector))}
`;
      }
    } else {
      hoverText += "**Definitions** (CSS cascade order):\n\n";
      sortedVars.forEach((v, index) => {
        const spec = (0, specificity_1.calculateSpecificity)(v.selector);
        const isApplicable = usageContext ? (0, specificity_1.matchesContext)(v.selector, usageContext, domTree, domNode) : true;
        const isWinner = index === 0 && (isApplicable || isInlineStyle);
        let line = `${index + 1}. \`${v.value}\``;
        if (v.important) {
          line += ` **!important**`;
        }
        if (v.selector) {
          line += ` from \`${v.selector}\``;
          line += ` ${(0, specificity_1.formatSpecificity)(spec)}`;
        }
        if (isWinner && usageContext) {
          if (v.important) {
            line += " \u2713 **Wins (!important)**";
          } else if (isInlineStyle) {
            line += " \u2713 **Would apply (inline style)**";
          } else if (domTree && domNode) {
            line += " \u2713 **Applies (DOM match)**";
          } else {
            line += " \u2713 **Applies here**";
          }
        } else if (!isApplicable && usageContext && !isInlineStyle) {
          line += " _(selector doesn't match)_";
        } else if (index > 0 && usageContext) {
          const winner = sortedVars[0];
          if (winner.important && !v.important) {
            line += " _(overridden by !important)_";
          } else {
            const winnerSpec = (0, specificity_1.calculateSpecificity)(winner.selector);
            const cmp = (0, specificity_1.compareSpecificity)(winnerSpec, spec);
            if (cmp > 0) {
              line += " _(lower specificity)_";
            } else if (cmp === 0) {
              line += " _(earlier in source)_";
            }
          }
        }
        hoverText += line + "\n";
      });
      if (usageContext) {
        if (isInlineStyle) {
          hoverText += `
_Context: Inline style (highest priority)_`;
        } else if (domTree && domNode) {
          hoverText += `
_Context: \`${usageContext}\` (DOM-aware matching)_`;
        } else {
          hoverText += `
_Context: \`${usageContext}\`_`;
        }
      }
    }
    return {
      contents: {
        kind: "markdown",
        value: hoverText
      }
    };
  }
  return void 0;
});
connection.onDefinition((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return void 0;
  }
  const text = document.getText();
  const offset = document.offsetAt(params.position);
  const left = text.slice(0, offset).match(/[\w-]*$/);
  const right = text.slice(offset).match(/^[\w-]*/);
  if (!left || !right) {
    return void 0;
  }
  const word = left[0] + right[0];
  if (word.startsWith("--")) {
    const variables = cssVariableManager.getVariables(word);
    if (variables.length > 0) {
      return {
        uri: variables[0].uri,
        range: variables[0].range
      };
    }
  }
  return void 0;
});
connection.onReferences((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }
  const text = document.getText();
  const offset = document.offsetAt(params.position);
  const left = text.slice(0, offset).match(/[\w-]*$/);
  const right = text.slice(offset).match(/^[\w-]*/);
  if (!left || !right) {
    return [];
  }
  const word = left[0] + right[0];
  if (word.startsWith("--")) {
    const references = cssVariableManager.getReferences(word);
    return references.map((ref) => node_1.Location.create(ref.uri, ref.range));
  }
  return [];
});
connection.onRenameRequest((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return null;
  }
  const text = document.getText();
  const offset = document.offsetAt(params.position);
  const left = text.slice(0, offset).match(/[\w-]*$/);
  const right = text.slice(offset).match(/^[\w-]*/);
  if (!left || !right) {
    return null;
  }
  const word = left[0] + right[0];
  if (word.startsWith("--")) {
    const references = cssVariableManager.getReferences(word);
    const changes = {};
    for (const ref of references) {
      if (!changes[ref.uri]) {
        changes[ref.uri] = [];
      }
      const editRange = ref.nameRange ?? ref.range;
      const edit = {
        range: editRange,
        newText: params.newName
      };
      changes[ref.uri].push(edit);
    }
    return { changes };
  }
  return null;
});
connection.onDocumentSymbol((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }
  const variables = cssVariableManager.getDocumentDefinitions(document.uri);
  return variables.map((v) => node_1.DocumentSymbol.create(v.name, v.value, node_1.SymbolKind.Variable, v.range, v.range));
});
connection.onWorkspaceSymbol((params) => {
  const query = params.query.toLowerCase();
  const allVariables = cssVariableManager.getAllDefinitions();
  const filtered = query ? allVariables.filter((v) => v.name.toLowerCase().includes(query)) : allVariables;
  return filtered.map((v) => node_1.WorkspaceSymbol.create(v.name, node_1.SymbolKind.Variable, v.uri, v.range));
});
connection.onDocumentColor((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }
  return (0, colorProvider_1.collectDocumentColors)(document, cssVariableManager, {
    enabled: runtimeConfig.enableColorProvider,
    onlyVariables: runtimeConfig.colorOnlyOnVariables
  });
});
connection.onColorPresentation((params) => {
  const color = params.color;
  const range = params.range;
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }
  return (0, colorProvider_1.collectColorPresentations)(range, color, runtimeConfig.enableColorProvider);
});
documents.listen(connection);
connection.listen();
/*! Bundled license information:

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)
*/
//# sourceMappingURL=server.js.map
